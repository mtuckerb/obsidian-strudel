typeof BigInt > "u" && (BigInt = function(e) {
  if (isNaN(e)) throw new Error("");
  return e;
});
const ie = BigInt(0), de = BigInt(1), Hr = BigInt(2), Ks = BigInt(5), dt = BigInt(10), sy = 2e3, H = {
  s: de,
  n: ie,
  d: de
};
function fn(e, t) {
  try {
    e = BigInt(e);
  } catch {
    throw xn();
  }
  return e * t;
}
function Lt(e) {
  return typeof e == "bigint" ? e : Math.floor(e);
}
function Xe(e, t) {
  if (t === ie)
    throw bu();
  const n = Object.create(Re.prototype);
  n.s = e < ie ? -de : de, e = e < ie ? -e : e;
  const r = Zn(e, t);
  return n.n = e / r, n.d = t / r, n;
}
function or(e) {
  const t = {};
  let n = e, r = Hr, i = Ks - de;
  for (; i <= n; ) {
    for (; n % r === ie; )
      n /= r, t[r] = (t[r] || ie) + de;
    i += de + Hr * r++;
  }
  return n !== e ? n > 1 && (t[n] = (t[n] || ie) + de) : t[e] = (t[e] || ie) + de, t;
}
const et = function(e, t) {
  let n = ie, r = de, i = de;
  if (e != null) if (t !== void 0) {
    if (typeof e == "bigint")
      n = e;
    else {
      if (isNaN(e))
        throw xn();
      if (e % 1 !== 0)
        throw Ka();
      n = BigInt(e);
    }
    if (typeof t == "bigint")
      r = t;
    else {
      if (isNaN(t))
        throw xn();
      if (t % 1 !== 0)
        throw Ka();
      r = BigInt(t);
    }
    i = n * r;
  } else if (typeof e == "object") {
    if ("d" in e && "n" in e)
      n = BigInt(e.n), r = BigInt(e.d), "s" in e && (n *= BigInt(e.s));
    else if (0 in e)
      n = BigInt(e[0]), 1 in e && (r = BigInt(e[1]));
    else if (typeof e == "bigint")
      n = e;
    else
      throw xn();
    i = n * r;
  } else if (typeof e == "number") {
    if (isNaN(e))
      throw xn();
    if (e < 0 && (i = -de, e = -e), e % 1 === 0)
      n = BigInt(e);
    else if (e > 0) {
      let s = 1, u = 0, a = 1, o = 1, f = 1, h = 1e7;
      for (e >= 1 && (s = 10 ** Math.floor(1 + Math.log10(e)), e /= s); a <= h && f <= h; ) {
        let m = (u + o) / (a + f);
        if (e === m) {
          a + f <= h ? (n = u + o, r = a + f) : f > a ? (n = o, r = f) : (n = u, r = a);
          break;
        } else
          e > m ? (u += o, a += f) : (o += u, f += a), a > h ? (n = o, r = f) : (n = u, r = a);
      }
      n = BigInt(n) * BigInt(s), r = BigInt(r);
    }
  } else if (typeof e == "string") {
    let s = 0, u = ie, a = ie, o = ie, f = de, h = de, m = e.replace(/_/g, "").match(/\d+|./g);
    if (m === null)
      throw xn();
    if (m[s] === "-" ? (i = -de, s++) : m[s] === "+" && s++, m.length === s + 1 ? a = fn(m[s++], i) : m[s + 1] === "." || m[s] === "." ? (m[s] !== "." && (u = fn(m[s++], i)), s++, (s + 1 === m.length || m[s + 1] === "(" && m[s + 3] === ")" || m[s + 1] === "'" && m[s + 3] === "'") && (a = fn(m[s], i), f = dt ** BigInt(m[s].length), s++), (m[s] === "(" && m[s + 2] === ")" || m[s] === "'" && m[s + 2] === "'") && (o = fn(m[s + 1], i), h = dt ** BigInt(m[s + 1].length) - de, s += 3)) : m[s + 1] === "/" || m[s + 1] === ":" ? (a = fn(m[s], i), f = fn(m[s + 2], de), s += 3) : m[s + 3] === "/" && m[s + 1] === " " && (u = fn(m[s], i), a = fn(m[s + 2], i), f = fn(m[s + 4], de), s += 5), m.length <= s)
      r = f * h, i = /* void */
      n = o + r * u + h * a;
    else
      throw xn();
  } else if (typeof e == "bigint")
    n = e, i = e, r = de;
  else
    throw xn();
  if (r === ie)
    throw bu();
  H.s = i < ie ? -de : de, H.n = n < ie ? -n : n, H.d = r < ie ? -r : r;
};
function uy(e, t, n) {
  let r = de;
  for (; t > ie; e = e * e % n, t >>= de)
    t & de && (r = r * e % n);
  return r;
}
function ay(e, t) {
  for (; t % Hr === ie; t /= Hr)
    ;
  for (; t % Ks === ie; t /= Ks)
    ;
  if (t === de)
    return ie;
  let n = dt % t, r = 1;
  for (; n !== de; r++)
    if (n = n * dt % t, r > sy)
      return ie;
  return BigInt(r);
}
function oy(e, t, n) {
  let r = de, i = uy(dt, n, t);
  for (let s = 0; s < 300; s++) {
    if (r === i)
      return BigInt(s);
    r = r * dt % t, i = i * dt % t;
  }
  return 0;
}
function Zn(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  for (; ; ) {
    if (e %= t, !e)
      return t;
    if (t %= e, !t)
      return e;
  }
}
function Re(e, t) {
  if (et(e, t), this instanceof Re)
    e = Zn(H.d, H.n), this.s = H.s, this.n = H.n / e, this.d = H.d / e;
  else
    return Xe(H.s * H.n, H.d);
}
var bu = function() {
  return new Error("Division by Zero");
}, xn = function() {
  return new Error("Invalid argument");
}, Ka = function() {
  return new Error("Parameters must be integer");
};
Re.prototype = {
  s: de,
  n: ie,
  d: de,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return Xe(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return Xe(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(e, t) {
    return et(e, t), Xe(
      this.s * this.n * H.d + H.s * this.d * H.n,
      this.d * H.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(e, t) {
    return et(e, t), Xe(
      this.s * this.n * H.d - H.s * this.d * H.n,
      this.d * H.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(e, t) {
    return et(e, t), Xe(
      this.s * H.s * this.n * H.n,
      this.d * H.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(e, t) {
    return et(e, t), Xe(
      this.s * H.s * this.n * H.d,
      this.d * H.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return Xe(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
   **/
  mod: function(e, t) {
    if (e === void 0)
      return Xe(this.s * this.n % this.d, de);
    if (et(e, t), ie === H.n * this.d)
      throw bu();
    return Xe(
      this.s * (H.d * this.n) % (H.n * this.d),
      H.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(e, t) {
    return et(e, t), Xe(Zn(H.n, this.n) * Zn(H.d, this.d), H.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(e, t) {
    return et(e, t), H.n === ie && this.n === ie ? Xe(ie, de) : Xe(H.n * this.n, Zn(H.n, this.n) * Zn(H.d, this.d));
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return Xe(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some integer exponent
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(e, t) {
    if (et(e, t), H.d === de)
      return H.s < ie ? Xe((this.s * this.d) ** H.n, this.n ** H.n) : Xe((this.s * this.n) ** H.n, this.d ** H.n);
    if (this.s < ie) return null;
    let n = or(this.n), r = or(this.d), i = de, s = de;
    for (let u in n)
      if (u !== "1") {
        if (u === "0") {
          i = ie;
          break;
        }
        if (n[u] *= H.n, n[u] % H.d === ie)
          n[u] /= H.d;
        else return null;
        i *= BigInt(u) ** n[u];
      }
    for (let u in r)
      if (u !== "1") {
        if (r[u] *= H.n, r[u] % H.d === ie)
          r[u] /= H.d;
        else return null;
        s *= BigInt(u) ** r[u];
      }
    return H.s < ie ? Xe(s, i) : Xe(i, s);
  },
  /**
   * Calculates the logarithm of a fraction to a given rational base
   *
   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
   */
  log: function(e, t) {
    if (et(e, t), this.s <= ie || H.s <= ie) return null;
    const n = {}, r = or(H.n), i = or(H.d), s = or(this.n), u = or(this.d);
    for (const f in i)
      r[f] = (r[f] || ie) - i[f];
    for (const f in u)
      s[f] = (s[f] || ie) - u[f];
    for (const f in r)
      f !== "1" && (n[f] = !0);
    for (const f in s)
      f !== "1" && (n[f] = !0);
    let a = null, o = null;
    for (const f in n) {
      const h = r[f] || ie, m = s[f] || ie;
      if (h === ie) {
        if (m !== ie)
          return null;
        continue;
      }
      let p = m, b = h;
      const M = Zn(p, b);
      if (p /= M, b /= M, a === null && o === null)
        a = p, o = b;
      else if (p * o !== a * b)
        return null;
    }
    return a !== null && o !== null ? Xe(a, o) : null;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(e, t) {
    return et(e, t), this.s * this.n * H.d === H.s * H.n * this.d;
  },
  /**
   * Check if this rational number is less than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lt: function(e, t) {
    return et(e, t), this.s * this.n * H.d < H.s * H.n * this.d;
  },
  /**
   * Check if this rational number is less than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lte: function(e, t) {
    return et(e, t), this.s * this.n * H.d <= H.s * H.n * this.d;
  },
  /**
   * Check if this rational number is greater than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gt: function(e, t) {
    return et(e, t), this.s * this.n * H.d > H.s * H.n * this.d;
  },
  /**
   * Check if this rational number is greater than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gte: function(e, t) {
    return et(e, t), this.s * this.n * H.d >= H.s * H.n * this.d;
  },
  /**
   * Compare two rational numbers
   * < 0 iff this < that
   * > 0 iff this > that
   * = 0 iff this = that
   *
   * Ex: new Fraction(19.6).compare([98, 5]);
   **/
  compare: function(e, t) {
    et(e, t);
    let n = this.s * this.n * H.d - H.s * H.n * this.d;
    return (ie < n) - (n < ie);
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(e) {
    return e = dt ** BigInt(e || 0), Xe(
      Lt(this.s * e * this.n / this.d) + (e * this.n % this.d > ie && this.s >= ie ? de : ie),
      e
    );
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(e) {
    return e = dt ** BigInt(e || 0), Xe(
      Lt(this.s * e * this.n / this.d) - (e * this.n % this.d > ie && this.s < ie ? de : ie),
      e
    );
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(e) {
    return e = dt ** BigInt(e || 0), Xe(
      Lt(this.s * e * this.n / this.d) + this.s * ((this.s >= ie ? de : ie) + Hr * (e * this.n % this.d) > this.d ? de : ie),
      e
    );
  },
  /**
    * Rounds a rational number to a multiple of another rational number
    *
    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
    **/
  roundTo: function(e, t) {
    et(e, t);
    const n = this.n * H.d, r = this.d * H.n, i = n % r;
    let s = Lt(n / r);
    return i + i >= r && s++, Xe(this.s * s * H.n, H.d);
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(e, t) {
    return et(e, t), !(!(H.n * this.d) || this.n * H.d % (H.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return Number(this.s * this.n) / Number(this.d);
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(e) {
    let t = this.n, n = this.d;
    e = e || 15;
    let r = ay(t, n), i = oy(t, n, r), s = this.s < ie ? "-" : "";
    if (s += Lt(t / n), t %= n, t *= dt, t && (s += "."), r) {
      for (let u = i; u--; )
        s += Lt(t / n), t %= n, t *= dt;
      s += "(";
      for (let u = r; u--; )
        s += Lt(t / n), t %= n, t *= dt;
      s += ")";
    } else
      for (let u = e; t && u--; )
        s += Lt(t / n), t %= n, t *= dt;
    return s;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
   **/
  toFraction: function(e) {
    let t = this.n, n = this.d, r = this.s < ie ? "-" : "";
    if (n === de)
      r += t;
    else {
      let i = Lt(t / n);
      e && i > ie && (r += i, r += " ", t %= n), r += t, r += "/", r += n;
    }
    return r;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(e) {
    let t = this.n, n = this.d, r = this.s < ie ? "-" : "";
    if (n === de)
      r += t;
    else {
      let i = Lt(t / n);
      e && i > ie && (r += i, t %= n), r += "\\frac{", r += t, r += "}{", r += n, r += "}";
    }
    return r;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    let e = this.n, t = this.d, n = [];
    do {
      n.push(Lt(e / t));
      let r = e % t;
      e = t, t = r;
    } while (e !== de);
    return n;
  },
  simplify: function(e) {
    const t = BigInt(1 / (e || 1e-3) | 0), n = this.abs(), r = n.toContinued();
    for (let i = 1; i < r.length; i++) {
      let s = Xe(r[i - 1], de);
      for (let a = i - 2; a >= 0; a--)
        s = s.inverse().add(r[a]);
      let u = s.sub(n);
      if (u.n * t < u.d)
        return s.mul(this.s);
    }
    return this;
  }
};
const Mu = "strudel.log";
let cy = 1e3, Ha, Ua;
function Je(e, t, n = {}) {
  let r = performance.now();
  Ha === e && r - Ua < cy || (Ha = e, Ua = r, console.log(`%c${e}`, "background-color: black;color:white;border-radius:15px"), typeof document < "u" && typeof CustomEvent < "u" && document.dispatchEvent(
    new CustomEvent(Mu, {
      detail: {
        message: e,
        type: t,
        data: n
      }
    })
  ));
}
Je.key = Mu;
const ly = (e) => /^[a-gA-G][#bs]*[0-9]$/.test(e), Un = (e) => /^[a-gA-G][#bsf]*[0-9]?$/.test(e), cc = (e) => {
  if (typeof e != "string")
    return [];
  const [t, n = "", r] = e.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return t ? [t, n, r ? Number(r) : void 0] : [];
}, fy = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, hy = { "#": 1, b: -1, s: 1, f: -1 }, In = (e, t = 3) => {
  const [n, r, i = t] = cc(e);
  if (!n)
    throw new Error('not a note: "' + e + '"');
  const s = fy[n.toLowerCase()], u = r?.split("").reduce((a, o) => a + hy[o], 0) || 0;
  return (Number(i) + 1) * 12 + s + u;
}, qn = (e) => Math.pow(2, (e - 69) / 12) * 440, Cu = (e) => 12 * Math.log(e / 440) / Math.LN2 + 69, py = (e, t) => {
  if (typeof e != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: r } = e;
  if (typeof n == "number")
    return Cu(n);
  if (typeof r == "string")
    return In(r);
  if (typeof r == "number")
    return r;
  if (!t)
    throw new Error("valueToMidi: expected freq or note to be set");
  return t;
}, dy = (e, t) => (e - t) * 1e3, lc = (e) => qn(typeof e == "number" ? e : In(e)), my = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], gy = (e) => {
  const t = Math.floor(e / 12) - 1;
  return my[e % 12] + t;
}, St = (e, t) => (e % t + t) % t, fc = (e) => e.reduce((t, n) => t + n) / e.length;
function hc(e, t = 0) {
  return isNaN(Number(e)) ? (Je(`"${e}" is not a number, falling back to ${t}`, "warning"), t) : e;
}
const yy = (e, t) => St(Math.round(hc(e ?? 0, 0)), t), Ay = (e) => {
  let { value: t, context: n } = e, r = t;
  if (typeof r == "object" && !Array.isArray(r) && (r = r.note || r.n || r.value, r === void 0))
    throw new Error(`cannot find a playable note for ${JSON.stringify(t)}`);
  if (typeof r == "number" && n.type !== "frequency")
    r = qn(e.value);
  else if (typeof r == "number" && n.type === "frequency")
    r = e.value;
  else if (typeof r != "string" || !Un(r))
    throw new Error("not a note: " + JSON.stringify(r));
  return r;
}, pc = (e) => {
  let { value: t, context: n } = e;
  if (typeof t == "object")
    return t.freq ? t.freq : lc(t.note || t.n || t.value);
  if (typeof t == "number" && n.type !== "frequency")
    t = qn(e.value);
  else if (typeof t == "string" && Un(t))
    t = qn(In(e.value));
  else if (typeof t != "number")
    throw new Error("not a note or frequency: " + t);
  return t;
}, dc = (e, t) => e.slice(t).concat(e.slice(0, t)), mc = (...e) => e.reduce(
  (t, n) => (...r) => t(n(...r)),
  (t) => t
), by = (...e) => mc(...e.reverse()), Mr = (e) => e.filter((t) => t != null), dn = (e) => [].concat(...e), cr = (e) => e, My = (e, t) => e, vu = (e, t) => Array.from({ length: t - e + 1 }, (n, r) => r + e);
function me(e, t, n = e.length) {
  const r = function i(...s) {
    if (s.length >= n)
      return e.apply(this, s);
    {
      const u = function(...a) {
        return i.apply(this, s.concat(a));
      };
      return t && t(u, s), u;
    }
  };
  return t && t(r, []), r;
}
function Pu(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  if (Un(e))
    return In(e);
  throw new Error(`cannot parse as numeral: "${e}"`);
}
function Du(e, t) {
  return (...n) => e(...n.map(t));
}
function Mt(e) {
  return Du(e, Pu);
}
function gc(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  const n = {
    pi: Math.PI,
    w: 1,
    h: 0.5,
    q: 0.25,
    e: 0.125,
    s: 0.0625,
    t: 1 / 3,
    f: 0.2,
    x: 1 / 6
  }[e];
  if (typeof n < "u")
    return n;
  throw new Error(`cannot parse as fractional: "${e}"`);
}
const Cy = (e) => Du(e, gc), Fu = function(e, t) {
  return [t.slice(0, e), t.slice(e)];
}, Eu = (e, t, n) => t.map((r, i) => e(r, n[i])), yc = function(e) {
  const t = [];
  for (let n = 0; n < e.length - 1; ++n)
    t.push([e[n], e[n + 1]]);
  return t;
}, Ri = (e, t, n) => Math.min(Math.max(e, t), n), vy = ["Do", "Reb", "Re", "Mib", "Mi", "Fa", "Solb", "Sol", "Lab", "La", "Sib", "Si"], Py = [
  "Sa",
  "Re",
  "Ga",
  "Ma",
  "Pa",
  "Dha",
  "Ni"
], Dy = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Hb", "H"], Fy = [
  "Ni",
  "Pab",
  "Pa",
  "Voub",
  "Vou",
  "Ga",
  "Dib",
  "Di",
  "Keb",
  "Ke",
  "Zob",
  "Zo"
], Ey = [
  "I",
  "Ro",
  "Ha",
  "Ni",
  "Ho",
  "He",
  "To"
], xy = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], wy = (e, t = "letters") => {
  const r = (t === "solfeggio" ? vy : t === "indian" ? Py : t === "german" ? Dy : t === "byzantine" ? Fy : t === "japanese" ? Ey : xy)[e % 12], i = Math.floor(e / 12) - 1;
  return r + i;
};
function Sy(e) {
  var t = {};
  return e.filter(function(n) {
    return t.hasOwn(n) ? !1 : t[n] = !0;
  });
}
function By(e) {
  return e.sort().filter(function(t, n, r) {
    return !n || t != r[n - 1];
  });
}
function Ac(e) {
  return e.sort((t, n) => t.compare(n)).filter(function(t, n, r) {
    return !n || t.ne(r[n - 1]);
  });
}
function bc(e) {
  const t = new TextEncoder().encode(e);
  return btoa(String.fromCharCode(...t));
}
function Mc(e) {
  const t = new Uint8Array(
    atob(e).split("").map((r) => r.charCodeAt(0))
  );
  return new TextDecoder().decode(t);
}
function _y(e) {
  return encodeURIComponent(bc(e));
}
function ky(e) {
  return Mc(decodeURIComponent(e));
}
function Cc(e, t) {
  return Array.isArray(e) ? e.map(t) : Object.fromEntries(Object.entries(e).map(([n, r], i) => [n, t(r, n, i)]));
}
function Hs(e, t) {
  return e / t;
}
class vc {
  constructor({
    getTargetClockTime: t = Vy,
    weight: n = 16,
    offsetDelta: r = 5e-3,
    checkAfterTime: i = 2,
    resetAfterTime: s = 8
  }) {
    this.offsetTime, this.timeAtPrevOffsetSample, this.prevOffsetTimes = [], this.getTargetClockTime = t, this.weight = n, this.offsetDelta = r, this.checkAfterTime = i, this.resetAfterTime = s, this.reset = () => {
      this.prevOffsetTimes = [], this.offsetTime = null, this.timeAtPrevOffsetSample = null;
    };
  }
  calculateOffset(t) {
    const n = this.getTargetClockTime(), r = n - this.timeAtPrevOffsetSample, i = n - t;
    if (r > this.resetAfterTime && this.reset(), this.offsetTime == null && (this.offsetTime = i), this.prevOffsetTimes.push(i), this.prevOffsetTimes.length > this.weight && this.prevOffsetTimes.shift(), this.timeAtPrevOffsetSample == null || r > this.checkAfterTime) {
      this.timeAtPrevOffsetSample = n;
      const s = fc(this.prevOffsetTimes);
      Math.abs(s - this.offsetTime) > this.offsetDelta && (this.offsetTime = s);
    }
    return this.offsetTime;
  }
  calculateTimestamp(t, n) {
    return this.calculateOffset(t) + n;
  }
}
function Iy() {
  return performance.now() * 1e-3;
}
function Vy() {
  return Date.now() * 1e-3;
}
const Pc = /* @__PURE__ */ new Map([
  ["control", "Control"],
  ["ctrl", "Control"],
  ["alt", "Alt"],
  ["shift", "Shift"],
  ["down", "ArrowDown"],
  ["up", "ArrowUp"],
  ["left", "ArrowLeft"],
  ["right", "ArrowRight"]
]);
let Vr;
function Dc() {
  if (Vr == null) {
    if (typeof window > "u")
      return;
    Vr = {}, window.addEventListener("keydown", (e) => {
      Vr[e.key] = !0;
    }), window.addEventListener("keyup", (e) => {
      Vr[e.key] = !1;
    });
  }
  return { ...Vr };
}
Re.prototype.sam = function() {
  return this.floor();
};
Re.prototype.nextSam = function() {
  return this.sam().add(1);
};
Re.prototype.wholeCycle = function() {
  return new Ue(this.sam(), this.nextSam());
};
Re.prototype.cyclePos = function() {
  return this.sub(this.sam());
};
Re.prototype.lt = function(e) {
  return this.compare(e) < 0;
};
Re.prototype.gt = function(e) {
  return this.compare(e) > 0;
};
Re.prototype.lte = function(e) {
  return this.compare(e) <= 0;
};
Re.prototype.gte = function(e) {
  return this.compare(e) >= 0;
};
Re.prototype.eq = function(e) {
  return this.compare(e) == 0;
};
Re.prototype.ne = function(e) {
  return this.compare(e) != 0;
};
Re.prototype.max = function(e) {
  return this.gt(e) ? this : e;
};
Re.prototype.maximum = function(...e) {
  return e = e.map((t) => new Re(t)), e.reduce((t, n) => n.max(t), this);
};
Re.prototype.min = function(e) {
  return this.lt(e) ? this : e;
};
Re.prototype.mulmaybe = function(e) {
  return e !== void 0 ? this.mul(e) : void 0;
};
Re.prototype.divmaybe = function(e) {
  return e !== void 0 ? this.div(e) : void 0;
};
Re.prototype.addmaybe = function(e) {
  return e !== void 0 ? this.add(e) : void 0;
};
Re.prototype.submaybe = function(e) {
  return e !== void 0 ? this.sub(e) : void 0;
};
Re.prototype.show = function() {
  return this.s * this.n + "/" + this.d;
};
Re.prototype.or = function(e) {
  return this.eq(0) ? e : this;
};
const j = (e) => Re(e), Ny = (...e) => {
  if (e = Mr(e), e.length !== 0)
    return e.reduce((t, n) => t.gcd(n), j(1));
}, Zt = (...e) => {
  if (e = Mr(e), e.length === 0)
    return;
  const t = e.pop();
  return e.reduce(
    (n, r) => n === void 0 || r === void 0 ? void 0 : n.lcm(r),
    t
  );
};
j._original = Re;
class Ue {
  constructor(t, n) {
    this.begin = j(t), this.end = j(n);
  }
  get spanCycles() {
    const t = [];
    var n = this.begin;
    const r = this.end, i = r.sam();
    if (n.equals(r))
      return [new Ue(n, r)];
    for (; r.gt(n); ) {
      if (n.sam().equals(i)) {
        t.push(new Ue(n, this.end));
        break;
      }
      const s = n.nextSam();
      t.push(new Ue(n, s)), n = s;
    }
    return t;
  }
  get duration() {
    return this.end.sub(this.begin);
  }
  cycleArc() {
    const t = this.begin.cyclePos(), n = t.add(this.duration);
    return new Ue(t, n);
  }
  withTime(t) {
    return new Ue(t(this.begin), t(this.end));
  }
  withEnd(t) {
    return new Ue(this.begin, t(this.end));
  }
  withCycle(t) {
    const n = this.begin.sam(), r = n.add(t(this.begin.sub(n))), i = n.add(t(this.end.sub(n)));
    return new Ue(r, i);
  }
  intersection(t) {
    const n = this.begin.max(t.begin), r = this.end.min(t.end);
    if (!n.gt(r) && !(n.equals(r) && (n.equals(this.end) && this.begin.lt(this.end) || n.equals(t.end) && t.begin.lt(t.end))))
      return new Ue(n, r);
  }
  intersection_e(t) {
    const n = this.intersection(t);
    if (n == null)
      throw "TimeSpans do not intersect";
    return n;
  }
  midpoint() {
    return this.begin.add(this.duration.div(j(2)));
  }
  equals(t) {
    return this.begin.equals(t.begin) && this.end.equals(t.end);
  }
  show() {
    return this.begin.show() + " → " + this.end.show();
  }
}
class qe {
  /*
        Event class, representing a value active during the timespan
        'part'. This might be a fragment of an event, in which case the
        timespan will be smaller than the 'whole' timespan, otherwise the
        two timespans will be the same. The 'part' must never extend outside of the
        'whole'. If the event represents a continuously changing value
        then the whole will be returned as None, in which case the given
        value will have been sampled from the point halfway between the
        start and end of the 'part' timespan.
        The context is to store a list of source code locations causing the event.
  
        The word 'Event' is more or less a reserved word in javascript, hence this
        class is named called 'Hap'.
        */
  constructor(t, n, r, i = {}, s = !1) {
    this.whole = t, this.part = n, this.value = r, this.context = i, this.stateful = s, s && console.assert(typeof this.value == "function", "Stateful values must be functions");
  }
  get duration() {
    let t;
    return typeof this.value?.duration == "number" ? t = j(this.value.duration) : t = this.whole.end.sub(this.whole.begin), typeof this.value?.clip == "number" ? t.mul(this.value.clip) : t;
  }
  get endClipped() {
    return this.whole.begin.add(this.duration);
  }
  isActive(t) {
    return this.whole.begin <= t && this.endClipped >= t;
  }
  isInPast(t) {
    return t > this.endClipped;
  }
  isInNearPast(t, n) {
    return n - t <= this.endClipped;
  }
  isInFuture(t) {
    return t < this.whole.begin;
  }
  isInNearFuture(t, n) {
    return n < this.whole.begin && n > this.whole.begin - t;
  }
  isWithinTime(t, n) {
    return this.whole.begin <= n && this.endClipped >= t;
  }
  wholeOrPart() {
    return this.whole ? this.whole : this.part;
  }
  withSpan(t) {
    const n = this.whole ? t(this.whole) : void 0;
    return new qe(n, t(this.part), this.value, this.context);
  }
  withValue(t) {
    return new qe(this.whole, this.part, t(this.value), this.context);
  }
  hasOnset() {
    return this.whole != null && this.whole.begin.equals(this.part.begin);
  }
  hasTag(t) {
    return this.context.tags?.includes(t);
  }
  resolveState(t) {
    if (this.stateful && this.hasOnset()) {
      console.log("stateful");
      const n = this.value, [r, i] = n(t);
      return [r, new qe(this.whole, this.part, i, this.context, !1)];
    }
    return [t, this];
  }
  spanEquals(t) {
    return this.whole == null && t.whole == null || this.whole.equals(t.whole);
  }
  equals(t) {
    return this.spanEquals(t) && this.part.equals(t.part) && // TODO would == be better ??
    this.value === t.value;
  }
  show(t = !1) {
    const n = typeof this.value == "object" ? t ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value;
    var r = "";
    if (this.whole == null)
      r = "~" + this.part.show;
    else {
      var i = this.whole.begin.equals(this.part.begin) && this.whole.end.equals(this.part.end);
      this.whole.begin.equals(this.part.begin) || (r = this.whole.begin.show() + " ⇜ "), i || (r += "("), r += this.part.show(), i || (r += ")"), this.whole.end.equals(this.part.end) || (r += " ⇝ " + this.whole.end.show());
    }
    return "[ " + r + " | " + n + " ]";
  }
  showWhole(t = !1) {
    return `${this.whole == null ? "~" : this.whole.show()}: ${typeof this.value == "object" ? t ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value}`;
  }
  combineContext(t) {
    const n = this;
    return { ...n.context, ...t.context, locations: (n.context.locations || []).concat(t.context.locations || []) };
  }
  setContext(t) {
    return new qe(this.whole, this.part, this.value, t);
  }
  ensureObjectValue() {
    if (typeof this.value != "object")
      throw new Error(
        `expected hap.value to be an object, but got "${this.value}". Hint: append .note() or .s() to the end`,
        "error"
      );
  }
}
class pr {
  constructor(t, n = {}) {
    this.span = t, this.controls = n;
  }
  // Returns new State with different span
  setSpan(t) {
    return new pr(t, this.controls);
  }
  withSpan(t) {
    return this.setSpan(t(this.span));
  }
  // Returns new State with different controls
  setControls(t) {
    return new pr(this.span, t);
  }
}
function Ty(e, t, n) {
  if (t?.value !== void 0 && Object.keys(t).length === 1)
    return Je("[warn]: Can't do arithmetic on control pattern."), e;
  const r = Object.keys(e).filter((i) => Object.keys(t).includes(i));
  return Object.assign({}, e, t, Object.fromEntries(r.map((i) => [i, n(e[i], t[i])])));
}
me((e, t) => e * t);
me((e, t) => t.map(e));
function Fc(e, t = 60) {
  let n = 0, r = j(0), i = [""], s = "";
  for (; i[0].length < t; ) {
    const u = e.queryArc(n, n + 1), a = u.filter((h) => h.hasOnset()).map((h) => h.duration), o = Ny(...a), f = o.inverse();
    i = i.map((h) => h + "|"), s += "|";
    for (let h = 0; h < f; h++) {
      const [m, p] = [r, r.add(o)], b = u.filter((v) => v.whole.begin.lte(m) && v.whole.end.gte(p)), M = b.length - i.length;
      M > 0 && (i = i.concat(Array(M).fill(s))), i = i.map((v, E) => {
        const I = b[E];
        if (I) {
          const X = I.whole.begin.eq(m) ? "" + I.value : "-";
          return v + X;
        }
        return v + ".";
      }), s += ".", r = r.add(o);
    }
    n++;
  }
  return i.join(`
`);
}
let Us, Ot = !0;
const Ry = function(e) {
  Ot = !!e;
}, Ec = (e) => Us = e;
let z = class nt {
  /**
   * Create a pattern. As an end user, you will most likely not create a Pattern directly.
   *
   * @param {function} query - The function that maps a `State` to an array of `Hap`.
   * @noAutocomplete
   */
  constructor(t, n = void 0) {
    this.query = t, this._Pattern = !0, this._steps = n;
  }
  get _steps() {
    return this.__steps;
  }
  set _steps(t) {
    this.__steps = t === void 0 ? void 0 : j(t);
  }
  setSteps(t) {
    return this._steps = t, this;
  }
  withSteps(t) {
    return Ot ? new nt(this.query, this._steps === void 0 ? void 0 : t(this._steps)) : this;
  }
  get hasSteps() {
    return this._steps !== void 0;
  }
  //////////////////////////////////////////////////////////////////////
  // Haskell-style functor, applicative and monadic operations
  /**
   * Returns a new pattern, with the function applied to the value of
   * each hap. It has the alias `fmap`.
   * @synonyms fmap
   * @param {Function} func to to apply to the value
   * @returns Pattern
   * @example
   * "0 1 2".withValue(v => v + 10).log()
   */
  withValue(t) {
    const n = new nt((r) => this.query(r).map((i) => i.withValue(t)));
    return n._steps = this._steps, n;
  }
  // runs func on query state
  withState(t) {
    return this.withHaps((n, r) => (t(r), n));
  }
  /**
   * see `withValue`
   * @noAutocomplete
   */
  fmap(t) {
    return this.withValue(t);
  }
  /**
   * Assumes 'this' is a pattern of functions, and given a function to
   * resolve wholes, applies a given pattern of values to that
   * pattern of functions.
   * @param {Function} whole_func
   * @param {Function} func
   * @noAutocomplete
   * @returns Pattern
   */
  appWhole(t, n) {
    const r = this, i = function(s) {
      const u = r.query(s), a = n.query(s), o = function(f, h) {
        const m = f.part.intersection(h.part);
        if (m != null)
          return new qe(
            t(f.whole, h.whole),
            m,
            f.value(h.value),
            h.combineContext(f)
          );
      };
      return dn(
        u.map((f) => Mr(a.map((h) => o(f, h))))
      );
    };
    return new nt(i);
  }
  /**
   * When this method is called on a pattern of functions, it matches its haps
   * with those in the given pattern of values.  A new pattern is returned, with
   * each matching value applied to the corresponding function.
   *
   * In this `_appBoth` variant, where timespans of the function and value haps
   * are not the same but do intersect, the resulting hap has a timespan of the
   * intersection. This applies to both the part and the whole timespan.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appBoth(t) {
    const n = this, r = function(s, u) {
      if (!(s == null || u == null))
        return s.intersection_e(u);
    }, i = n.appWhole(r, t);
    return Ot && (i._steps = Zt(t._steps, n._steps)), i;
  }
  /**
   * As with `appBoth`, but the `whole` timespan is not the intersection,
   * but the timespan from the function of patterns that this method is called
   * on. In practice, this means that the pattern structure, including onsets,
   * are preserved from the pattern of functions (often referred to as the left
   * hand or inner pattern).
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appLeft(t) {
    const n = this, r = function(s) {
      const u = [];
      for (const a of n.query(s)) {
        const o = t.query(s.setSpan(a.wholeOrPart()));
        for (const f of o) {
          const h = a.whole, m = a.part.intersection(f.part);
          if (m) {
            const p = a.value(f.value), b = f.combineContext(a), M = new qe(h, m, p, b);
            u.push(M);
          }
        }
      }
      return u;
    }, i = new nt(r);
    return i._steps = this._steps, i;
  }
  /**
   * As with `appLeft`, but `whole` timespans are instead taken from the
   * pattern of values, i.e. structure is preserved from the right hand/outer
   * pattern.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appRight(t) {
    const n = this, r = function(s) {
      const u = [];
      for (const a of t.query(s)) {
        const o = n.query(s.setSpan(a.wholeOrPart()));
        for (const f of o) {
          const h = a.whole, m = f.part.intersection(a.part);
          if (m) {
            const p = f.value(a.value), b = a.combineContext(f), M = new qe(h, m, p, b);
            u.push(M);
          }
        }
      }
      return u;
    }, i = new nt(r);
    return i._steps = t._steps, i;
  }
  bindWhole(t, n) {
    const r = this, i = function(s) {
      const u = function(o, f) {
        return new qe(
          t(o.whole, f.whole),
          f.part,
          f.value,
          Object.assign({}, o.context, f.context, {
            locations: (o.context.locations || []).concat(f.context.locations || [])
          })
        );
      }, a = function(o) {
        return n(o.value).query(s.setSpan(o.part)).map((f) => u(o, f));
      };
      return dn(r.query(s).map((o) => a(o)));
    };
    return new nt(i);
  }
  bind(t) {
    const n = function(r, i) {
      if (!(r == null || i == null))
        return r.intersection_e(i);
    };
    return this.bindWhole(n, t);
  }
  join() {
    return this.bind(cr);
  }
  outerBind(t) {
    return this.bindWhole((n) => n, t).setSteps(this._steps);
  }
  outerJoin() {
    return this.outerBind(cr);
  }
  innerBind(t) {
    return this.bindWhole((n, r) => r, t);
  }
  innerJoin() {
    return this.innerBind(cr);
  }
  // Flatterns patterns of patterns, by retriggering/resetting inner patterns at onsets of outer pattern haps
  resetJoin(t = !1) {
    const n = this;
    return new nt((r) => n.discreteOnly().query(r).map((i) => i.value.late(t ? i.whole.begin : i.whole.begin.cyclePos()).query(r).map(
      (s) => new qe(
        // Supports continuous haps in the inner pattern
        s.whole ? s.whole.intersection(i.whole) : void 0,
        s.part.intersection(i.part),
        s.value
      ).setContext(i.combineContext(s))
    ).filter((s) => s.part)).flat());
  }
  restartJoin() {
    return this.resetJoin(!0);
  }
  // Like the other joins above, joins a pattern of patterns of values, into a flatter
  // pattern of values. In this case it takes whole cycles of the inner pattern to fit each event
  // in the outer pattern.
  squeezeJoin() {
    const t = this;
    function n(r) {
      const i = t.discreteOnly().query(r);
      function s(a) {
        const f = a.value._focusSpan(a.wholeOrPart()).query(r.setSpan(a.part));
        function h(m, p) {
          let b;
          if (p.whole && m.whole && (b = p.whole.intersection(m.whole), !b))
            return;
          const M = p.part.intersection(m.part);
          if (!M)
            return;
          const v = p.combineContext(m);
          return new qe(b, M, p.value, v);
        }
        return f.map((m) => h(a, m));
      }
      return dn(i.map(s)).filter((a) => a);
    }
    return new nt(n);
  }
  squeezeBind(t) {
    return this.fmap(t).squeezeJoin();
  }
  polyJoin = function() {
    const t = this;
    return t.fmap((n) => n.extend(t._steps.div(n._steps))).outerJoin();
  };
  polyBind(t) {
    return this.fmap(t).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // Utility methods mainly for internal use
  /**
   * Query haps inside the given time span.
   *
   * @param {Fraction | number} begin from time
   * @param {Fraction | number} end to time
   * @returns Hap[]
   * @example
   * const pattern = sequence('a', ['b', 'c'])
   * const haps = pattern.queryArc(0, 1)
   * console.log(haps)
   * silence
   * @noAutocomplete
   */
  queryArc(t, n, r = {}) {
    try {
      return this.query(new pr(new Ue(t, n), r));
    } catch (i) {
      return Je(`[query]: ${i.message}`, "error"), [];
    }
  }
  /**
   * Returns a new pattern, with queries split at cycle boundaries. This makes
   * some calculations easier to express, as all haps are then constrained to
   * happen within a cycle.
   * @returns Pattern
   * @noAutocomplete
   */
  splitQueries() {
    const t = this, n = (r) => dn(r.span.spanCycles.map((i) => t.query(r.setSpan(i))));
    return new nt(n);
  }
  /**
   * Returns a new pattern, where the given function is applied to the query
   * timespan before passing it to the original pattern.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQuerySpan(t) {
    return new nt((n) => this.query(n.withSpan(t)));
  }
  withQuerySpanMaybe(t) {
    const n = this;
    return new nt((r) => {
      const i = r.withSpan(t);
      return i.span ? n.query(i) : [];
    });
  }
  /**
   * As with `withQuerySpan`, but the function is applied to both the
   * begin and end time of the query timespan.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQueryTime(t) {
    return new nt((n) => this.query(n.withSpan((r) => r.withTime(t))));
  }
  /**
   * Similar to `withQuerySpan`, but the function is applied to the timespans
   * of all haps returned by pattern queries (both `part` timespans, and where
   * present, `whole` timespans).
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHapSpan(t) {
    return new nt((n) => this.query(n).map((r) => r.withSpan(t)));
  }
  /**
   * As with `withHapSpan`, but the function is applied to both the
   * begin and end time of the hap timespans.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withHapTime(t) {
    return this.withHapSpan((n) => n.withTime(t));
  }
  /**
   * Returns a new pattern with the given function applied to the list of haps returned by every query.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHaps(t) {
    const n = new nt((r) => t(this.query(r), r));
    return n._steps = this._steps, n;
  }
  /**
   * As with `withHaps`, but applies the function to every hap, rather than every list of haps.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHap(t) {
    return this.withHaps((n) => n.map(t));
  }
  /**
   * Returns a new pattern with the context field set to every hap set to the given value.
   * @param {*} context
   * @returns Pattern
   * @noAutocomplete
   */
  setContext(t) {
    return this.withHap((n) => n.setContext(t));
  }
  /**
   * Returns a new pattern with the given function applied to the context field of every hap.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withContext(t) {
    const n = this.withHap((r) => r.setContext(t(r.context)));
    return this.__pure !== void 0 && (n.__pure = this.__pure, n.__pure_loc = this.__pure_loc), n;
  }
  /**
   * Returns a new pattern with the context field of every hap set to an empty object.
   * @returns Pattern
   * @noAutocomplete
   */
  stripContext() {
    return this.withHap((t) => t.setContext({}));
  }
  /**
   * Returns a new pattern with the given location information added to the
   * context of every hap.
   * @param {Number} start start offset
   * @param {Number} end end offset
   * @returns Pattern
   * @noAutocomplete
   */
  withLoc(t, n) {
    const r = {
      start: t,
      end: n
    }, i = this.withContext((s) => {
      const u = (s.locations || []).concat([r]);
      return { ...s, locations: u };
    });
    return this.__pure && (i.__pure = this.__pure, i.__pure_loc = r), i;
  }
  /**
   * Returns a new Pattern, which only returns haps that meet the given test.
   * @param {Function} hap_test - a function which returns false for haps to be removed from the pattern
   * @returns Pattern
   * @noAutocomplete
   */
  filterHaps(t) {
    return new nt((n) => this.query(n).filter(t));
  }
  /**
   * As with `filterHaps`, but the function is applied to values
   * inside haps.
   * @param {Function} value_test
   * @returns Pattern
   * @noAutocomplete
   */
  filterValues(t) {
    return new nt((n) => this.query(n).filter((r) => t(r.value))).setSteps(this._steps);
  }
  /**
   * Returns a new pattern, with haps containing undefined values removed from
   * query results.
   * @returns Pattern
   * @noAutocomplete
   */
  removeUndefineds() {
    return this.filterValues((t) => t != null);
  }
  /**
   * Returns a new pattern, with all haps without onsets filtered out. A hap
   * with an onset is one with a `whole` timespan that begins at the same time
   * as its `part` timespan.
   * @returns Pattern
   * @noAutocomplete
   */
  onsetsOnly() {
    return this.filterHaps((t) => t.hasOnset());
  }
  /**
   * Returns a new pattern, with 'continuous' haps (those without 'whole'
   * timespans) removed from query results.
   * @returns Pattern
   * @noAutocomplete
   */
  discreteOnly() {
    return this.filterHaps((t) => t.whole);
  }
  /**
   * Combines adjacent haps with the same value and whole.  Only
   * intended for use in tests.
   * @noAutocomplete
   */
  defragmentHaps() {
    return this.discreteOnly().withHaps((n) => {
      const r = [];
      for (var i = 0; i < n.length; ++i) {
        for (var s = !0, u = n[i]; s; ) {
          const f = JSON.stringify(n[i].value);
          for (var a = !1, o = i + 1; o < n.length; o++) {
            const h = n[o];
            if (u.whole.equals(h.whole)) {
              if (u.part.begin.eq(h.part.end)) {
                if (f === JSON.stringify(h.value)) {
                  u = new qe(u.whole, new Ue(h.part.begin, u.part.end), u.value), n.splice(o, 1), a = !0;
                  break;
                }
              } else if (h.part.begin.eq(u.part.end) && f == JSON.stringify(h.value)) {
                u = new qe(u.whole, new Ue(u.part.begin, h.part.end), u.value), n.splice(o, 1), a = !0;
                break;
              }
            }
          }
          s = a;
        }
        r.push(u);
      }
      return r;
    });
  }
  /**
   * Queries the pattern for the first cycle, returning Haps. Mainly of use when
   * debugging a pattern.
   * @param {Boolean} with_context - set to true, otherwise the context field
   * will be stripped from the resulting haps.
   * @returns [Hap]
   * @noAutocomplete
   */
  firstCycle(t = !1) {
    var n = this;
    return t || (n = n.stripContext()), n.query(new pr(new Ue(j(0), j(1))));
  }
  /**
   * Accessor for a list of values returned by querying the first cycle.
   * @noAutocomplete
   */
  get firstCycleValues() {
    return this.firstCycle().map((t) => t.value);
  }
  /**
   * More human-readable version of the `firstCycleValues` accessor.
   * @noAutocomplete
   */
  get showFirstCycle() {
    return this.firstCycle().map(
      (t) => `${t.value}: ${t.whole.begin.toFraction()} - ${t.whole.end.toFraction()}`
    );
  }
  /**
   * Returns a new pattern, which returns haps sorted in temporal order. Mainly
   * of use when comparing two patterns for equality, in tests.
   * @returns Pattern
   * @noAutocomplete
   */
  sortHapsByPart() {
    return this.withHaps(
      (t) => t.sort(
        (n, r) => n.part.begin.sub(r.part.begin).or(n.part.end.sub(r.part.end)).or(n.whole.begin.sub(r.whole.begin).or(n.whole.end.sub(r.whole.end)))
      )
    );
  }
  asNumber() {
    return this.fmap(Pu);
  }
  //////////////////////////////////////////////////////////////////////
  // Operators - see 'make composers' later..
  _opIn(t, n) {
    return this.fmap(n).appLeft(K(t));
  }
  _opOut(t, n) {
    return this.fmap(n).appRight(K(t));
  }
  _opMix(t, n) {
    return this.fmap(n).appBoth(K(t));
  }
  _opSqueeze(t, n) {
    const r = K(t);
    return this.fmap((i) => r.fmap((s) => n(i)(s))).squeezeJoin();
  }
  _opSqueezeOut(t, n) {
    const r = this;
    return K(t).fmap((s) => r.fmap((u) => n(u)(s))).squeezeJoin();
  }
  _opReset(t, n) {
    return K(t).fmap((i) => this.fmap((s) => n(s)(i))).resetJoin();
  }
  _opRestart(t, n) {
    return K(t).fmap((i) => this.fmap((s) => n(s)(i))).restartJoin();
  }
  _opPoly(t, n) {
    const r = K(t);
    return this.fmap((i) => r.fmap((s) => n(s)(i))).polyJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // End-user methods.
  // Those beginning with an underscore (_) are 'patternified',
  // i.e. versions are created without the underscore, that are
  // magically transformed to accept patterns for all their arguments.
  //////////////////////////////////////////////////////////////////////
  // Methods without corresponding toplevel functions
  /**
   * Layers the result of the given function(s). Like `superimpose`, but without the original pattern:
   * @name layer
   * @memberof Pattern
   * @synonyms apply
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .layer(x=>x.add("0,2"))
   *   .scale('C minor').note()
   */
  layer(...t) {
    return Te(...t.map((n) => n(this)));
  }
  /**
   * Superimposes the result of the given function(s) on top of the original pattern:
   * @name superimpose
   * @memberof Pattern
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .superimpose(x=>x.add(2))
   *   .scale('C minor').note()
   */
  superimpose(...t) {
    return this.stack(...t.map((n) => n(this)));
  }
  //////////////////////////////////////////////////////////////////////
  // Multi-pattern functions
  stack(...t) {
    return Te(this, ...t);
  }
  sequence(...t) {
    return Bt(this, ...t);
  }
  seq(...t) {
    return Bt(this, ...t);
  }
  cat(...t) {
    return _c(this, ...t);
  }
  fastcat(...t) {
    return yt(this, ...t);
  }
  slowcat(...t) {
    return Vn(this, ...t);
  }
  //////////////////////////////////////////////////////////////////////
  // Context methods - ones that deal with metadata
  onTrigger(t, n = !0) {
    return this.withHap(
      (r) => r.setContext({
        ...r.context,
        onTrigger: (...i) => {
          r.context.onTrigger?.(...i), t(...i);
        },
        // if dominantTrigger is set to true, the default output (webaudio) will be disabled
        // when using multiple triggers, you cannot flip this flag to false again!
        // example: x.csound('CooLSynth').log() as well as x.log().csound('CooLSynth') should work the same
        dominantTrigger: r.context.dominantTrigger || n
      })
    );
  }
  log(t = (r, i) => `[hap] ${i.showWhole(!0)}`, n = (r, i) => ({ hap: i })) {
    return this.onTrigger((...r) => {
      Je(t(...r), void 0, n(...r));
    }, !1);
  }
  logValues(t = cr) {
    return this.log((n, r) => t(r.value));
  }
  //////////////////////////////////////////////////////////////////////
  // Visualisation
  drawLine() {
    return console.log(Fc(this)), this;
  }
};
function Ly(e, t) {
  let n = [];
  return t.forEach((r) => {
    const i = n.findIndex(([s]) => e(r, s));
    i === -1 ? n.push([r]) : n[i].push(r);
  }), n;
}
const Gy = (e, t) => e.spanEquals(t);
z.prototype.collect = function() {
  return this.withHaps(
    (e) => Ly(Gy, e).map((t) => new qe(t[0].whole, t[0].part, t, {}))
  );
};
z.prototype.arpWith = function(e) {
  return this.collect().fmap((t) => K(e(t))).innerJoin().withHap((t) => new qe(t.whole, t.part, t.value.value, t.combineContext(t.value)));
};
z.prototype.arp = function(e) {
  return this.arpWith((t) => e.fmap((n) => t[n % t.length]));
};
function di(e) {
  return !Array.isArray(e) && typeof e == "object";
}
function Xy(e, t, n) {
  return di(e) || di(t) ? (di(e) || (e = { value: e }), di(t) || (t = { value: t }), Ty(e, t, n)) : n(e, t);
}
(function() {
  const e = {
    set: [(n, r) => r],
    keep: [(n) => n],
    keepif: [(n, r) => r ? n : void 0],
    // numerical functions
    /**
     *
     * Assumes a pattern of numbers. Adds the given number to each item in the pattern.
     * @name add
     * @memberof Pattern
     * @example
     * // Here, the triad 0, 2, 4 is shifted by different amounts
     * n("0 2 4".add("<0 3 4 0>")).scale("C:major")
     * // Without add, the equivalent would be:
     * // n("<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>").scale("C:major")
     * @example
     * // You can also use add with notes:
     * note("c3 e3 g3".add("<0 5 7 0>"))
     * // Behind the scenes, the notes are converted to midi numbers:
     * // note("48 52 55".add("<0 5 7 0>"))
     */
    add: [Mt((n, r) => n + r)],
    // support string concatenation
    /**
     *
     * Like add, but the given numbers are subtracted.
     * @name sub
     * @memberof Pattern
     * @example
     * n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
     * // See add for more information.
     */
    sub: [Mt((n, r) => n - r)],
    /**
     *
     * Multiplies each number by the given factor.
     * @name mul
     * @memberof Pattern
     * @example
     * "<1 1.5 [1.66, <2 2.33>]>*4".mul(150).freq()
     */
    mul: [Mt((n, r) => n * r)],
    /**
     *
     * Divides each number by the given factor.
     * @name div
     * @memberof Pattern
     */
    div: [Mt((n, r) => n / r)],
    mod: [Mt(St)],
    pow: [Mt(Math.pow)],
    log2: [Mt(Math.log2)],
    band: [Mt((n, r) => n & r)],
    bor: [Mt((n, r) => n | r)],
    bxor: [Mt((n, r) => n ^ r)],
    blshift: [Mt((n, r) => n << r)],
    brshift: [Mt((n, r) => n >> r)],
    // TODO - force numerical comparison if both look like numbers?
    lt: [(n, r) => n < r],
    gt: [(n, r) => n > r],
    lte: [(n, r) => n <= r],
    gte: [(n, r) => n >= r],
    eq: [(n, r) => n == r],
    eqt: [(n, r) => n === r],
    ne: [(n, r) => n != r],
    net: [(n, r) => n !== r],
    and: [(n, r) => n && r],
    or: [(n, r) => n || r],
    //  bitwise ops
    func: [(n, r) => r(n)]
  }, t = ["In", "Out", "Mix", "Squeeze", "SqueezeOut", "Reset", "Restart", "Poly"];
  for (const [n, [r, i]] of Object.entries(e)) {
    z.prototype["_" + n] = function(s) {
      return this.fmap((u) => r(u, s));
    }, Object.defineProperty(z.prototype, n, {
      // a getter that returns a function, so 'pat' can be
      // accessed by closures that are methods of that function..
      get: function() {
        const s = this, u = (...a) => s[n].in(...a);
        for (const a of t)
          u[a.toLowerCase()] = function(...o) {
            var f = s;
            o = Bt(o), i && (f = i(f), o = i(o));
            var h;
            return n === "keepif" ? (h = f["_op" + a](o, (m) => (p) => r(m, p)), h = h.removeUndefineds()) : h = f["_op" + a](o, (m) => (p) => Xy(m, p, r)), h;
          };
        return u.squeezein = u.squeeze, u;
      }
    });
    for (const s of t)
      z.prototype[s.toLowerCase()] = function(...u) {
        return this.set[s.toLowerCase()](u);
      };
  }
  z.prototype.struct = function(...n) {
    return this.keepif.out(...n);
  }, z.prototype.structAll = function(...n) {
    return this.keep.out(...n);
  }, z.prototype.mask = function(...n) {
    return this.keepif.in(...n);
  }, z.prototype.maskAll = function(...n) {
    return this.keep.in(...n);
  }, z.prototype.reset = function(...n) {
    return this.keepif.reset(...n);
  }, z.prototype.resetAll = function(...n) {
    return this.keep.reset(...n);
  }, z.prototype.restart = function(...n) {
    return this.keepif.restart(...n);
  }, z.prototype.restartAll = function(...n) {
    return this.keep.restart(...n);
  };
})();
const Zy = Te, Wy = Te, Oy = Li, Cr = (e) => new z(() => [], e), Se = Cr(1), Ct = Cr(0);
function Ye(e) {
  function t(r) {
    return r.span.spanCycles.map((i) => new qe(j(i.begin).wholeCycle(), i, e));
  }
  const n = new z(t, 1);
  return n.__pure = e, n;
}
function xu(e) {
  return e instanceof z || e?._Pattern;
}
function K(e) {
  return xu(e) ? e : Us && typeof e == "string" ? Us(e) : Ye(e);
}
function xc(e) {
  let t = Ye([]);
  for (const n of e)
    t = t.bind((r) => n.fmap((i) => r.concat([i])));
  return t;
}
function Te(...e) {
  e = e.map((r) => Array.isArray(r) ? Bt(...r) : K(r));
  const t = (r) => dn(e.map((i) => i.query(r))), n = new z(t);
  return Ot && (n._steps = Zt(...e.map((r) => r._steps))), n;
}
function wu(e, t) {
  if (t = t.map((s) => Array.isArray(s) ? Bt(...s) : K(s)), t.length === 0)
    return Se;
  if (t.length === 1)
    return t[0];
  const [n, ...r] = t.map((s) => s._steps), i = Ot ? n.maximum(...r) : void 0;
  return Te(...e(i, t));
}
function wc(...e) {
  return wu(
    (t, n) => n.map((r) => r._steps.eq(t) ? r : mt(r, Cr(t.sub(r._steps)))),
    e
  );
}
function Sc(...e) {
  return wu(
    (t, n) => n.map((r) => r._steps.eq(t) ? r : mt(Cr(t.sub(r._steps)), r)),
    e
  );
}
function Bc(...e) {
  return wu(
    (t, n) => n.map((r) => {
      if (r._steps.eq(t))
        return r;
      const i = Cr(t.sub(r._steps).div(2));
      return mt(i, r, i);
    }),
    e
  );
}
function zy(e, ...t) {
  const [n, ...r] = t.map((u) => u._steps), i = n.maximum(...r), s = {
    centre: Bc,
    left: wc,
    right: Sc,
    expand: Te,
    repeat: (...u) => Li(...u).steps(i)
  };
  return e.inhabit(s).fmap((u) => u(...t)).innerJoin().setSteps(i);
}
function Vn(...e) {
  if (e = e.map((r) => Array.isArray(r) ? yt(...r) : K(r)), e.length == 1)
    return e[0];
  const t = function(r) {
    const i = r.span, s = St(i.begin.sam(), e.length), u = e[s];
    if (!u)
      return [];
    const a = i.begin.floor().sub(i.begin.div(e.length).floor());
    return u.withHapTime((o) => o.add(a)).query(r.setSpan(i.withTime((o) => o.sub(a))));
  }, n = Ot ? Zt(...e.map((r) => r._steps)) : void 0;
  return new z(t).splitQueries().setSteps(n);
}
function Su(...e) {
  e = e.map(K);
  const t = function(n) {
    const r = Math.floor(n.span.begin) % e.length;
    return e[r]?.query(n) || [];
  };
  return new z(t).splitQueries();
}
function _c(...e) {
  return Vn(...e);
}
function jy(...e) {
  const t = e.reduce((n, [r]) => n + r, 0);
  return e = e.map(([n, r]) => [n, r.fast(n)]), mt(...e).slow(t);
}
function $y(...e) {
  let t = j(0);
  for (let n of e)
    n.length == 2 && n.unshift(t), t = n[1];
  return Te(
    ...e.map(
      ([n, r, i]) => Ye(K(i)).compress(j(n).div(t), j(r).div(t))
    )
  ).slow(t).innerJoin();
}
function yt(...e) {
  let t = Vn(...e);
  return e.length > 1 && (t = t._fast(e.length), t._steps = e.length), e.length == 1 && e[0].__steps_source && (e._steps = e[0]._steps), t;
}
function Bt(...e) {
  return yt(...e);
}
function kc(...e) {
  return yt(...e);
}
function Js(e) {
  return Array.isArray(e) ? e.length == 0 ? [Se, 0] : e.length == 1 ? Js(e[0]) : [yt(...e.map((t) => Js(t)[0])), e.length] : [K(e), 1];
}
const qy = me((e, t) => K(t).mask(e)), Ky = me((e, t) => K(t).struct(e)), Hy = me((e, t) => K(t).superimpose(...e)), Uy = me((e, t) => K(t).withValue(e)), Jy = me((e, t) => K(t).bind(e)), Yy = me((e, t) => K(t).innerBind(e)), Qy = me((e, t) => K(t).outerBind(e)), e3 = me((e, t) => K(t).squeezeBind(e)), t3 = me((e, t) => K(t).stepBind(e)), n3 = me((e, t) => K(t).polyBind(e)), r3 = me((e, t) => K(t).set(e)), i3 = me((e, t) => K(t).keep(e)), s3 = me((e, t) => K(t).keepif(e)), u3 = me((e, t) => K(t).add(e)), a3 = me((e, t) => K(t).sub(e)), o3 = me((e, t) => K(t).mul(e)), c3 = me((e, t) => K(t).div(e)), l3 = me((e, t) => K(t).mod(e)), f3 = me((e, t) => K(t).pow(e)), h3 = me((e, t) => K(t).band(e)), p3 = me((e, t) => K(t).bor(e)), d3 = me((e, t) => K(t).bxor(e)), m3 = me((e, t) => K(t).blshift(e)), g3 = me((e, t) => K(t).brshift(e)), y3 = me((e, t) => K(t).lt(e)), A3 = me((e, t) => K(t).gt(e)), b3 = me((e, t) => K(t).lte(e)), M3 = me((e, t) => K(t).gte(e)), C3 = me((e, t) => K(t).eq(e)), v3 = me((e, t) => K(t).eqt(e)), P3 = me((e, t) => K(t).ne(e)), D3 = me((e, t) => K(t).net(e)), F3 = me((e, t) => K(t).and(e)), E3 = me((e, t) => K(t).or(e)), x3 = me((e, t) => K(t).func(e));
function T(e, t, n = !0, r = !1, i = (s) => s.innerJoin()) {
  if (Array.isArray(e)) {
    const a = {};
    for (const o of e)
      a[o] = T(o, t, n, r, i);
    return a;
  }
  const s = t.length;
  var u;
  return n ? u = function(...a) {
    a = a.map(K);
    const o = a[a.length - 1];
    let f;
    if (s === 1)
      f = t(o);
    else {
      const h = a.slice(0, -1);
      if (h.every((m) => m.__pure != null)) {
        const m = h.map((b) => b.__pure), p = h.filter((b) => b.__pure_loc).map((b) => b.__pure_loc);
        f = t(...m, o), f = f.withContext((b) => {
          const M = (b.locations || []).concat(p);
          return { ...b, locations: M };
        });
      } else {
        const [m, ...p] = h;
        let b = (...M) => t(...M, o);
        b = me(b, null, s - 1), f = i(p.reduce((M, v) => M.appLeft(v), m.fmap(b)));
      }
    }
    return r && (f._steps = o._steps), f;
  } : u = function(...a) {
    a = a.map(K);
    const o = t(...a);
    return r && (o._steps = a[a.length - 1]._steps), o;
  }, z.prototype[e] = function(...a) {
    if (s === 2 && a.length !== 1)
      a = [Bt(...a)];
    else if (s !== a.length + 1)
      throw new Error(`.${e}() expects ${s - 1} inputs but got ${a.length}.`);
    return a = a.map(K), u(...a, this);
  }, s > 1 && (z.prototype["_" + e] = function(...a) {
    const o = t(...a, this);
    return r && o.setSteps(this._steps), o;
  }), me(u, null, s);
}
function ei(e, t, n = !0, r = !1, i = (s) => s.stepJoin()) {
  return T(e, t, n, r, i);
}
const w3 = T("round", function(e) {
  return e.asNumber().fmap((t) => Math.round(t));
}), S3 = T("floor", function(e) {
  return e.asNumber().fmap((t) => Math.floor(t));
}), B3 = T("ceil", function(e) {
  return e.asNumber().fmap((t) => Math.ceil(t));
}), _3 = T("toBipolar", function(e) {
  return e.fmap((t) => t * 2 - 1);
}), k3 = T("fromBipolar", function(e) {
  return e.fmap((t) => (t + 1) / 2);
}), I3 = T("range", function(e, t, n) {
  return n.mul(t - e).add(e);
}), V3 = T("rangex", function(e, t, n) {
  return n._range(Math.log(e), Math.log(t)).fmap(Math.exp);
}), N3 = T("range2", function(e, t, n) {
  return n.fromBipolar()._range(e, t);
}), T3 = T(
  "ratio",
  (e) => e.fmap((t) => Array.isArray(t) ? t.slice(1).reduce((n, r) => n / r, t[0]) : t)
), R3 = T("compress", function(e, t, n) {
  return e = j(e), t = j(t), e.gt(t) || e.gt(1) || t.gt(1) || e.lt(0) || t.lt(0) ? Se : n._fastGap(j(1).div(t.sub(e)))._late(e);
}), { compressSpan: L3, compressspan: G3 } = T(["compressSpan", "compressspan"], function(e, t) {
  return t._compress(e.begin, e.end);
}), { fastGap: X3, fastgap: Z3 } = T(["fastGap", "fastgap"], function(e, t) {
  const n = function(i) {
    const s = i.begin.sam(), u = i.begin.sub(s).mul(e).min(1), a = i.end.sub(s).mul(e).min(1);
    if (!(u >= 1))
      return new Ue(s.add(u), s.add(a));
  }, r = function(i) {
    const s = i.part.begin, u = i.part.end, a = s.sam(), o = s.sub(a).div(e).min(1), f = u.sub(a).div(e).min(1), h = new Ue(a.add(o), a.add(f)), m = i.whole ? new Ue(
      h.begin.sub(s.sub(i.whole.begin).div(e)),
      h.end.add(i.whole.end.sub(u).div(e))
    ) : void 0;
    return new qe(m, h, i.value, i.context);
  };
  return t.withQuerySpanMaybe(n).withHap(r).splitQueries();
}), W3 = T("focus", function(e, t, n) {
  return e = j(e), t = j(t), n._early(e.sam())._fast(j(1).div(t.sub(e)))._late(e);
}), { focusSpan: O3, focusspan: z3 } = T(["focusSpan", "focusspan"], function(e, t) {
  return t._focus(e.begin, e.end);
}), j3 = T("ply", function(e, t) {
  const n = t.fmap((r) => Ye(r)._fast(e)).squeezeJoin();
  return Ot && (n._steps = j(e).mulmaybe(t._steps)), n;
}), { fast: $3, density: dF } = T(
  ["fast", "density"],
  function(e, t) {
    return e === 0 ? Se : (e = j(e), t.withQueryTime((r) => r.mul(e)).withHapTime((r) => r.div(e)).setSteps(t._steps));
  },
  !0,
  !0
), q3 = T("hurry", function(e, t) {
  return t._fast(e).mul(Ye({ speed: e }));
}), { slow: K3, sparsity: H3 } = T(["slow", "sparsity"], function(e, t) {
  return e === 0 ? Se : t._fast(j(1).div(e));
}), U3 = T("inside", function(e, t, n) {
  return t(n._slow(e))._fast(e);
}), J3 = T("outside", function(e, t, n) {
  return t(n._fast(e))._slow(e);
}), Y3 = T("lastOf", function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.push(t(n)), Su(...r);
}), { firstOf: Q3, every: eA } = T(["firstOf", "every"], function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.unshift(t(n)), Su(...r);
}), tA = T("apply", function(e, t) {
  return e(t);
}), nA = T("cpm", function(e, t) {
  return t._fast(e / 60 / 1);
}), rA = T(
  "early",
  function(e, t) {
    return e = j(e), t.withQueryTime((n) => n.add(e)).withHapTime((n) => n.sub(e));
  },
  !0,
  !0
), Ic = T(
  "late",
  function(e, t) {
    return e = j(e), t._early(j(0).sub(e));
  },
  !0,
  !0
), iA = T("zoom", function(e, t, n) {
  if (t = j(t), e = j(e), e.gte(t))
    return Ct;
  const r = t.sub(e), i = Ot ? n._steps?.mulmaybe(r) : void 0;
  return n.withQuerySpan((s) => s.withCycle((u) => u.mul(r).add(e))).withHapSpan((s) => s.withCycle((u) => u.sub(e).div(r))).splitQueries().setSteps(i);
}), { zoomArc: sA, zoomarc: uA } = T(["zoomArc", "zoomarc"], function(e, t) {
  return t.zoom(e.begin, e.end);
}), aA = T(
  "bite",
  (e, t, n) => t.fmap((r) => (i) => {
    const s = j(r).div(i).mod(1), u = s.add(j(1).div(i));
    return n.zoom(s, u);
  }).appLeft(e).squeezeJoin(),
  !1
), oA = T(
  "linger",
  function(e, t) {
    return e == 0 ? Se : e < 0 ? t._zoom(e.add(1), 1)._slow(e) : t._zoom(0, e)._slow(e);
  },
  !0,
  !0
), { segment: cA, seg: lA } = T(["segment", "seg"], function(e, t) {
  return t.struct(Ye(!0)._fast(e)).setSteps(e);
}), fA = T("swingBy", (e, t, n) => n.inside(t, Ic(kc(0, e / 2)))), hA = T("swing", (e, t) => t.swingBy(1 / 3, e)), { invert: pA, inv: dA } = T(
  ["invert", "inv"],
  function(e) {
    return e.fmap((t) => !t);
  },
  !0,
  !0
), mA = T("when", function(e, t, n) {
  return e ? t(n) : n;
}), gA = T("off", function(e, t, n) {
  return Te(n, t(n.late(e)));
}), yA = T("brak", function(e) {
  return e.when(Vn(!1, !0), (t) => yt(t, Se)._late(0.25));
}), Vc = T(
  "rev",
  function(e) {
    const t = function(n) {
      const r = n.span, i = r.begin.sam(), s = r.begin.nextSam(), u = function(o) {
        const f = o.withTime((m) => i.add(s.sub(m))), h = f.begin;
        return f.begin = f.end, f.end = h, f;
      };
      return e.query(n.setSpan(u(r))).map((o) => o.withSpan(u));
    };
    return new z(t).splitQueries();
  },
  !1,
  !0
), AA = T("pressBy", function(e, t) {
  return t.fmap((n) => Ye(n).compress(e, 1)).squeezeJoin();
}), bA = T("press", function(e) {
  return e._pressBy(0.5);
});
z.prototype.hush = function() {
  return Se;
};
const MA = T(
  "palindrome",
  function(e) {
    return e.lastOf(2, Vc);
  },
  !0,
  !0
), { juxBy: CA, juxby: vA } = T(["juxBy", "juxby"], function(e, t, n) {
  e /= 2;
  const r = function(u, a, o) {
    return a in u ? u[a] : o;
  }, i = n.withValue((u) => Object.assign({}, u, { pan: r(u, "pan", 0.5) - e })), s = t(n.withValue((u) => Object.assign({}, u, { pan: r(u, "pan", 0.5) + e })));
  return Te(i, s).setSteps(Ot ? Zt(i._steps, s._steps) : void 0);
}), PA = T("jux", function(e, t) {
  return t._juxBy(1, e, t);
}), { echoWith: DA, echowith: FA, stutWith: EA, stutwith: xA } = T(
  ["echoWith", "echowith", "stutWith", "stutwith"],
  function(e, t, n, r) {
    return Te(...vu(0, e - 1).map((i) => n(r.late(j(t).mul(i)), i)));
  }
), wA = T("echo", function(e, t, n, r) {
  return r._echoWith(e, t, (i, s) => i.gain(Math.pow(n, s)));
}), SA = T("stut", function(e, t, n, r) {
  return r._echoWith(e, n, (i, s) => i.gain(Math.pow(t, s)));
}), Bu = function(e, t, n = !1) {
  return e = j(e), Vn(
    ...vu(0, e.sub(1)).map(
      (r) => n ? t.late(j(r).div(e)) : t.early(j(r).div(e))
    )
  );
}, BA = T(
  "iter",
  function(e, t) {
    return Bu(e, t, !1);
  },
  !0,
  !0
), { iterBack: _A, iterback: kA } = T(
  ["iterBack", "iterback"],
  function(e, t) {
    return Bu(e, t, !0);
  },
  !0,
  !0
), { repeatCycles: IA } = T(
  "repeatCycles",
  function(e, t) {
    return new z(function(n) {
      const r = n.span.begin.sam(), i = r.div(e).sam(), s = r.sub(i);
      return n = n.withSpan((u) => u.withTime((a) => a.sub(s))), t.query(n).map((u) => u.withSpan((a) => a.withTime((o) => o.add(s))));
    }).splitQueries();
  },
  !0,
  !0
), _u = function(e, t, n, r = !1, i = !1) {
  const s = Array(e - 1).fill(!1);
  s.unshift(!0);
  const u = Bu(e, Bt(...s), !r);
  return i || (n = n.repeatCycles(e)), n.when(u, t);
}, { chunk: VA, slowchunk: NA, slowChunk: TA } = T(["chunk", "slowchunk", "slowChunk"], function(e, t, n) {
  return _u(e, t, n, !1, !1);
}), { chunkBack: RA, chunkback: LA } = T(["chunkBack", "chunkback"], function(e, t, n) {
  return _u(e, t, n, !0);
}), { fastchunk: GA, fastChunk: XA } = T(["fastchunk", "fastChunk"], function(e, t, n) {
  return _u(e, t, n, !1, !0);
}), ZA = T(
  "bypass",
  function(e, t) {
    return e = !!parseInt(e), e ? Se : t;
  },
  !0,
  !0
), { ribbon: WA, rib: OA } = T(
  ["ribbon", "rib"],
  (e, t, n) => n.early(e).restart(Ye(1).slow(t))
), zA = T("hsla", (e, t, n, r, i) => i.color(`hsla(${e}turn,${t * 100}%,${n * 100}%,${r})`)), jA = T("hsl", (e, t, n, r) => r.color(`hsl(${e}turn,${t * 100}%,${n * 100}%)`));
z.prototype.tag = function(e) {
  return this.withContext((t) => ({ ...t, tags: (t.tags || []).concat([e]) }));
};
const $A = T("filter", (e, t) => t.withHaps((n) => n.filter(e))), qA = T("filterWhen", (e, t) => t.filter((n) => e(n.whole.begin))), KA = T(
  "within",
  (e, t, n, r) => Te(
    n(r.filterWhen((i) => i.cyclePos() >= e && i.cyclePos() <= t)),
    r.filterWhen((i) => i.cyclePos() < e || i.cyclePos() > t)
  )
);
z.prototype.stepJoin = function() {
  const e = this, t = mt(...Ys(Qs(e.queryArc(0, 1))))._steps, n = function(r) {
    const s = e.early(r.span.begin.sam()).query(r.setSpan(new Ue(j(0), j(1))));
    return mt(...Ys(Qs(s))).query(r);
  };
  return new z(n, t);
};
z.prototype.stepBind = function(e) {
  return this.fmap(e).stepJoin();
};
function Ys(e) {
  const t = e.filter((s, u) => u.hasSteps).reduce((s, u) => s.add(u), j(0)), n = Mr(e.map((s, u) => u._steps)).reduce(
    (s, u) => s.add(u),
    j(0)
  ), r = t.eq(0) ? void 0 : n.div(t);
  function i(s, u) {
    return u._steps === void 0 ? [s.mulmaybe(r), u] : [u._steps, u];
  }
  return e.map((s) => i(...s));
}
function Qs(e) {
  const t = dn(e.map((i) => [i.part.begin, i.part.end])), n = Ac([j(0), j(1), ...t]);
  return yc(n).map((i) => [
    i[1].sub(i[0]),
    Te(...Nc(new Ue(...i), e).map((s) => s.value.withHap((u) => u.setContext(u.combineContext(s)))))
  ]);
}
function Nc(e, t) {
  return Mr(t.map((n) => Tc(e, n)));
}
function Tc(e, t) {
  const n = e.intersection(t.part);
  if (n != null)
    return new qe(t.whole, n, t.value, t.context);
}
const Rc = T("pace", function(e, t) {
  return t._steps === void 0 ? t : t._steps.eq(j(0)) ? Ct : t._fast(j(e).div(t._steps)).setSteps(e);
});
function Lc(e, ...t) {
  const n = t.map((i) => Js(i));
  if (n.length == 0)
    return Se;
  e == 0 && (e = n[0][1]);
  const r = [];
  for (const i of n)
    i[1] != 0 && (e == i[1] ? r.push(i[0]) : r.push(i[0]._fast(j(e).div(j(i[1])))));
  return Te(...r);
}
function Li(...e) {
  if (Array.isArray(e[0]))
    return Lc(0, ...e);
  if (e = e.filter((r) => r.hasSteps), e.length == 0)
    return Se;
  const t = Zt(...e.map((r) => r._steps));
  if (t.eq(j(0)))
    return Ct;
  const n = Te(...e.map((r) => r.pace(t)));
  return n._steps = t, n;
}
function mt(...e) {
  if (e.length === 0)
    return Ct;
  const t = (u) => Array.isArray(u) ? u : [u._steps, u];
  if (e = e.map(t), e.find((u) => u[0] === void 0)) {
    const u = e.map((o) => o[0]).filter((o) => o !== void 0);
    if (u.length === 0)
      return yt(...e.map((o) => o[1]));
    if (u.length === e.length)
      return Ct;
    const a = u.reduce((o, f) => o.add(f), j(0)).div(u.length);
    for (let o of e)
      o[0] === void 0 && (o[0] = a);
  }
  if (e.length == 1)
    return K(e[0][1]).withSteps((a) => e[0][0]);
  const n = e.map((u) => u[0]).reduce((u, a) => u.add(a), j(0));
  let r = j(0);
  const i = [];
  for (const [u, a] of e) {
    if (j(u).eq(0))
      continue;
    const o = r.add(u);
    i.push(K(a)._compress(r.div(n), o.div(n))), r = o;
  }
  const s = Te(...i);
  return s._steps = n, s;
}
function Gc(...e) {
  e = e.map((i) => Array.isArray(i) ? i.map(K) : [K(i)]);
  const t = Zt(...e.map((i) => j(i.length)));
  let n = [];
  for (let i = 0; i < t; ++i)
    n.push(...e.map((s) => s.length == 0 ? Se : s[i % s.length]));
  n = n.filter((i) => i.hasSteps && i._steps > 0);
  const r = n.reduce((i, s) => i.add(s._steps), j(0));
  return n = mt(...n), n._steps = r, n;
}
const Xc = ei("take", function(e, t) {
  if (!t.hasSteps || t._steps.lte(0) || (e = j(e), e.eq(0)))
    return Ct;
  const n = e < 0;
  n && (e = e.abs());
  const r = e.div(t._steps);
  return r.lte(0) ? Ct : r.gte(1) ? t : n ? t.zoom(j(1).sub(r), 1) : t.zoom(0, r);
}), Zc = ei("drop", function(e, t) {
  return t.hasSteps ? (e = j(e), e.lt(0) ? t.take(t._steps.add(e)) : t.take(j(0).sub(t._steps.sub(e)))) : Ct;
}), Wc = ei("extend", function(e, t) {
  return t.fast(e).expand(e);
}), Oc = ei("expand", function(e, t) {
  return t.withSteps((n) => n.mul(j(e)));
}), zc = ei("contract", function(e, t) {
  return t.withSteps((n) => n.div(j(e)));
});
z.prototype.shrinklist = function(e) {
  const t = this;
  if (!t.hasSteps)
    return [t];
  let [n, r] = Array.isArray(e) ? e : [e, t._steps];
  if (n = j(n), r === 0 || n === 0)
    return [t];
  const i = n > 0, s = [];
  if (i) {
    const u = j(1).div(t._steps).mul(n);
    for (let a = 0; a < r; ++a) {
      const o = u.mul(a);
      if (o.gt(1))
        break;
      s.push([o, 1]);
    }
  } else {
    n = j(0).sub(n);
    const u = j(1).div(t._steps).mul(n);
    for (let a = 0; a < r; ++a) {
      const o = j(1).sub(u.mul(a));
      if (o.lt(0))
        break;
      s.push([j(0), o]);
    }
  }
  return s.map((u) => t.zoom(...u));
};
const jc = (e, t) => t.shrinklist(e), $c = T(
  "shrink",
  function(e, t) {
    if (!t.hasSteps)
      return Ct;
    const n = t.shrinklist(e), r = mt(...n);
    return r._steps = n.reduce((i, s) => i.add(s._steps), j(0)), r;
  },
  !0,
  !1,
  (e) => e.stepJoin()
), HA = T(
  "grow",
  function(e, t) {
    if (!t.hasSteps)
      return Ct;
    const n = t.shrinklist(j(0).sub(e));
    n.reverse();
    const r = mt(...n);
    return r._steps = n.reduce((i, s) => i.add(s._steps), j(0)), r;
  },
  !0,
  !1,
  (e) => e.stepJoin()
), qc = function(e, ...t) {
  return e.tour(...t);
};
z.prototype.tour = function(...e) {
  return mt(
    ...[].concat(
      ...e.map((t, n) => [...e.slice(0, e.length - n), this, ...e.slice(e.length - n)]),
      this,
      ...e
    )
  );
};
const Kc = function(...e) {
  e = e.filter((r) => r.hasSteps);
  const t = Vn(...e.map((r) => r._slow(r._steps))), n = Zt(...e.map((r) => r._steps));
  return t._fast(n).setSteps(n);
}, UA = mt, ku = mt, JA = mt, YA = Gc, QA = Li;
z.prototype.s_polymeter = z.prototype.polymeter;
const eb = $c;
z.prototype.s_taper = z.prototype.shrink;
const tb = jc;
z.prototype.s_taperlist = z.prototype.shrinklist;
const nb = Xc;
z.prototype.s_add = z.prototype.take;
const rb = Zc;
z.prototype.s_sub = z.prototype.drop;
const ib = Oc;
z.prototype.s_expand = z.prototype.expand;
const sb = Wc;
z.prototype.s_extend = z.prototype.extend;
const ub = zc;
z.prototype.s_contract = z.prototype.contract;
const ab = qc;
z.prototype.s_tour = z.prototype.tour;
const ob = Kc;
z.prototype.s_zip = z.prototype.zip;
const cb = Rc;
z.prototype.steps = z.prototype.pace;
const lb = T("chop", function(e, t) {
  const r = Array.from({ length: e }, (u, a) => a).map((u) => ({ begin: u / e, end: (u + 1) / e })), i = function(u, a) {
    if ("begin" in u && "end" in u && u.begin !== void 0 && u.end !== void 0) {
      const o = u.end - u.begin;
      a = { begin: u.begin + a.begin * o, end: u.begin + a.end * o };
    }
    return Object.assign({}, u, a);
  }, s = function(u) {
    return Bt(r.map((a) => i(u, a)));
  };
  return t.squeezeBind(s).setSteps(Ot ? j(e).mulmaybe(t._steps) : void 0);
}), fb = T("striate", function(e, t) {
  const r = Array.from({ length: e }, (s, u) => u).map((s) => ({ begin: s / e, end: (s + 1) / e })), i = Vn(...r);
  return t.set(i)._fast(e).setSteps(Ot ? j(e).mulmaybe(t._steps) : void 0);
}), Hc = function(e, t, n = 0.5) {
  return t.speed(1 / e * n).unit("c").slow(e);
}, Uc = T(
  "slice",
  function(e, t, n) {
    return e.innerBind(
      (r) => t.outerBind(
        (i) => n.outerBind((s) => {
          s = s instanceof Object ? s : { s };
          const u = Array.isArray(r) ? r[i] : i / r, a = Array.isArray(r) ? r[i + 1] : (i + 1) / r;
          return Ye({ begin: u, end: a, _slices: r, ...s });
        })
      )
    ).setSteps(t._steps);
  },
  !1
  // turns off auto-patternification
), hb = T(
  "splice",
  function(e, t, n) {
    const r = Uc(e, t, n);
    return new z((i) => {
      const s = i.controls._cps || 1;
      return r.query(i).map(
        (a) => a.withValue((o) => ({
          speed: s / o._slices / a.whole.duration * (o.speed || 1),
          unit: "c",
          ...o
        }))
      );
    }).setSteps(t._steps);
  },
  !1
  // turns off auto-patternification
), { loopAt: pb, loopat: db } = T(["loopAt", "loopat"], function(e, t) {
  const n = t._steps ? t._steps.div(e) : void 0;
  return new z((r) => Hc(e, t, r.controls._cps).query(r), n);
}), mb = T(
  "fit",
  (e) => e.withHaps(
    (t, n) => t.map(
      (r) => r.withValue((i) => {
        const s = ("end" in i ? i.end : 1) - ("begin" in i ? i.begin : 0);
        return {
          ...i,
          speed: (n.controls._cps || 1) / r.whole.duration * s,
          unit: "c"
        };
      })
    )
  )
), { loopAtCps: gb, loopatcps: yb } = T(["loopAtCps", "loopatcps"], function(e, t, n) {
  return Hc(e, n, t);
}), Ab = (e) => Ye(1).withValue(() => K(e())).innerJoin();
let Ja = (e) => e < 0.5 ? 1 : 1 - (e - 0.5) / 0.5, Jc = (e, t, n) => {
  t = K(t), e = K(e), n = K(n);
  let r = t.fmap((s) => ({ gain: Ja(s) })), i = t.fmap((s) => ({ gain: Ja(1 - s) }));
  return Te(e.mul(r), n.mul(i));
};
z.prototype.xfade = function(e, t) {
  return Jc(this, e, t);
};
const bb = (e) => (t, n, r) => {
  t = j(t).mod(n), n = j(n);
  const i = t.div(n), s = t.add(1).div(n);
  return e(r.fmap((u) => Ye(u)._compress(i, s)));
}, { beat: Mb } = T(
  ["beat"],
  bb((e) => e.innerJoin())
);
function Gi(e) {
  let t = Array.isArray(e);
  e = t ? e : [e];
  const n = e[0], r = (u) => {
    let a;
    if (typeof u == "object" && u.value !== void 0 && (a = { ...u }, u = u.value, delete a.value), t && Array.isArray(u)) {
      const o = a || {};
      return u.forEach((f, h) => {
        h < e.length && (o[e[h]] = f);
      }), o;
    } else return a ? (a[n] = u, a) : { [n]: u };
  }, i = (...u) => Bt(...u).withValue(r), s = function(...u) {
    return u.length ? this.set(i(...u)) : this.fmap(r);
  };
  return z.prototype[n] = s, i;
}
const eu = /* @__PURE__ */ new Map();
function w(e, ...t) {
  const n = Array.isArray(e) ? e[0] : e;
  let r = {};
  return r[n] = Gi(e), t.forEach((i) => {
    r[i] = r[n], eu.set(i, n), z.prototype[i] = z.prototype[n];
  }), r;
}
const { s: Yc, sound: Qc } = w(["s", "n", "gain"], "sound"), { source: el, src: tl } = w("source", "src"), { n: nl } = w("n"), { note: rl } = w(["note", "n"]), { accelerate: il } = w("accelerate"), { velocity: sl } = w("velocity"), { gain: ul } = w("gain"), { postgain: al } = w("postgain"), { amp: ol } = w("amp"), { attack: cl, att: ll } = w("attack", "att"), { fmh: fl } = w(["fmh", "fmi"], "fmh"), { fmi: hl, fm: pl } = w(["fmi", "fmh"], "fm"), { fmenv: dl } = w("fmenv"), { fmattack: ml } = w("fmattack"), { fmdecay: gl } = w("fmdecay"), { fmsustain: yl } = w("fmsustain"), { fmrelease: Al } = w("fmrelease"), { fmvelocity: bl } = w("fmvelocity"), { bank: Ml } = w("bank"), { analyze: Cl } = w("analyze"), { fft: vl } = w("fft"), { decay: Pl, dec: Dl } = w("decay", "dec"), { sustain: Fl, sus: El } = w("sustain", "sus"), { release: xl, rel: wl } = w("release", "rel"), { hold: Sl } = w("hold"), { bandf: Bl, bpf: _l, bp: kl } = w(["bandf", "bandq", "bpenv"], "bpf", "bp"), { bandq: Il, bpq: Vl } = w("bandq", "bpq"), { begin: Nl } = w("begin"), { end: Tl } = w("end"), { loop: Rl } = w("loop"), { loopBegin: Ll, loopb: Gl } = w("loopBegin", "loopb"), { loopEnd: Xl, loope: Zl } = w("loopEnd", "loope"), { crush: Wl } = w("crush"), { coarse: Ol } = w("coarse"), { drive: zl } = w("drive"), { channels: jl, ch: $l } = w("channels", "ch"), { phaserrate: ql, ph: Kl, phaser: Hl } = w(
  ["phaserrate", "phaserdepth", "phasercenter", "phasersweep"],
  "ph",
  "phaser"
), { phasersweep: Ul, phs: Jl } = w("phasersweep", "phs"), { phasercenter: Yl, phc: Ql } = w("phasercenter", "phc"), { phaserdepth: e0, phd: t0, phasdp: n0 } = w("phaserdepth", "phd", "phasdp"), { channel: r0 } = w("channel"), { cut: i0 } = w("cut"), { cutoff: s0, ctf: u0, lpf: a0, lp: o0 } = w(["cutoff", "resonance", "lpenv"], "ctf", "lpf", "lp"), { lpenv: c0, lpe: l0 } = w("lpenv", "lpe"), { hpenv: f0, hpe: h0 } = w("hpenv", "hpe"), { bpenv: p0, bpe: d0 } = w("bpenv", "bpe"), { lpattack: m0, lpa: g0 } = w("lpattack", "lpa"), { hpattack: y0, hpa: A0 } = w("hpattack", "hpa"), { bpattack: b0, bpa: M0 } = w("bpattack", "bpa"), { lpdecay: C0, lpd: v0 } = w("lpdecay", "lpd"), { hpdecay: P0, hpd: D0 } = w("hpdecay", "hpd"), { bpdecay: F0, bpd: E0 } = w("bpdecay", "bpd"), { lpsustain: x0, lps: w0 } = w("lpsustain", "lps"), { hpsustain: S0, hps: B0 } = w("hpsustain", "hps"), { bpsustain: _0, bps: k0 } = w("bpsustain", "bps"), { lprelease: I0, lpr: V0 } = w("lprelease", "lpr"), { hprelease: N0, hpr: T0 } = w("hprelease", "hpr"), { bprelease: R0, bpr: L0 } = w("bprelease", "bpr"), { ftype: G0 } = w("ftype"), { fanchor: X0 } = w("fanchor"), { vib: Z0, vibrato: W0, v: O0 } = w(["vib", "vibmod"], "vibrato", "v"), { noise: z0 } = w("noise"), { vibmod: j0, vmod: $0 } = w(["vibmod", "vib"], "vmod"), { hcutoff: q0, hpf: K0, hp: H0 } = w(["hcutoff", "hresonance", "hpenv"], "hpf", "hp"), { hresonance: U0, hpq: J0 } = w("hresonance", "hpq"), { resonance: Y0, lpq: Q0 } = w("resonance", "lpq"), { djf: ef } = w("djf"), { delay: tf } = w(["delay", "delaytime", "delayfeedback"]), { delayfeedback: nf, delayfb: rf, dfb: sf } = w("delayfeedback", "delayfb", "dfb"), { delaytime: uf, delayt: af, dt: of } = w("delaytime", "delayt", "dt"), { lock: cf } = w("lock"), { detune: lf, det: ff } = w("detune", "det"), { unison: hf } = w("unison"), { spread: pf } = w("spread"), { dry: df } = w("dry"), { fadeTime: mf, fadeOutTime: gf } = w("fadeTime", "fadeOutTime"), { fadeInTime: yf } = w("fadeInTime"), { freq: Af } = w("freq"), { pattack: bf, patt: Mf } = w("pattack", "patt"), { pdecay: Cf, pdec: vf } = w("pdecay", "pdec"), { psustain: Pf, psus: Df } = w("psustain", "psus"), { prelease: Ff, prel: Ef } = w("prelease", "prel"), { penv: xf } = w("penv"), { pcurve: wf } = w("pcurve"), { panchor: Sf } = w("panchor"), { gate: Bf, gat: _f } = w("gate", "gat"), { leslie: kf } = w("leslie"), { lrate: If } = w("lrate"), { lsize: Vf } = w("lsize"), { activeLabel: Nf } = w("activeLabel"), { label: Tf } = w(["label", "activeLabel"]), { degree: Rf } = w("degree"), { mtranspose: Lf } = w("mtranspose"), { ctranspose: Gf } = w("ctranspose"), { harmonic: Xf } = w("harmonic"), { stepsPerOctave: Zf } = w("stepsPerOctave"), { octaveR: Wf } = w("octaveR"), { nudge: Of } = w("nudge"), { octave: zf } = w("octave"), { orbit: jf } = w("orbit"), { overgain: $f } = w("overgain"), { overshape: qf } = w("overshape"), { pan: Kf } = w("pan"), { panspan: Hf } = w("panspan"), { pansplay: Uf } = w("pansplay"), { panwidth: Jf } = w("panwidth"), { panorient: Yf } = w("panorient"), { rate: Qf } = w("rate"), { slide: eh } = w("slide"), { semitone: th } = w("semitone"), { voice: nh } = w("voice"), { chord: rh } = w("chord"), { dictionary: ih, dict: sh } = w("dictionary", "dict"), { anchor: uh } = w("anchor"), { offset: ah } = w("offset"), { octaves: oh } = w("octaves"), { mode: ch } = w(["mode", "anchor"]), { room: lh } = w(["room", "size"]), { roomlp: fh, rlp: hh } = w("roomlp", "rlp"), { roomdim: ph, rdim: dh } = w("roomdim", "rdim"), { roomfade: mh, rfade: gh } = w("roomfade", "rfade"), { ir: yh, iresponse: Ah } = w(["ir", "i"], "iresponse"), { roomsize: bh, size: Mh, sz: Ch, rsize: vh } = w("roomsize", "size", "sz", "rsize"), { shape: Ph } = w(["shape", "shapevol"]), { distort: Dh, dist: Fh } = w(["distort", "distortvol"], "dist"), { compressor: Eh } = w([
  "compressor",
  "compressorRatio",
  "compressorKnee",
  "compressorAttack",
  "compressorRelease"
]), { compressorKnee: xh } = w("compressorKnee"), { compressorRatio: wh } = w("compressorRatio"), { compressorAttack: Sh } = w("compressorAttack"), { compressorRelease: Bh } = w("compressorRelease"), { speed: Iu } = w("speed"), { stretch: _h } = w("stretch"), { unit: kh } = w("unit"), { squiz: Ih } = w("squiz"), { vowel: Vh } = w("vowel"), { waveloss: Nh } = w("waveloss"), { density: Cb } = w("density"), { expression: Th } = w("expression"), { sustainpedal: Rh } = w("sustainpedal"), { tremolodepth: Lh, tremdp: Gh } = w("tremolodepth", "tremdp"), { tremolorate: Xh, tremr: Zh } = w("tremolorate", "tremr"), { fshift: Wh } = w("fshift"), { fshiftnote: Oh } = w("fshiftnote"), { fshiftphase: zh } = w("fshiftphase"), { triode: jh } = w("triode"), { krush: $h } = w("krush"), { kcutoff: qh } = w("kcutoff"), { octer: Kh } = w("octer"), { octersub: Hh } = w("octersub"), { octersubsub: Uh } = w("octersubsub"), { ring: Jh } = w("ring"), { ringf: Yh } = w("ringf"), { ringdf: Qh } = w("ringdf"), { freeze: e1 } = w("freeze"), { xsdelay: t1 } = w("xsdelay"), { tsdelay: n1 } = w("tsdelay"), { real: r1 } = w("real"), { imag: i1 } = w("imag"), { enhance: s1 } = w("enhance"), { partials: u1 } = w("partials"), { comb: a1 } = w("comb"), { smear: o1 } = w("smear"), { scram: c1 } = w("scram"), { binshift: l1 } = w("binshift"), { hbrick: f1 } = w("hbrick"), { lbrick: h1 } = w("lbrick"), { frameRate: p1 } = w("frameRate"), { frames: d1 } = w("frames"), { hours: m1 } = w("hours"), { minutes: g1 } = w("minutes"), { seconds: y1 } = w("seconds"), { songPtr: A1 } = w("songPtr"), { uid: b1 } = w("uid"), { val: M1 } = w("val"), { cps: C1 } = w("cps"), { clip: v1, legato: P1 } = w("clip", "legato"), { duration: D1, dur: F1 } = w("duration", "dur"), { zrand: E1 } = w("zrand"), { curve: x1 } = w("curve"), { deltaSlide: w1 } = w("deltaSlide"), { pitchJump: S1 } = w("pitchJump"), { pitchJumpTime: B1 } = w("pitchJumpTime"), { lfo: _1, repeatTime: k1 } = w("lfo", "repeatTime"), { znoise: I1 } = w("znoise"), { zmod: V1 } = w("zmod"), { zcrush: N1 } = w("zcrush"), { zdelay: T1 } = w("zdelay"), { tremolo: R1 } = w("tremolo"), { zzfx: L1 } = w("zzfx"), { color: G1, colour: X1 } = w(["color", "colour"]);
let Vu = (...e) => e.reduce((t, n) => Object.assign(t, { [n]: Gi(n) }), {});
const Z1 = T("adsr", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r, i, s] = e;
  return t.set({ attack: n, decay: r, sustain: i, release: s });
}), W1 = T("ad", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.attack(n).decay(r);
}), O1 = T("ds", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = 0] = e;
  return t.set({ decay: n, sustain: r });
}), z1 = T("ar", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.set({ attack: n, release: r });
}), { midichan: j1 } = w("midichan"), { midimap: $1 } = w("midimap"), { midiport: q1 } = w("midiport"), { midicmd: K1 } = w("midicmd"), H1 = T("control", (e, t) => {
  if (!Array.isArray(e))
    throw new Error("control expects an array of [ccn, ccv]");
  const [n, r] = e;
  return t.ccn(n).ccv(r);
}), { ccn: U1 } = w("ccn"), { ccv: J1 } = w("ccv"), { ctlNum: Y1 } = w("ctlNum"), { nrpnn: Q1 } = w("nrpnn"), { nrpv: ep } = w("nrpv"), { progNum: tp } = w("progNum"), np = T("sysex", (e, t) => {
  if (!Array.isArray(e))
    throw new Error("sysex expects an array of [id, data]");
  const [n, r] = e;
  return t.sysexid(n).sysexdata(r);
}), { sysexid: rp } = w("sysexid"), { sysexdata: ip } = w("sysexdata"), { midibend: sp } = w("midibend"), { miditouch: up } = w("miditouch"), { polyTouch: ap } = w("polyTouch"), Nu = (e) => eu.has(e) ? eu.get(e) : e, op = T("as", (e, t) => (e = Array.isArray(e) ? e : [e], t.fmap((n) => (n = Array.isArray(n) ? n : [n], n = Object.fromEntries(e.map((r, i) => [Nu(r), n[i]])), n)))), cp = T(
  "scrub",
  (e, t) => e.outerBind((n) => {
    Array.isArray(n) || (n = [n]);
    const [r, i = 1] = n;
    return t.begin(r).mul(Iu(i)).clip(1);
  }),
  !1
), vb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accelerate: il,
  activeLabel: Nf,
  ad: W1,
  adsr: Z1,
  amp: ol,
  analyze: Cl,
  anchor: uh,
  ar: z1,
  as: op,
  att: ll,
  attack: cl,
  bandf: Bl,
  bandq: Il,
  bank: Ml,
  begin: Nl,
  binshift: l1,
  bp: kl,
  bpa: M0,
  bpattack: b0,
  bpd: E0,
  bpdecay: F0,
  bpe: d0,
  bpenv: p0,
  bpf: _l,
  bpq: Vl,
  bpr: L0,
  bprelease: R0,
  bps: k0,
  bpsustain: _0,
  ccn: U1,
  ccv: J1,
  ch: $l,
  channel: r0,
  channels: jl,
  chord: rh,
  clip: v1,
  coarse: Ol,
  color: G1,
  colour: X1,
  comb: a1,
  compressor: Eh,
  compressorAttack: Sh,
  compressorKnee: xh,
  compressorRatio: wh,
  compressorRelease: Bh,
  control: H1,
  cps: C1,
  createParam: Gi,
  createParams: Vu,
  crush: Wl,
  ctf: u0,
  ctlNum: Y1,
  ctranspose: Gf,
  curve: x1,
  cut: i0,
  cutoff: s0,
  dec: Dl,
  decay: Pl,
  degree: Rf,
  delay: tf,
  delayfb: rf,
  delayfeedback: nf,
  delayt: af,
  delaytime: uf,
  deltaSlide: w1,
  density: Cb,
  det: ff,
  detune: lf,
  dfb: sf,
  dict: sh,
  dictionary: ih,
  dist: Fh,
  distort: Dh,
  djf: ef,
  drive: zl,
  dry: df,
  ds: O1,
  dt: of,
  dur: F1,
  duration: D1,
  end: Tl,
  enhance: s1,
  expression: Th,
  fadeInTime: yf,
  fadeOutTime: gf,
  fadeTime: mf,
  fanchor: X0,
  fft: vl,
  fm: pl,
  fmattack: ml,
  fmdecay: gl,
  fmenv: dl,
  fmh: fl,
  fmi: hl,
  fmrelease: Al,
  fmsustain: yl,
  fmvelocity: bl,
  frameRate: p1,
  frames: d1,
  freeze: e1,
  freq: Af,
  fshift: Wh,
  fshiftnote: Oh,
  fshiftphase: zh,
  ftype: G0,
  gain: ul,
  gat: _f,
  gate: Bf,
  getControlName: Nu,
  harmonic: Xf,
  hbrick: f1,
  hcutoff: q0,
  hold: Sl,
  hours: m1,
  hp: H0,
  hpa: A0,
  hpattack: y0,
  hpd: D0,
  hpdecay: P0,
  hpe: h0,
  hpenv: f0,
  hpf: K0,
  hpq: J0,
  hpr: T0,
  hprelease: N0,
  hps: B0,
  hpsustain: S0,
  hresonance: U0,
  imag: i1,
  ir: yh,
  iresponse: Ah,
  kcutoff: qh,
  krush: $h,
  label: Tf,
  lbrick: h1,
  legato: P1,
  leslie: kf,
  lfo: _1,
  lock: cf,
  loop: Rl,
  loopBegin: Ll,
  loopEnd: Xl,
  loopb: Gl,
  loope: Zl,
  lp: o0,
  lpa: g0,
  lpattack: m0,
  lpd: v0,
  lpdecay: C0,
  lpe: l0,
  lpenv: c0,
  lpf: a0,
  lpq: Q0,
  lpr: V0,
  lprelease: I0,
  lps: w0,
  lpsustain: x0,
  lrate: If,
  lsize: Vf,
  midibend: sp,
  midichan: j1,
  midicmd: K1,
  midimap: $1,
  midiport: q1,
  miditouch: up,
  minutes: g1,
  mode: ch,
  mtranspose: Lf,
  n: nl,
  noise: z0,
  note: rl,
  nrpnn: Q1,
  nrpv: ep,
  nudge: Of,
  octave: zf,
  octaveR: Wf,
  octaves: oh,
  octer: Kh,
  octersub: Hh,
  octersubsub: Uh,
  offset: ah,
  orbit: jf,
  overgain: $f,
  overshape: qf,
  pan: Kf,
  panchor: Sf,
  panorient: Yf,
  panspan: Hf,
  pansplay: Uf,
  panwidth: Jf,
  partials: u1,
  patt: Mf,
  pattack: bf,
  pcurve: wf,
  pdec: vf,
  pdecay: Cf,
  penv: xf,
  ph: Kl,
  phasdp: n0,
  phaser: Hl,
  phasercenter: Yl,
  phaserdepth: e0,
  phaserrate: ql,
  phasersweep: Ul,
  phc: Ql,
  phd: t0,
  phs: Jl,
  pitchJump: S1,
  pitchJumpTime: B1,
  polyTouch: ap,
  postgain: al,
  prel: Ef,
  prelease: Ff,
  progNum: tp,
  psus: Df,
  psustain: Pf,
  rate: Qf,
  rdim: dh,
  real: r1,
  registerControl: w,
  rel: wl,
  release: xl,
  repeatTime: k1,
  resonance: Y0,
  rfade: gh,
  ring: Jh,
  ringdf: Qh,
  ringf: Yh,
  rlp: hh,
  room: lh,
  roomdim: ph,
  roomfade: mh,
  roomlp: fh,
  roomsize: bh,
  rsize: vh,
  s: Yc,
  scram: c1,
  scrub: cp,
  seconds: y1,
  semitone: th,
  shape: Ph,
  size: Mh,
  slide: eh,
  smear: o1,
  songPtr: A1,
  sound: Qc,
  source: el,
  speed: Iu,
  spread: pf,
  squiz: Ih,
  src: tl,
  stepsPerOctave: Zf,
  stretch: _h,
  sus: El,
  sustain: Fl,
  sustainpedal: Rh,
  sysex: np,
  sysexdata: ip,
  sysexid: rp,
  sz: Ch,
  tremdp: Gh,
  tremolo: R1,
  tremolodepth: Lh,
  tremolorate: Xh,
  tremr: Zh,
  triode: jh,
  tsdelay: n1,
  uid: b1,
  unison: hf,
  unit: kh,
  v: O0,
  val: M1,
  velocity: sl,
  vib: Z0,
  vibmod: j0,
  vibrato: W0,
  vmod: $0,
  voice: nh,
  vowel: Vh,
  waveloss: Nh,
  xsdelay: t1,
  zcrush: N1,
  zdelay: T1,
  zmod: V1,
  znoise: I1,
  zrand: E1,
  zzfx: L1
}, Symbol.toStringTag, { value: "Module" })), Pb = function(e, t) {
  const [n, r] = e, [i, s] = t, [u, a] = Fu(r, i);
  return [
    [r, n - r],
    [Eu((o, f) => o.concat(f), u, s), a]
  ];
}, Db = function(e, t) {
  const [n, r] = e, [i, s] = t, [u, a] = Fu(n, s);
  return [
    [n, r - n],
    [Eu((f, h) => f.concat(h), i, u), a]
  ];
}, lp = function(e, t) {
  const [n, r] = e;
  return Math.min(n, r) <= 1 ? [e, t] : lp(...n > r ? Pb(e, t) : Db(e, t));
}, fp = function(e, t) {
  const n = e < 0;
  e = Math.abs(e);
  const r = t - e, i = Array(e).fill([1]), s = Array(r).fill([0]), u = lp([e, r], [i, s]), a = dn(u[1][0]).concat(dn(u[1][1]));
  return n ? a.map((o) => o === 0 ? 1 : 0) : a;
}, Tu = function(e, t, n) {
  const r = fp(e, t);
  return n ? dc(r, -n) : r;
}, Fb = T("euclid", function(e, t, n) {
  return n.struct(Tu(e, t, 0));
}), { euclidrot: Eb, euclidRot: xb } = T(["euclidrot", "euclidRot"], function(e, t, n, r) {
  return r.struct(Tu(e, t, n));
}), hp = function(e, t, n, r) {
  if (e < 1)
    return Se;
  const s = Tu(e, t, n).join("").split("1").slice(1).map((u) => [u.length + 1, !0]);
  return r.struct(ku(...s));
}, wb = T(["euclidLegato"], function(e, t, n) {
  return hp(e, t, 0, n);
}), Sb = T(["euclidLegatoRot"], function(e, t, n, r) {
  return hp(e, t, n, r);
});
function pp(e, t, n = 0.05, r = 0.1, i = 0.1, s = globalThis.setInterval, u = globalThis.clearInterval, a = !0) {
  let o = 0, f = 0, h = 10 ** 4, m = 0.01;
  const p = (S) => n = S(n);
  i = i || r / 2;
  const b = () => {
    const S = e(), x = S + r + i;
    for (f === 0 && (f = S + m); f < x; )
      f = a ? Math.round(f * h) / h : f, t(f, n, o, S), f += n, o++;
  };
  let M;
  const v = () => {
    E(), b(), M = s(b, r * 1e3);
  }, E = () => {
    M !== void 0 && u(M), M = void 0;
  };
  return { setDuration: p, start: v, stop: () => {
    o = 0, f = 0, E();
  }, pause: () => E(), duration: n, interval: r, getPhase: () => f, minLatency: m };
}
function Bb(e) {
  return new z((t) => [new qe(void 0, t.span, e)]);
}
const _t = (e) => {
  const t = (n) => [new qe(void 0, n.span, e(n.span.begin))];
  return new z(t);
}, ti = _t((e) => e % 1), Ru = ti.toBipolar(), Xi = _t((e) => 1 - e % 1), Lu = Xi.toBipolar(), Gu = _t((e) => Math.sin(Math.PI * 2 * e)), dp = Gu.fromBipolar(), _b = dp._early(j(1).div(4)), kb = Gu._early(j(1).div(4)), mp = _t((e) => Math.floor(e * 2 % 2)), Ib = mp.toBipolar(), Vb = yt(ti, Xi), Nb = yt(Ru, Lu), Tb = yt(Xi, ti), Rb = yt(Lu, Ru), gp = _t(cr);
let Xu = 0, Zu = 0;
typeof window < "u" && document.addEventListener("mousemove", (e) => {
  Xu = e.clientY / document.body.clientHeight, Zu = e.clientX / document.body.clientWidth;
});
const Lb = _t(() => Xu), Gb = _t(() => Xu), Xb = _t(() => Zu), Zb = _t(() => Zu), yp = (e) => {
  const t = e << 13 ^ e, n = t >> 17 ^ t;
  return n << 5 ^ n;
}, Wb = (e) => e - Math.trunc(e), Ap = (e) => yp(Math.trunc(Wb(e / 300) * 536870912)), bp = (e) => e % 536870912 / 536870912, tu = (e) => Math.abs(bp(Ap(e))), Ob = (e, t) => {
  const n = [];
  for (let r = 0; r < t; ++r)
    n.push(bp(e)), e = yp(e);
  return n;
}, zb = (e, t) => Ob(Ap(e), t), Mp = (e) => ti.range(0, e).round().segment(e), jb = (e) => {
  const t = K(e).log2(0).floor().add(1);
  return Cp(e, t);
}, Cp = (e, t = 16) => {
  t = K(t);
  const n = Mp(t).mul(-1).add(t.sub(1));
  return K(e).segment(t).brshift(n).band(Ye(1));
}, vp = (e) => _t((t) => {
  const r = zb(t.floor().add(0.5), e).map((s, u) => [s, u]).sort((s, u) => s[0] > u[0] - s[0] < u[0]).map((s) => s[1]), i = t.cyclePos().mul(e).floor() % e;
  return r[i];
})._segment(e), Pp = (e, t, n) => {
  const r = [...Array(t).keys()].map((i) => n.zoom(j(i).div(t), j(i + 1).div(t)));
  return e.fmap((i) => r[i].repeatCycles(t)._fast(t)).innerJoin();
}, $b = T("shuffle", (e, t) => Pp(vp(e), e, t)), qb = T("scramble", (e, t) => Pp(Ou(e)._segment(e), e, t)), gt = _t(tu), Kb = gt.toBipolar(), Wu = (e) => gt.fmap((t) => t < e), Hb = (e) => K(e).fmap(Wu).innerJoin(), Ub = Wu(0.5), Ou = (e) => gt.fmap((t) => Math.trunc(t * e)), Jb = (e) => K(e).fmap(Ou).innerJoin(), zu = (e, t) => (t = t.map(K), t.length == 0 ? Se : e.range(0, t.length).fmap((n) => {
  const r = Math.min(Math.max(Math.floor(n), 0), t.length - 1);
  return t[r];
})), Zi = (e, t) => zu(e, t).outerJoin(), ju = (e, t) => zu(e, t).innerJoin(), Yb = (...e) => Zi(gt, e);
z.prototype.choose = function(...e) {
  return Zi(this, e);
};
z.prototype.choose2 = function(...e) {
  return Zi(this.fromBipolar(), e);
};
const Dp = (...e) => ju(gt.segment(1), e), Qb = Dp, Fp = function(e, ...t) {
  const n = t.map((a) => K(a[0])), r = [];
  let i = Ye(0);
  for (const a of t)
    i = i.add(a[1]), r.push(i);
  const s = xc(r), u = function(a) {
    const o = i.mul(a);
    return s.fmap((f) => (h) => n[f.findIndex((m) => m > h, f)]).appLeft(o);
  };
  return e.bind(u);
}, eM = (...e) => Fp(...e).outerJoin(), tM = (...e) => eM(gt, ...e), Ep = (...e) => Fp(gt.segment(1), ...e).innerJoin(), nM = Ep, xp = (e) => {
  const t = e.fmap(Math.floor), n = e.fmap((s) => Math.floor(s) + 1), r = (s) => 6 * s ** 5 - 15 * s ** 4 + 10 * s ** 3, i = (s) => (u) => (a) => u + r(s) * (a - u);
  return e.sub(t).fmap(i).appBoth(t.fmap(tu)).appBoth(n.fmap(tu));
}, rM = xp(gp.fmap((e) => Number(e))), iM = T(
  "degradeByWith",
  (e, t, n) => n.fmap((r) => (i) => r).appLeft(e.filterValues((r) => r > t)),
  !0,
  !0
), sM = T(
  "degradeBy",
  function(e, t) {
    return t._degradeByWith(gt, e);
  },
  !0,
  !0
), uM = T("degrade", (e) => e._degradeBy(0.5), !0, !0), aM = T(
  "undegradeBy",
  function(e, t) {
    return t._degradeByWith(
      gt.fmap((n) => 1 - n),
      e
    );
  },
  !0,
  !0
), oM = T("undegrade", (e) => e._undegradeBy(0.5), !0, !0), cM = T("sometimesBy", function(e, t, n) {
  return K(e).fmap((r) => Te(n._degradeBy(r), t(n._undegradeBy(1 - r)))).innerJoin();
}), lM = T("sometimes", function(e, t) {
  return t._sometimesBy(0.5, e);
}), fM = T("someCyclesBy", function(e, t, n) {
  return K(e).fmap(
    (r) => Te(
      n._degradeByWith(gt._segment(1), r),
      t(n._degradeByWith(gt.fmap((i) => 1 - i)._segment(1), 1 - r))
    )
  ).innerJoin();
}), hM = T("someCycles", function(e, t) {
  return t._someCyclesBy(0.5, e);
}), pM = T("often", function(e, t) {
  return t.sometimesBy(0.75, e);
}), dM = T("rarely", function(e, t) {
  return t.sometimesBy(0.25, e);
}), mM = T("almostNever", function(e, t) {
  return t.sometimesBy(0.1, e);
}), gM = T("almostAlways", function(e, t) {
  return t.sometimesBy(0.9, e);
}), yM = T("never", function(e, t) {
  return t;
}), AM = T("always", function(e, t) {
  return e(t);
});
function $u(e) {
  Array.isArray(e) === !1 && (e = [e]);
  const t = Dc();
  return e.every((n) => {
    const r = Pc.get(n) ?? n;
    return t[r];
  });
}
const bM = T("whenKey", function(e, t, n) {
  return n.when($u(e), t);
}), MM = T("keyDown", function(e) {
  return e.fmap($u);
}), tn = function(e, t, n = !0) {
  const r = Array.isArray(e), i = Object.keys(e).length;
  return e = Cc(e, K), i === 0 ? Se : t.fmap((s) => {
    let u = s;
    return r && (u = n ? Math.round(u) % i : Ri(Math.round(u), 0, e.length - 1)), e[u];
  });
}, wp = function(e, t) {
  return Array.isArray(t) && ([t, e] = [e, t]), CM(e, t);
}, CM = T("pick", function(e, t) {
  return tn(e, t, !1).innerJoin();
}), Sp = T("pickmod", function(e, t) {
  return tn(e, t, !0).innerJoin();
}), vM = T("pickF", function(e, t, n) {
  return n.apply(wp(e, t));
}), PM = T("pickmodF", function(e, t, n) {
  return n.apply(Sp(e, t));
}), DM = T("pickOut", function(e, t) {
  return tn(e, t, !1).outerJoin();
}), FM = T("pickmodOut", function(e, t) {
  return tn(e, t, !0).outerJoin();
}), EM = T("pickRestart", function(e, t) {
  return tn(e, t, !1).restartJoin();
}), xM = T("pickmodRestart", function(e, t) {
  return tn(e, t, !0).restartJoin();
}), wM = T("pickReset", function(e, t) {
  return tn(e, t, !1).resetJoin();
}), SM = T("pickmodReset", function(e, t) {
  return tn(e, t, !0).resetJoin();
}), { inhabit: BM, pickSqueeze: _M } = T(["inhabit", "pickSqueeze"], function(e, t) {
  return tn(e, t, !1).squeezeJoin();
}), { inhabitmod: kM, pickmodSqueeze: IM } = T(["inhabitmod", "pickmodSqueeze"], function(e, t) {
  return tn(e, t, !0).squeezeJoin();
}), VM = (e, t) => (t = t.map(K), t.length == 0 ? Se : e.fmap((n) => {
  const r = St(Math.round(n), t.length);
  return t[r];
}).squeezeJoin());
let Fi;
try {
  Fi = window?.speechSynthesis;
} catch {
  console.warn("cannot use window: not in browser?");
}
let Ya = Fi?.getVoices();
function NM(e, t, n) {
  Fi.cancel();
  const r = new SpeechSynthesisUtterance(e);
  r.lang = t, Ya = Fi.getVoices();
  const i = Ya.filter((s) => s.lang.includes(t));
  typeof n == "number" ? r.voice = i[n % i.length] : typeof n == "string" && (r.voice = i.find((s) => s.name === s)), speechSynthesis.speak(r);
}
const TM = T("speak", function(e, t, n) {
  return n.onTrigger((r, i) => {
    NM(i.value, e, t);
  });
}), Ei = async (...e) => {
  const t = await Promise.allSettled(e), n = t.filter((r) => r.status === "fulfilled").map((r) => r.value);
  return t.forEach((r, i) => {
    r.status === "rejected" && console.warn(`evalScope: module with index ${i} could not be loaded:`, r.reason);
  }), n.forEach((r) => {
    Object.entries(r).forEach(([i, s]) => {
      globalThis[i] = s;
    });
  }), n;
};
function RM(e, t = {}) {
  const { wrapExpression: n = !0, wrapAsync: r = !0 } = t;
  n && (e = `{${e}}`), r && (e = `(async ()=>${e})()`);
  const i = `"use strict";return (${e})`;
  return Function(i)();
}
const Bp = async (e, t, n) => {
  let r = {};
  if (t) {
    const u = t(e, n);
    e = u.output, r = u;
  }
  return { mode: "javascript", pattern: await RM(e, { wrapExpression: !!t }), meta: r };
};
class LM {
  constructor({ onTrigger: t, onToggle: n, getTime: r }) {
    this.started = !1, this.cps = 0.5, this.lastTick = 0, this.getTime = r, this.time_at_last_tick_message = 0, this.collator = new vc({ getTargetClockTime: r }), this.onToggle = n, this.latency = 0.1, this.cycle = 0, this.id = Math.round(Date.now() * Math.random()), this.worker = new SharedWorker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/clockworker-ZDiUtESR.js", import.meta.url).href,
      import.meta.url
    )), this.worker.port.start(), this.channel = new BroadcastChannel("strudeltick");
    const i = (u) => {
      const { cps: a, begin: o, end: f, cycle: h, time: m } = u;
      this.cps = a, this.cycle = h;
      const p = this.collator.calculateOffset(m) + m;
      s(o, f, p), this.time_at_last_tick_message = p;
    }, s = (u, a, o) => {
      if (this.started === !1)
        return;
      this.pattern.queryArc(u, a, { _cps: this.cps }).forEach((h) => {
        if (h.hasOnset()) {
          const p = Hs(h.whole.begin - this.cycle, this.cps) + o + this.latency, b = Hs(h.duration, this.cps);
          t?.(h, 0, b, this.cps, p);
        }
      });
    };
    this.channel.onmessage = (u) => {
      if (!this.started)
        return;
      const { payload: a, type: o } = u.data;
      switch (o) {
        case "tick":
          i(a);
      }
    };
  }
  sendMessage(t, n) {
    this.worker.port.postMessage({ type: t, payload: n, id: this.id });
  }
  now() {
    const t = (this.getTime() - this.time_at_last_tick_message) * this.cps;
    return this.cycle + t;
  }
  setCps(t = 1) {
    this.sendMessage("cpschange", { cps: t });
  }
  setCycle(t) {
    this.sendMessage("setcycle", { cycle: t });
  }
  setStarted(t) {
    this.sendMessage("toggle", { started: t }), this.started = t, this.onToggle?.(t);
  }
  start() {
    Je("[cyclist] start"), this.setStarted(!0);
  }
  stop() {
    Je("[cyclist] stop"), this.collator.reset(), this.setStarted(!1);
  }
  setPattern(t, n = !1) {
    this.pattern = t, n && !this.started && this.start();
  }
  log(t, n, r) {
    const i = r.filter((s) => s.hasOnset());
    console.log(`${t.toFixed(4)} - ${n.toFixed(4)} ${Array(i.length).fill("I").join("")}`);
  }
}
class _p {
  constructor({
    interval: t,
    onTrigger: n,
    onToggle: r,
    onError: i,
    getTime: s,
    latency: u = 0.1,
    setInterval: a,
    clearInterval: o,
    beforeStart: f
  }) {
    this.started = !1, this.beforeStart = f, this.cps = 0.5, this.num_ticks_since_cps_change = 0, this.lastTick = 0, this.lastBegin = 0, this.lastEnd = 0, this.getTime = s, this.num_cycles_at_cps_change = 0, this.seconds_at_cps_change, this.onToggle = r, this.latency = u, this.clock = pp(
      s,
      // called slightly before each cycle
      (h, m, p, b) => {
        this.num_ticks_since_cps_change === 0 && (this.num_cycles_at_cps_change = this.lastEnd, this.seconds_at_cps_change = h), this.num_ticks_since_cps_change++;
        const v = this.num_ticks_since_cps_change * m * this.cps;
        try {
          const E = this.lastEnd;
          this.lastBegin = E;
          const I = this.num_cycles_at_cps_change + v;
          if (this.lastEnd = I, this.lastTick = h, h < b) {
            console.log("skip query: too late");
            return;
          }
          this.pattern.queryArc(E, I, { _cps: this.cps }).forEach((X) => {
            if (X.hasOnset()) {
              const S = (X.whole.begin - this.num_cycles_at_cps_change) / this.cps + this.seconds_at_cps_change + u, x = X.duration / this.cps, B = S - h;
              n?.(X, B, x, this.cps, S), X.value.cps !== void 0 && this.cps != X.value.cps && (this.cps = X.value.cps, this.num_ticks_since_cps_change = 0);
            }
          });
        } catch (E) {
          Je(`[cyclist] error: ${E.message}`), i?.(E);
        }
      },
      t,
      // duration of each cycle
      0.1,
      0.1,
      a,
      o
    );
  }
  now() {
    if (!this.started)
      return 0;
    const t = this.getTime() - this.lastTick - this.clock.duration;
    return this.lastBegin + t * this.cps;
  }
  setStarted(t) {
    this.started = t, this.onToggle?.(t);
  }
  async start() {
    if (await this.beforeStart?.(), this.num_ticks_since_cps_change = 0, this.num_cycles_at_cps_change = 0, !this.pattern)
      throw new Error("Scheduler: no pattern set! call .setPattern first.");
    Je("[cyclist] start"), this.clock.start(), this.setStarted(!0);
  }
  pause() {
    Je("[cyclist] pause"), this.clock.pause(), this.setStarted(!1);
  }
  stop() {
    Je("[cyclist] stop"), this.clock.stop(), this.lastEnd = 0, this.setStarted(!1);
  }
  async setPattern(t, n = !1) {
    this.pattern = t, n && !this.started && await this.start();
  }
  setCps(t = 0.5) {
    this.cps !== t && (this.cps = t, this.num_ticks_since_cps_change = 0);
  }
  log(t, n, r) {
    const i = r.filter((s) => s.hasOnset());
    console.log(`${t.toFixed(4)} - ${n.toFixed(4)} ${Array(i.length).fill("I").join("")}`);
  }
}
let nu;
function ru() {
  if (!nu)
    throw new Error("no time set! use setTime to define a time source");
  return nu();
}
function xi(e) {
  nu = e;
}
function GM({
  defaultOutput: e,
  onEvalError: t,
  beforeEval: n,
  beforeStart: r,
  afterEval: i,
  getTime: s,
  transpiler: u,
  onToggle: a,
  editPattern: o,
  onUpdateState: f,
  sync: h = !1,
  setInterval: m,
  clearInterval: p,
  id: b
}) {
  const M = {
    schedulerError: void 0,
    evalError: void 0,
    code: "// LOADING",
    activeCode: "// LOADING",
    pattern: void 0,
    miniLocations: [],
    widgets: [],
    pending: !1,
    started: !1
  }, v = {
    id: b
  }, E = (oe) => {
    Object.assign(M, oe), M.isDirty = M.code !== M.activeCode, M.error = M.evalError || M.schedulerError, f?.(M);
  }, I = {
    onTrigger: kp({ defaultOutput: e, getTime: s }),
    getTime: s,
    onToggle: (oe) => {
      E({ started: oe }), a?.(oe);
    },
    setInterval: m,
    clearInterval: p,
    beforeStart: r
  }, _ = h && typeof SharedWorker < "u" ? new LM(I) : new _p(I);
  let X = {}, S = 0, x, B;
  const k = function() {
    return X = {}, S = 0, x = void 0, B = void 0, Se;
  }, V = async (oe, ge = !0) => (oe = o?.(oe) || oe, await _.setPattern(oe, ge), oe);
  xi(() => _.now());
  const q = () => _.stop(), G = () => _.start(), Y = () => _.pause(), W = () => _.toggle(), O = (oe) => _.setCps(oe), te = (oe) => _.setCps(oe / 60), Ae = function(oe) {
    return x = oe, Se;
  }, pe = function(oe) {
    return B = oe, Se;
  }, fe = () => {
    z.prototype.p = function(ge) {
      return typeof ge == "string" && (ge.startsWith("_") || ge.endsWith("_")) ? Se : (ge === "$" && (ge = `$${S}`, S++), X[ge] = this, this);
    }, z.prototype.q = function(ge) {
      return Se;
    };
    try {
      for (let ge = 1; ge < 10; ++ge)
        Object.defineProperty(z.prototype, `d${ge}`, {
          get() {
            return this.p(ge);
          },
          configurable: !0
        }), Object.defineProperty(z.prototype, `p${ge}`, {
          get() {
            return this.p(ge);
          },
          configurable: !0
        }), z.prototype[`q${ge}`] = Se;
    } catch (ge) {
      console.warn("injectPatternMethods: error:", ge);
    }
    const oe = T("cpm", function(ge, $) {
      return $._fast(ge / 60 / _.cps);
    });
    return Ei({
      all: Ae,
      each: pe,
      hush: k,
      cpm: oe,
      setCps: O,
      setcps: O,
      setCpm: te,
      setcpm: te
    });
  };
  return { scheduler: _, evaluate: async (oe, ge = !0, $ = !0) => {
    if (!oe)
      throw new Error("no code to evaluate");
    try {
      E({ code: oe, pending: !0 }), await fe(), xi(() => _.now()), await n?.({ code: oe }), $ && k();
      let { pattern: ve, meta: st } = await Bp(oe, u, v);
      if (Object.keys(X).length) {
        let je = Object.values(X);
        B && (je = je.map((be) => B(be))), ve = Te(...je);
      } else B && (ve = B(ve));
      if (x && (ve = x(ve)), !xu(ve)) {
        const je = `got "${typeof evaluated}" instead of pattern`;
        throw new Error(je + (typeof evaluated == "function" ? ", did you forget to call a function?" : "."));
      }
      return Je("[eval] code updated"), ve = await V(ve, ge), E({
        miniLocations: st?.miniLocations || [],
        widgets: st?.widgets || [],
        activeCode: oe,
        pattern: ve,
        evalError: void 0,
        schedulerError: void 0,
        pending: !1
      }), i?.({ code: oe, pattern: ve, meta: st }), ve;
    } catch (ve) {
      Je(`[eval] error: ${ve.message}`, "error"), console.error(ve), E({ evalError: ve, pending: !1 }), t?.(ve);
    }
  }, start: G, stop: q, pause: Y, setCps: O, setPattern: V, setCode: (oe) => E({ code: oe }), toggle: W, state: M };
}
const kp = ({ getTime: e, defaultOutput: t }) => async (n, r, i, s, u) => {
  try {
    (!n.context.onTrigger || !n.context.dominantTrigger) && await t(n, r, i, s, u), n.context.onTrigger && await n.context.onTrigger(e() + r, n, e(), s, u);
  } catch (a) {
    Je(`[cyclist] error: ${a.message}`, "error");
  }
}, XM = function(e, t = {}) {
  const n = document.getElementById("code"), r = "background-image:url(" + e + ");background-size:contain;";
  n.style = r;
  const { className: i } = n, s = (o, f) => {
    ({
      style: () => n.style = r + ";" + f,
      className: () => n.className = f + " " + i
    })[o]();
  }, u = Object.entries(t).filter(([o, f]) => typeof f == "function");
  Object.entries(t).filter(([o, f]) => typeof f == "string").forEach(([o, f]) => s(o, f)), u.length;
}, ZM = () => {
  const e = document.getElementById("code");
  e && (e.style = "");
};
Je("🌀 @strudel/core loaded 🌀");
globalThis._strudelLoaded && console.warn(
  `@strudel/core was loaded more than once...
This might happen when you have multiple versions of strudel installed. 
Please check with "npm ls @strudel/core".`
);
globalThis._strudelLoaded = !0;
const Ip = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClockCollator: vc,
  Cyclist: _p,
  Fraction: j,
  Hap: qe,
  Pattern: z,
  State: pr,
  TimeSpan: Ue,
  __chooseWith: zu,
  _brandBy: Wu,
  _fitslice: Nc,
  _irand: Ou,
  _keyDown: $u,
  _match: Tc,
  _mod: St,
  _polymeterListSteps: Lc,
  _retime: Ys,
  _slices: Qs,
  accelerate: il,
  activeLabel: Nf,
  ad: W1,
  add: u3,
  adsr: Z1,
  almostAlways: gM,
  almostNever: mM,
  always: AM,
  amp: ol,
  analyze: Cl,
  anchor: uh,
  and: F3,
  apply: tA,
  ar: z1,
  arrange: jy,
  as: op,
  att: ll,
  attack: cl,
  averageArray: fc,
  backgroundImage: XM,
  band: h3,
  bandf: Bl,
  bandq: Il,
  bank: Ml,
  base64ToUnicode: Mc,
  beat: Mb,
  begin: Nl,
  binary: jb,
  binaryN: Cp,
  bind: Jy,
  binshift: l1,
  bite: aA,
  bjork: fp,
  blshift: m3,
  bor: p3,
  bp: kl,
  bpa: M0,
  bpattack: b0,
  bpd: E0,
  bpdecay: F0,
  bpe: d0,
  bpenv: p0,
  bpf: _l,
  bpq: Vl,
  bpr: L0,
  bprelease: R0,
  bps: k0,
  bpsustain: _0,
  brak: yA,
  brand: Ub,
  brandBy: Hb,
  brshift: g3,
  bxor: d3,
  bypass: ZA,
  calculateSteps: Ry,
  cat: _c,
  ccn: U1,
  ccv: J1,
  ceil: B3,
  ch: $l,
  channel: r0,
  channels: jl,
  choose: Yb,
  chooseCycles: Dp,
  chooseInWith: ju,
  chooseWith: Zi,
  chop: lb,
  chord: rh,
  chunk: VA,
  chunkBack: RA,
  chunkback: LA,
  clamp: Ri,
  cleanupUi: ZM,
  clip: v1,
  coarse: Ol,
  code2hash: _y,
  color: G1,
  colour: X1,
  comb: a1,
  compose: by,
  compress: R3,
  compressSpan: L3,
  compressor: Eh,
  compressorAttack: Sh,
  compressorKnee: xh,
  compressorRatio: wh,
  compressorRelease: Bh,
  compressspan: G3,
  constant: My,
  contract: zc,
  control: H1,
  controls: vb,
  cosine: _b,
  cosine2: kb,
  cpm: nA,
  cps: C1,
  createClock: pp,
  createParam: Gi,
  createParams: Vu,
  crush: Wl,
  ctf: u0,
  ctlNum: Y1,
  ctranspose: Gf,
  curry: me,
  curve: x1,
  cut: i0,
  cutoff: s0,
  cycleToSeconds: Hs,
  dec: Dl,
  decay: Pl,
  degrade: uM,
  degradeBy: sM,
  degradeByWith: iM,
  degree: Rf,
  delay: tf,
  delayfb: rf,
  delayfeedback: nf,
  delayt: af,
  delaytime: uf,
  deltaSlide: w1,
  det: ff,
  detune: lf,
  dfb: sf,
  dict: sh,
  dictionary: ih,
  dist: Fh,
  distort: Dh,
  div: c3,
  djf: ef,
  drawLine: Fc,
  drive: zl,
  drop: Zc,
  dry: df,
  ds: O1,
  dt: of,
  dur: F1,
  duration: D1,
  early: rA,
  echo: wA,
  echoWith: DA,
  echowith: FA,
  end: Tl,
  enhance: s1,
  eq: C3,
  eqt: v3,
  euclid: Fb,
  euclidLegato: wb,
  euclidLegatoRot: Sb,
  euclidRot: xb,
  euclidrot: Eb,
  evalScope: Ei,
  evaluate: Bp,
  every: eA,
  expand: Oc,
  expression: Th,
  extend: Wc,
  fadeInTime: yf,
  fadeOutTime: gf,
  fadeTime: mf,
  fanchor: X0,
  fast: $3,
  fastChunk: XA,
  fastGap: X3,
  fastcat: yt,
  fastchunk: GA,
  fastgap: Z3,
  fft: vl,
  filter: $A,
  filterWhen: qA,
  firstOf: Q3,
  fit: mb,
  flatten: dn,
  floor: S3,
  fm: pl,
  fmattack: ml,
  fmdecay: gl,
  fmenv: dl,
  fmh: fl,
  fmi: hl,
  fmrelease: Al,
  fmsustain: yl,
  fmvelocity: bl,
  focus: W3,
  focusSpan: O3,
  focusspan: z3,
  fractionalArgs: Cy,
  frameRate: p1,
  frames: d1,
  freeze: e1,
  freq: Af,
  freqToMidi: Cu,
  fromBipolar: k3,
  fshift: Wh,
  fshiftnote: Oh,
  fshiftphase: zh,
  ftype: G0,
  func: x3,
  gain: ul,
  gap: Cr,
  gat: _f,
  gate: Bf,
  getControlName: Nu,
  getCurrentKeyboardState: Dc,
  getEventOffsetMs: dy,
  getFreq: lc,
  getFrequency: pc,
  getPerformanceTimeSeconds: Iy,
  getPlayableNoteValue: Ay,
  getSoundIndex: yy,
  getTime: ru,
  getTrigger: kp,
  grow: HA,
  gt: A3,
  gte: M3,
  harmonic: Xf,
  hash2code: ky,
  hbrick: f1,
  hcutoff: q0,
  hold: Sl,
  hours: m1,
  hp: H0,
  hpa: A0,
  hpattack: y0,
  hpd: D0,
  hpdecay: P0,
  hpe: h0,
  hpenv: f0,
  hpf: K0,
  hpq: J0,
  hpr: T0,
  hprelease: N0,
  hps: B0,
  hpsustain: S0,
  hresonance: U0,
  hsl: jA,
  hsla: zA,
  hurry: q3,
  id: cr,
  imag: i1,
  inhabit: BM,
  inhabitmod: kM,
  innerBind: Yy,
  inside: U3,
  inv: dA,
  invert: pA,
  ir: yh,
  irand: Jb,
  iresponse: Ah,
  isNote: Un,
  isNoteWithOctave: ly,
  isPattern: xu,
  isaw: Xi,
  isaw2: Lu,
  iter: BA,
  iterBack: _A,
  iterback: kA,
  itri: Tb,
  itri2: Rb,
  jux: PA,
  juxBy: CA,
  juxby: vA,
  kcutoff: qh,
  keep: i3,
  keepif: s3,
  keyAlias: Pc,
  keyDown: MM,
  krush: $h,
  label: Tf,
  lastOf: Y3,
  late: Ic,
  lbrick: h1,
  legato: P1,
  leslie: kf,
  lfo: _1,
  linger: oA,
  listRange: vu,
  lock: cf,
  logKey: Mu,
  logger: Je,
  loop: Rl,
  loopAt: pb,
  loopAtCps: gb,
  loopBegin: Ll,
  loopEnd: Xl,
  loopat: db,
  loopatcps: yb,
  loopb: Gl,
  loope: Zl,
  lp: o0,
  lpa: g0,
  lpattack: m0,
  lpd: v0,
  lpdecay: C0,
  lpe: l0,
  lpenv: c0,
  lpf: a0,
  lpq: Q0,
  lpr: V0,
  lprelease: I0,
  lps: w0,
  lpsustain: x0,
  lrate: If,
  lsize: Vf,
  lt: y3,
  lte: b3,
  mapArgs: Du,
  mask: qy,
  midi2note: gy,
  midiToFreq: qn,
  midibend: sp,
  midichan: j1,
  midicmd: K1,
  midimap: $1,
  midiport: q1,
  miditouch: up,
  minutes: g1,
  mod: l3,
  mode: ch,
  mouseX: Zb,
  mouseY: Gb,
  mousex: Xb,
  mousey: Lb,
  mtranspose: Lf,
  mul: o3,
  n: nl,
  nanFallback: hc,
  ne: P3,
  net: D3,
  never: yM,
  noise: z0,
  note: rl,
  noteToMidi: In,
  nothing: Ct,
  nrpnn: Q1,
  nrpv: ep,
  nudge: Of,
  numeralArgs: Mt,
  objectMap: Cc,
  octave: zf,
  octaveR: Wf,
  octaves: oh,
  octer: Kh,
  octersub: Hh,
  octersubsub: Uh,
  off: gA,
  offset: ah,
  often: pM,
  or: E3,
  orbit: jf,
  outerBind: Qy,
  outside: J3,
  overgain: $f,
  overshape: qf,
  pace: Rc,
  pairs: yc,
  palindrome: MA,
  pan: Kf,
  panchor: Sf,
  panorient: Yf,
  panspan: Hf,
  pansplay: Uf,
  panwidth: Jf,
  parseFractional: gc,
  parseNumeral: Pu,
  partials: u1,
  patt: Mf,
  pattack: bf,
  pcurve: wf,
  pdec: vf,
  pdecay: Cf,
  penv: xf,
  perlin: rM,
  perlinWith: xp,
  ph: Kl,
  phasdp: n0,
  phaser: Hl,
  phasercenter: Yl,
  phaserdepth: e0,
  phaserrate: ql,
  phasersweep: Ul,
  phc: Ql,
  phd: t0,
  phs: Jl,
  pick: wp,
  pickF: vM,
  pickOut: DM,
  pickReset: wM,
  pickRestart: EM,
  pickSqueeze: _M,
  pickmod: Sp,
  pickmodF: PM,
  pickmodOut: FM,
  pickmodReset: SM,
  pickmodRestart: xM,
  pickmodSqueeze: IM,
  pipe: mc,
  pitchJump: S1,
  pitchJumpTime: B1,
  ply: j3,
  pm: Oy,
  polyBind: n3,
  polyTouch: ap,
  polymeter: Li,
  polyrhythm: Zy,
  postgain: al,
  pow: f3,
  pr: Wy,
  prel: Ef,
  prelease: Ff,
  press: bA,
  pressBy: AA,
  progNum: tp,
  psus: Df,
  psustain: Pf,
  pure: Ye,
  rand: gt,
  rand2: Kb,
  randcat: Qb,
  randrun: vp,
  range: I3,
  range2: N3,
  rangex: V3,
  rarely: dM,
  rate: Qf,
  ratio: T3,
  rdim: dh,
  real: r1,
  ref: Ab,
  register: T,
  registerControl: w,
  reify: K,
  rel: wl,
  release: xl,
  removeUndefineds: Mr,
  repeatCycles: IA,
  repeatTime: k1,
  repl: GM,
  resonance: Y0,
  rev: Vc,
  rfade: gh,
  rib: OA,
  ribbon: WA,
  ring: Jh,
  ringdf: Qh,
  ringf: Yh,
  rlp: hh,
  room: lh,
  roomdim: ph,
  roomfade: mh,
  roomlp: fh,
  roomsize: bh,
  rotate: dc,
  round: w3,
  rsize: vh,
  run: Mp,
  s: Yc,
  s_add: nb,
  s_alt: YA,
  s_cat: JA,
  s_contract: ub,
  s_expand: ib,
  s_extend: sb,
  s_polymeter: QA,
  s_sub: rb,
  s_taper: eb,
  s_taperlist: tb,
  s_tour: ab,
  s_zip: ob,
  saw: ti,
  saw2: Ru,
  scram: c1,
  scramble: qb,
  scrub: cp,
  seconds: y1,
  seg: lA,
  segment: cA,
  semitone: th,
  seq: kc,
  seqPLoop: $y,
  sequence: Bt,
  sequenceP: xc,
  set: r3,
  setStringParser: Ec,
  setTime: xi,
  shape: Ph,
  shrink: $c,
  shrinklist: jc,
  shuffle: $b,
  signal: _t,
  silence: Se,
  sine: dp,
  sine2: Gu,
  size: Mh,
  slice: Uc,
  slide: eh,
  slow: K3,
  slowChunk: TA,
  slowcat: Vn,
  slowcatPrime: Su,
  slowchunk: NA,
  smear: o1,
  sol2note: wy,
  someCycles: hM,
  someCyclesBy: fM,
  sometimes: lM,
  sometimesBy: cM,
  songPtr: A1,
  sound: Qc,
  source: el,
  sparsity: H3,
  speak: TM,
  speed: Iu,
  splice: hb,
  splitAt: Fu,
  spread: pf,
  square: mp,
  square2: Ib,
  squeeze: VM,
  squeezeBind: e3,
  squiz: Ih,
  src: tl,
  stack: Te,
  stackBy: zy,
  stackCentre: Bc,
  stackLeft: wc,
  stackRight: Sc,
  steady: Bb,
  stepBind: t3,
  stepalt: Gc,
  stepcat: mt,
  steps: cb,
  stepsPerOctave: Zf,
  stretch: _h,
  striate: fb,
  struct: Ky,
  stut: SA,
  stutWith: EA,
  stutwith: xA,
  sub: a3,
  superimpose: Hy,
  sus: El,
  sustain: Fl,
  sustainpedal: Rh,
  swing: hA,
  swingBy: fA,
  sysex: np,
  sysexdata: ip,
  sysexid: rp,
  sz: Ch,
  take: Xc,
  time: gp,
  timeCat: ku,
  timecat: UA,
  toBipolar: _3,
  tokenizeNote: cc,
  tour: qc,
  tremdp: Gh,
  tremolo: R1,
  tremolodepth: Lh,
  tremolorate: Xh,
  tremr: Zh,
  tri: Vb,
  tri2: Nb,
  triode: jh,
  tsdelay: n1,
  uid: b1,
  undegrade: oM,
  undegradeBy: aM,
  unicodeToBase64: bc,
  uniq: Sy,
  uniqsort: By,
  uniqsortr: Ac,
  unison: hf,
  unit: kh,
  v: O0,
  val: M1,
  valueToMidi: py,
  velocity: sl,
  vib: Z0,
  vibmod: j0,
  vibrato: W0,
  vmod: $0,
  voice: nh,
  vowel: Vh,
  waveloss: Nh,
  wchoose: tM,
  wchooseCycles: Ep,
  when: mA,
  whenKey: bM,
  withValue: Uy,
  within: KA,
  wrandcat: nM,
  xfade: Jc,
  xsdelay: t1,
  zcrush: N1,
  zdelay: T1,
  zip: Kc,
  zipWith: Eu,
  zmod: V1,
  znoise: I1,
  zoom: iA,
  zoomArc: sA,
  zoomarc: uA,
  zrand: E1,
  zzfx: L1
}, Symbol.toStringTag, { value: "Module" }));
if (typeof DelayNode < "u") {
  class e extends DelayNode {
    constructor(n, r, i, s) {
      super(n), r = Math.abs(r), this.delayTime.value = i;
      const u = n.createGain();
      u.gain.value = Math.min(Math.abs(s), 0.995), this.feedback = u.gain;
      const a = n.createGain();
      return a.gain.value = r, this.delayGain = a, this.connect(u), this.connect(a), u.connect(this), this.connect = (o) => a.connect(o), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(t, n, r) {
    return new e(this, t, n, r);
  };
}
var qu = {};
qu.generateReverb = function(e, t) {
  for (var n = e.audioContext || new AudioContext(), r = n.sampleRate, i = e.numChannels || 2, s = e.decayTime * 1.5, u = Math.round(e.decayTime * r), a = Math.round(s * r), o = Math.round((e.fadeInTime || 0) * r), f = Math.pow(1 / 1e3, 1 / u), h = n.createBuffer(i, a, r), m = 0; m < i; m++) {
    for (var p = h.getChannelData(m), b = 0; b < a; b++)
      p[b] = zM() * Math.pow(f, b);
    for (var b = 0; b < o; b++)
      p[b] *= b / o;
  }
  WM(h, e.lpFreqStart || 0, e.lpFreqEnd || 0, e.decayTime, t);
};
qu.generateGraph = function(e, t, n, r, i) {
  var s = document.createElement("canvas");
  s.width = t, s.height = n;
  var u = s.getContext("2d");
  u.fillStyle = "#000", u.fillRect(0, 0, s.width, s.height), u.fillStyle = "#fff";
  for (var a = t / e.length, o = n / (i - r), f = 0; f < e.length; f++)
    u.fillRect(f * a, n - (e[f] - r) * o, 1, 1);
  return s;
};
var WM = function(e, t, n, r, i) {
  if (t == 0) {
    i(e);
    return;
  }
  var s = OM(e), u = new OfflineAudioContext(e.numberOfChannels, s[0].length, e.sampleRate), a = u.createBufferSource();
  a.buffer = e;
  var o = u.createBiquadFilter();
  t = Math.min(t, e.sampleRate / 2), n = Math.min(n, e.sampleRate / 2), o.type = "lowpass", o.Q.value = 1e-4, o.frequency.setValueAtTime(t, 0), o.frequency.linearRampToValueAtTime(n, r), a.connect(o), o.connect(u.destination), a.start(), u.oncomplete = function(f) {
    i(f.renderedBuffer);
  }, u.startRendering(), window.filterNode = o;
}, OM = function(e) {
  for (var t = [], n = 0; n < e.numberOfChannels; n++)
    t[n] = e.getChannelData(n);
  return t;
}, zM = function() {
  return Math.random() * 2 - 1;
};
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(e, t) {
  const n = t.sampleRate * e, r = this.createBuffer(t.numberOfChannels, t.length, t.sampleRate);
  for (let i = 0; i < t.numberOfChannels; i++) {
    let s = t.getChannelData(i), u = r.getChannelData(i);
    for (let a = 0; a < n; a++)
      u[a] = s[a] || 0;
  }
  return r;
}, AudioContext.prototype.createReverb = function(e, t, n, r, i) {
  const s = this.createConvolver();
  return s.generate = (u = 2, a = 0.1, o = 15e3, f = 1e3, h) => {
    s.duration = u, s.fade = a, s.lp = o, s.dim = f, s.ir = h, h ? s.buffer = this.adjustLength(u, h) : qu.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: u,
        fadeInTime: a,
        lpFreqStart: o,
        lpFreqEnd: f
      },
      (m) => {
        s.buffer = m;
      }
    );
  }, s.generate(e, t, n, r, i), s;
});
var Qa = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class e extends GainNode {
    constructor(n, r) {
      if (super(n), !Qa[r])
        throw new Error("vowel: unknown vowel " + r);
      const { gains: i, qs: s, freqs: u } = Qa[r], a = n.createGain();
      for (let o = 0; o < 5; o++) {
        const f = n.createGain();
        f.gain.value = i[o];
        const h = n.createBiquadFilter();
        h.type = "bandpass", h.Q.value = s[o], h.frequency.value = u[o], this.connect(h), h.connect(f), f.connect(a);
      }
      return a.gain.value = 8, this.connect = (o) => a.connect(o), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(t) {
    return new e(this, t);
  };
}
let Vp = (e) => console.log(e);
const xt = (...e) => Vp(...e), Np = (e) => {
  Vp = e;
}, jM = (e) => {
  if (typeof e != "string")
    return [];
  const [t, n = "", r] = e.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return t ? [t, n, r ? Number(r) : void 0] : [];
}, $M = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, qM = { "#": 1, b: -1, s: 1, f: -1 }, Wi = (e, t = 3) => {
  const [n, r, i = t] = jM(e);
  if (!n)
    throw new Error('not a note: "' + e + '"');
  const s = $M[n.toLowerCase()], u = r?.split("").reduce((a, o) => a + qM[o], 0) || 0;
  return (Number(i) + 1) * 12 + s + u;
}, Tp = (e) => Math.pow(2, (e - 69) / 12) * 440, dr = (e, t, n) => Math.min(Math.max(e, t), n), KM = (e) => 12 * Math.log(e / 440) / Math.LN2 + 69, HM = (e, t) => {
  if (typeof e != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: r } = e;
  return typeof n == "number" ? KM(n) : typeof r == "string" ? Wi(r) : typeof r == "number" ? r : t;
};
function mn(e, t = 0, n) {
  return isNaN(Number(e)) ? (!n && xt(`"${e}" is not a number, falling back to ${t}`, "warning"), t) : e;
}
const Rp = (e, t) => (e % t + t) % t, eo = (e, t) => Rp(Math.round(mn(e, 0)), t), UM = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHB0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBuPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW4/ITE6KHRoaXMuc3RhcnRlZD1uLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBkdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3Qgbz1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MobyksZVtzKzFdPS1NYXRoLnNpbihvKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbj0xO3RoaXMuc2l6ZT5uO248PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgYT0wO2E8dGhpcy5fd2lkdGg7YSs9Mil7dmFyIGw9dGhpcy5fd2lkdGgtYS0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj5hJjMpPDxsfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG49ZS9yPDwxLGksYSxsPXRoaXMuX2JpdHJldjtpZihuPT09NClmb3IoaT0wLGE9MDtpPGU7aSs9bixhKyspe2NvbnN0IGQ9bFthXTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksZCxyKX1lbHNlIGZvcihpPTAsYT0wO2k8ZTtpKz1uLGErKyl7Y29uc3QgZD1sW2FdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxkLHIpfXZhciBvPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjI7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIHY9aStmLGM9aSxwPTA7Yzx2O2MrPTIscCs9cil7Y29uc3QgZD1jLGc9ZCtmLG09ZytmLEk9bStmLF89dFtkXSx3PXRbZCsxXSxCPXRbZ10sYj10W2crMV0sQT10W21dLFA9dFttKzFdLFQ9dFtJXSx5PXRbSSsxXSx4PV8sRj13LEM9dVtwXSxrPW8qdVtwKzFdLHo9QipDLWIqayxWPUIqaytiKkMsTj11WzIqcF0scT1vKnVbMipwKzFdLFc9QSpOLVAqcSxZPUEqcStQKk4sTD11WzMqcF0sVT1vKnVbMypwKzFdLEg9VCpMLXkqVSxLPVQqVSt5KkwsWj14K1csTT1GK1ksTz14LVcsRz1GLVksSj16K0gsRT1WK0ssUj1vKih6LUgpLFE9byooVi1LKSwkPVorSixldD1NK0Usc3Q9Wi1KLHJ0PU0tRSxpdD1PK1EsbnQ9Ry1SLG90PU8tUSxhdD1HK1I7dFtkXT0kLHRbZCsxXT1ldCx0W2ddPWl0LHRbZysxXT1udCx0W21dPXN0LHRbbSsxXT1ydCx0W0ldPW90LHRbSSsxXT1hdH19fV9zaW5nbGVUcmFuc2Zvcm0yKHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT1uW2VdLGE9bltlKzFdLGw9bltlK3NdLG89bltlK3MrMV0sdT1pK2wsZj1hK28sdj1pLWwsYz1hLW87clt0XT11LHJbdCsxXT1mLHJbdCsyXT12LHJbdCszXT1jfV9zaW5nbGVUcmFuc2Zvcm00KHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT10aGlzLl9pbnY/LTE6MSxhPXMqMixsPXMqMyxvPW5bZV0sdT1uW2UrMV0sZj1uW2Urc10sdj1uW2UrcysxXSxjPW5bZSthXSxwPW5bZSthKzFdLGQ9bltlK2xdLGc9bltlK2wrMV0sbT1vK2MsST11K3AsXz1vLWMsdz11LXAsQj1mK2QsYj12K2csQT1pKihmLWQpLFA9aSoodi1nKSxUPW0rQix5PUkrYix4PV8rUCxGPXctQSxDPW0tQixrPUktYix6PV8tUCxWPXcrQTtyW3RdPVQsclt0KzFdPXksclt0KzJdPXgsclt0KzNdPUYsclt0KzRdPUMsclt0KzVdPWssclt0KzZdPXosclt0KzddPVZ9X3JlYWxUcmFuc2Zvcm00KCl7dmFyIHQ9dGhpcy5fb3V0LGU9dGhpcy5fY3NpemUscz10aGlzLl93aWR0aCxyPTE8PHMsbj1lL3I8PDEsaSxhLGw9dGhpcy5fYml0cmV2O2lmKG49PT00KWZvcihpPTAsYT0wO2k8ZTtpKz1uLGErKyl7Y29uc3QgaHQ9bFthXTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtMihpLGh0Pj4+MSxyPj4+MSl9ZWxzZSBmb3IoaT0wLGE9MDtpPGU7aSs9bixhKyspe2NvbnN0IGh0PWxbYV07dGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTQoaSxodD4+PjEscj4+PjEpfXZhciBvPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjEsdj1mPj4+MSxjPXY+Pj4xO2ZvcihpPTA7aTxlO2krPW4pZm9yKHZhciBwPTAsZD0wO3A8PWM7cCs9MixkKz1yKXt2YXIgZz1pK3AsbT1nK3YsST1tK3YsXz1JK3Ysdz10W2ddLEI9dFtnKzFdLGI9dFttXSxBPXRbbSsxXSxQPXRbSV0sVD10W0krMV0seT10W19dLHg9dFtfKzFdLEY9dyxDPUIsaz11W2RdLHo9byp1W2QrMV0sVj1iKmstQSp6LE49Yip6K0EqayxxPXVbMipkXSxXPW8qdVsyKmQrMV0sWT1QKnEtVCpXLEw9UCpXK1QqcSxVPXVbMypkXSxIPW8qdVszKmQrMV0sSz15KlUteCpILFo9eSpIK3gqVSxNPUYrWSxPPUMrTCxHPUYtWSxKPUMtTCxFPVYrSyxSPU4rWixRPW8qKFYtSyksJD1vKihOLVopLGV0PU0rRSxzdD1PK1IscnQ9RyskLGl0PUotUTtpZih0W2ddPWV0LHRbZysxXT1zdCx0W21dPXJ0LHRbbSsxXT1pdCxwPT09MCl7dmFyIG50PU0tRSxvdD1PLVI7dFtJXT1udCx0W0krMV09b3Q7Y29udGludWV9aWYocCE9PWMpe3ZhciBhdD1HLGt0PS1KLHp0PU0sVnQ9LU8sTXQ9LW8qJCxPdD0tbypRLEV0PS1vKlIsUnQ9LW8qRSxEdD1hdCtNdCxOdD1rdCtPdCxxdD16dCtSdCxXdD1WdC1FdCxsdD1pK3YtcCxmdD1pK2YtcDt0W2x0XT1EdCx0W2x0KzFdPU50LHRbZnRdPXF0LHRbZnQrMV09V3R9fX19X3NpbmdsZVJlYWxUcmFuc2Zvcm0yKHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT1uW2VdLGE9bltlK3NdLGw9aSthLG89aS1hO3JbdF09bCxyW3QrMV09MCxyW3QrMl09byxyW3QrM109MH1fc2luZ2xlUmVhbFRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLGE9cyoyLGw9cyozLG89bltlXSx1PW5bZStzXSxmPW5bZSthXSx2PW5bZStsXSxjPW8rZixwPW8tZixkPXUrdixnPWkqKHUtdiksbT1jK2QsST1wLF89LWcsdz1jLWQsQj1wLGI9ZztyW3RdPW0sclt0KzFdPTAsclt0KzJdPUksclt0KzNdPV8sclt0KzRdPXcsclt0KzVdPTAsclt0KzZdPUIsclt0KzddPWJ9fWNvbnN0IFg9KGgsdCxlKT0+TWF0aC5taW4oTWF0aC5tYXgoaCx0KSxlKSx2dD0oaCx0KT0+KGgldCt0KSV0LEQ9MTI4O2Z1bmN0aW9uIG10KGgsdCl7cmV0dXJuIGg8dD8oaC89dCxoK2gtaCpoLTEpOmg+MS10PyhoPShoLTEpL3QsaCpoK2graCsxKTowfWNvbnN0IGo9e3RyaShoLHQ9LjUpe2NvbnN0IGU9MS10O3JldHVybiBoPj10PzEvZS1oL2U6aC90fSxzaW5lKGgpe3JldHVybiBNYXRoLnNpbihNYXRoLlBJKjIqaCkqLjUrLjV9LHJhbXAoaCl7cmV0dXJuIGh9LHNhdyhoKXtyZXR1cm4gMS1ofSxzcXVhcmUoaCx0PS41KXtyZXR1cm4gaD49dD8wOjF9LGN1c3RvbShoLHQ9WzAsMV0pe2NvbnN0IGU9dC5sZW5ndGgtMSxzPU1hdGguZmxvb3IoaCplKSxyPTEvZSxuPVgodFtzXSwwLDEpLGE9WCh0W3MrMV0sMCwxKSxsPW4sbz0wLHU9cjtyZXR1cm4oYS1sKS8odS1vKSooaC1yKnMpK259LHNhd2JsZXAoaCx0KXtyZXR1cm4gMipoLTEtbXQoaCx0KX19O2Z1bmN0aW9uIHR0KGgsdCl7cmV0dXJuIHQubGVuZ3RoPjE/dFtoXTp0WzBdfWNvbnN0IGd0PU9iamVjdC5rZXlzKGopO2NsYXNzIEl0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InRpbWUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToic2tldyIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToiZGVwdGgiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToicGhhc2VvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZGNvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2V9aW5jcmVtZW50UGhhc2UodCl7dGhpcy5waGFzZSs9dCx0aGlzLnBoYXNlPjEmJih0aGlzLnBoYXNlPXRoaXMucGhhc2UtMSl9cHJvY2Vzcyh0LGUscyl7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXSxuPXMuZnJlcXVlbmN5WzBdLGk9cy50aW1lWzBdLGE9cy5kZXB0aFswXSxsPXMuc2tld1swXSxvPXMucGhhc2VvZmZzZXRbMF0sdT1zLmRjb2Zmc2V0WzBdLGY9Z3Rbcy5zaGFwZVswXV0sdj1yWzBdLmxlbmd0aD8/MDt0aGlzLnBoYXNlPT1udWxsJiYodGhpcy5waGFzZT12dChpKm4rbywxKSk7Y29uc3QgYz1uL3NhbXBsZVJhdGU7Zm9yKGxldCBwPTA7cDx2O3ArKyl7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspe2NvbnN0IGc9KGpbZl0odGhpcy5waGFzZSxsKSt1KSphO3JbZF1bcF09Z310aGlzLmluY3JlbWVudFBoYXNlKGMpfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGZvLXByb2Nlc3NvciIsSXQpO2NsYXNzIEJ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNvYXJzZSIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IGE9cy5jb2Fyc2VbMF0/PzA7YT1NYXRoLm1heCgxLGEpO2ZvcihsZXQgbD0wO2w8RDtsKyspZm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspbltvXVtsXT1sJWE9PT0wP3Jbb11bbF06bltvXVtsLTFdO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY29hcnNlLXByb2Nlc3NvciIsQnQpO2NsYXNzIGJ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNydXNoIixkZWZhdWx0VmFsdWU6MH1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG49ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgYT1zLmNydXNoWzBdPz84O2E9TWF0aC5tYXgoMSxhKTtmb3IobGV0IGw9MDtsPEQ7bCsrKWZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCB1PU1hdGgucG93KDIsYS0xKTtuW29dW2xdPU1hdGgucm91bmQocltvXVtsXSp1KS91fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY3J1c2gtcHJvY2Vzc29yIixidCk7Y2xhc3MgX3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCBhPXMuc2hhcGVbMF07YT1hPDE/YToxLTRlLTEwLGE9MiphLygxLWEpO2NvbnN0IGw9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IG89MDtvPEQ7bysrKWZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKW5bdV1bb109KDErYSkqclt1XVtvXS8oMSthKk1hdGguYWJzKHJbdV1bb10pKSpsO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic2hhcGUtcHJvY2Vzc29yIixfdCk7ZnVuY3Rpb24gUyhoKXtjb25zdCB0PWgqaDtyZXR1cm4gaCooMjcrdCkvKDI3KzkqdCl9Y29uc3QgdXQ9My4xNDE1OTI2NTM1OTtjbGFzcyB3dCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo1MDB9LHtuYW1lOiJxIixkZWZhdWx0VmFsdWU6MX0se25hbWU6ImRyaXZlIixkZWZhdWx0VmFsdWU6LjY5fV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLnAwPVswLDBdLHRoaXMucDE9WzAsMF0sdGhpcy5wMj1bMCwwXSx0aGlzLnAzPVswLDBdLHRoaXMucDMyPVswLDBdLHRoaXMucDMzPVswLDBdLHRoaXMucDM0PVswLDBdfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7Y29uc3QgYT1zLnFbMF0sbD1YKE1hdGguZXhwKHMuZHJpdmVbMF0pLC4xLDJlMyk7bGV0IG89cy5mcmVxdWVuY3lbMF07bz1vKjIqdXQvc2FtcGxlUmF0ZSxvPW8+MT8xOm87Y29uc3QgdT1NYXRoLm1pbig4LGEqLjQpO2xldCBmPTEvbCpNYXRoLm1pbigxLjc1LDErdSk7Zm9yKGxldCB2PTA7djxEO3YrKylmb3IobGV0IGM9MDtjPHIubGVuZ3RoO2MrKyl7Y29uc3QgcD10aGlzLnAzW2NdKi4zNjA4OTErdGhpcy5wMzJbY10qLjQxNzI5K3RoaXMucDMzW2NdKi4xNzc4OTYrdGhpcy5wMzRbY10qLjA0Mzk3MjU7dGhpcy5wMzRbY109dGhpcy5wMzNbY10sdGhpcy5wMzNbY109dGhpcy5wMzJbY10sdGhpcy5wMzJbY109dGhpcy5wM1tjXSx0aGlzLnAwW2NdKz0oUyhyW2NdW3ZdKmwtdSpwKS1TKHRoaXMucDBbY10pKSpvLHRoaXMucDFbY10rPShTKHRoaXMucDBbY10pLVModGhpcy5wMVtjXSkpKm8sdGhpcy5wMltjXSs9KFModGhpcy5wMVtjXSktUyh0aGlzLnAyW2NdKSkqbyx0aGlzLnAzW2NdKz0oUyh0aGlzLnAyW2NdKS1TKHRoaXMucDNbY10pKSpvLG5bY11bdl09cCpmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGFkZGVyLXByb2Nlc3NvciIsd3QpO2NsYXNzIFN0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImRpc3RvcnQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IGE9TWF0aC5leHBtMShzLmRpc3RvcnRbMF0pLGw9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IG89MDtvPEQ7bysrKWZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKW5bdV1bb109KDErYSkqclt1XVtvXS8oMSthKk1hdGguYWJzKHJbdV1bb10pKSpsO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGlzdG9ydC1wcm9jZXNzb3IiLFN0KTtmdW5jdGlvbiBBdChoLHQsZSl7cmV0dXJuIGUqKHQtaCkraH1mdW5jdGlvbiBQdChoLHQsZSl7cmV0dXJuIGg8Mj8wOkF0KC10Ki41LHQqLjUsZS8oaC0xKSl9ZnVuY3Rpb24gY3QoaCx0KXtyZXR1cm4gaCpNYXRoLnBvdygyLHQvMTIpfWNsYXNzIFR0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7bGV0IHI9cy5mcmVxdWVuY3lbMF07cj1yKk1hdGgucG93KDIscy5kZXR1bmVbMF0vMTIwMCk7Y29uc3Qgbj1lWzBdLGk9cy52b2ljZXNbMF0sYT1zLmZyZXFzcHJlYWRbMF0sbD1zLnBhbnNwcmVhZFswXSouNSsuNSxvPU1hdGguc3FydCgxLWwpLHU9TWF0aC5zcXJ0KGwpO2ZvcihsZXQgZj0wO2Y8aTtmKyspe2NvbnN0IHY9KGYmMSk9PTEsYz1jdChyLFB0KGksYSxmKSk7bGV0IHA9byxkPXU7diYmKHA9dSxkPW8pO2NvbnN0IGc9Yy9zYW1wbGVSYXRlO2ZvcihsZXQgbT0wO208blswXS5sZW5ndGg7bSsrKXt0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0/P01hdGgucmFuZG9tKCk7Y29uc3QgST1qLnNhd2JsZXAodGhpcy5waGFzZVtmXSxnKTtuWzBdW21dPW5bMF1bbV0rSSpwLG5bMV1bbV09blsxXVttXStJKmQsdGhpcy5waGFzZVtmXSs9Zyx0aGlzLnBoYXNlW2ZdPjEmJih0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0tMSl9fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic3VwZXJzYXctb3NjaWxsYXRvciIsVHQpO2NvbnN0IHl0PTIwNDg7ZnVuY3Rpb24geHQoaCl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShoKTtmb3IodmFyIGU9MDtlPGg7ZSsrKXRbZV09LjUqKDEtTWF0aC5jb3MoMipNYXRoLlBJKmUvaCkpO3JldHVybiB0fWNsYXNzIEZ0IGV4dGVuZHMgcHR7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToicGl0Y2hGYWN0b3IiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IodCl7dC5wcm9jZXNzb3JPcHRpb25zPXtibG9ja1NpemU6eXR9LHN1cGVyKHQpLHRoaXMuZmZ0U2l6ZT10aGlzLmJsb2NrU2l6ZSx0aGlzLnRpbWVDdXJzb3I9MCx0aGlzLmhhbm5XaW5kb3c9eHQodGhpcy5ibG9ja1NpemUpLHRoaXMuZmZ0PW5ldyBkdCh0aGlzLmZmdFNpemUpLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXI9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQ9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy50aW1lQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLm1hZ25pdHVkZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmZmdFNpemUvMisxKSx0aGlzLnBlYWtJbmRleGVzPW5ldyBJbnQzMkFycmF5KHRoaXMubWFnbml0dWRlcy5sZW5ndGgpLHRoaXMubmJQZWFrcz0wfXByb2Nlc3NPTEEodCxlLHMpe2xldCByPXMucGl0Y2hGYWN0b3Jbcy5waXRjaEZhY3Rvci5sZW5ndGgtMV07cjwwJiYocj1yKi4yNSkscj1NYXRoLm1heCgwLHIrMSk7Zm9yKHZhciBuPTA7bjx0aGlzLm5iSW5wdXRzO24rKylmb3IodmFyIGk9MDtpPHRbbl0ubGVuZ3RoO2krKyl7dmFyIGE9dFtuXVtpXSxsPWVbbl1baV07dGhpcy5hcHBseUhhbm5XaW5kb3coYSksdGhpcy5mZnQucmVhbFRyYW5zZm9ybSh0aGlzLmZyZXFDb21wbGV4QnVmZmVyLGEpLHRoaXMuY29tcHV0ZU1hZ25pdHVkZXMoKSx0aGlzLmZpbmRQZWFrcygpLHRoaXMuc2hpZnRQZWFrcyhyKSx0aGlzLmZmdC5jb21wbGV0ZVNwZWN0cnVtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkKSx0aGlzLmZmdC5pbnZlcnNlVHJhbnNmb3JtKHRoaXMudGltZUNvbXBsZXhCdWZmZXIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmZyb21Db21wbGV4QXJyYXkodGhpcy50aW1lQ29tcGxleEJ1ZmZlcixsKSx0aGlzLmFwcGx5SGFubldpbmRvdyhsKX10aGlzLnRpbWVDdXJzb3IrPXRoaXMuaG9wU2l6ZX1hcHBseUhhbm5XaW5kb3codCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmJsb2NrU2l6ZTtlKyspdFtlXT10W2VdKnRoaXMuaGFubldpbmRvd1tlXSoxLjYyfWNvbXB1dGVNYWduaXR1ZGVzKCl7Zm9yKHZhciB0PTAsZT0wO3Q8dGhpcy5tYWduaXR1ZGVzLmxlbmd0aDspe2xldCBzPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZV0scj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2UrMV07dGhpcy5tYWduaXR1ZGVzW3RdPXMqKjIrcioqMix0Kz0xLGUrPTJ9fWZpbmRQZWFrcygpe3RoaXMubmJQZWFrcz0wO3ZhciB0PTI7bGV0IGU9dGhpcy5tYWduaXR1ZGVzLmxlbmd0aC0yO2Zvcig7dDxlOyl7bGV0IHM9dGhpcy5tYWduaXR1ZGVzW3RdO2lmKHRoaXMubWFnbml0dWRlc1t0LTFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdC0yXT49cyl7dCsrO2NvbnRpbnVlfWlmKHRoaXMubWFnbml0dWRlc1t0KzFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdCsyXT49cyl7dCsrO2NvbnRpbnVlfXRoaXMucGVha0luZGV4ZXNbdGhpcy5uYlBlYWtzXT10LHRoaXMubmJQZWFrcysrLHQrPTJ9fXNoaWZ0UGVha3ModCl7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQuZmlsbCgwKTtmb3IodmFyIGU9MDtlPHRoaXMubmJQZWFrcztlKyspe2xldCBpPXRoaXMucGVha0luZGV4ZXNbZV0sYT1NYXRoLnJvdW5kKGkqdCk7aWYoYT50aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO3ZhciBzPTAscj10aGlzLmZmdFNpemU7aWYoZT4wKXtsZXQgdT10aGlzLnBlYWtJbmRleGVzW2UtMV07cz1pLU1hdGguZmxvb3IoKGktdSkvMil9aWYoZTx0aGlzLm5iUGVha3MtMSl7bGV0IHU9dGhpcy5wZWFrSW5kZXhlc1tlKzFdO3I9aStNYXRoLmNlaWwoKHUtaSkvMil9bGV0IGw9cy1pLG89ci1pO2Zvcih2YXIgbj1sO248bztuKyspe2xldCB1PWkrbixmPWErbjtpZihmPj10aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO2xldCB2PTIqTWF0aC5QSSooZi11KS90aGlzLmZmdFNpemUsYz1NYXRoLmNvcyh2KnRoaXMudGltZUN1cnNvcikscD1NYXRoLnNpbih2KnRoaXMudGltZUN1cnNvciksZD11KjIsZz1kKzEsbT10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2RdLEk9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltnXSxfPW0qYy1JKnAsdz1tKnArSSpjLEI9ZioyLGI9QisxO3RoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW0JdKz1fLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW2JdKz13fX19fXJlZ2lzdGVyUHJvY2Vzc29yKCJwaGFzZS12b2NvZGVyLXByb2Nlc3NvciIsRnQpO2NsYXNzIEN0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBpPXV0LHRoaXMucGhpPS10aGlzLnBpLHRoaXMuWTA9MCx0aGlzLlkxPTAsdGhpcy5QVz10aGlzLnBpLHRoaXMuQj0yLjMsdGhpcy5kcGhpZj0wLHRoaXMuZW52Zj0wfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToicHVsc2V3aWR0aCIsZGVmYXVsdFZhbHVlOjEsbWluOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtjb25zdCByPWVbMF07bGV0IG49MSxpO2ZvcihsZXQgYT0wO2E8KHJbMF0ubGVuZ3RoPz8wKTthKyspe2NvbnN0IGw9KDEtWCh0dChhLHMucHVsc2V3aWR0aCksLS45OSwuOTkpKSp0aGlzLnBpLG89dHQoYSxzLmRldHVuZSksdT1jdCh0dChhLHMuZnJlcXVlbmN5KSxvLzEwMCk7aT11Kih0aGlzLnBpLyhzYW1wbGVSYXRlKi41KSksdGhpcy5kcGhpZis9LjEqKGktdGhpcy5kcGhpZiksbio9Ljk5OTgsdGhpcy5lbnZmKz0uMSoobi10aGlzLmVudmYpLHRoaXMuQj0yLjMqKDEtMWUtNCp1KSx0aGlzLkI8MCYmKHRoaXMuQj0wKSx0aGlzLnBoaSs9dGhpcy5kcGhpZix0aGlzLnBoaT49dGhpcy5waSYmKHRoaXMucGhpLT0yKnRoaXMucGkpO2xldCBmPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkwKTt0aGlzLlkwPS41KihmK3RoaXMuWTApO2xldCB2PU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkxK2wpO3RoaXMuWTE9LjUqKHYrdGhpcy5ZMSk7Zm9yKGxldCBjPTA7YzxyLmxlbmd0aDtjKyspcltjXVthXT0uMTUqKGYtdikqdGhpcy5lbnZmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigicHVsc2Utb3NjaWxsYXRvciIsQ3QpfSkoKTsK";
function pn(e) {
  const t = xe().createGain();
  return t.gain.value = e, t;
}
const to = (e, t, n, r) => r - n === 0 ? 0 : (t - e) / (r - n);
function Jt(e, t, n, r) {
  const i = new AudioWorkletNode(e, t, r);
  return Object.entries(n).forEach(([s, u]) => {
    i.parameters.get(s).value = u;
  }), i;
}
const gn = (e, t, n, r, i, s, u, a, o, f = "exponential") => {
  t = mn(t), n = mn(n), r = mn(r), i = mn(i);
  const h = f === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  f === "exponential" && (s = s === 0 ? 1e-3 : s, u = u === 0 ? 1e-3 : u);
  const m = u - s, p = u, b = s + r * m, M = o - a, v = (E) => {
    let I;
    if (t > E) {
      let _ = to(s, p, 0, t);
      I = E * _ + (s > p ? s : 0);
    } else
      I = (E - t) * to(p, b, 0, n) + p;
    return f === "exponential" && (I = I || 1e-3), I;
  };
  e.setValueAtTime(s, a), t > M ? e[h](v(M), o) : t + n > M ? (e[h](v(t), a + t), e[h](v(M), o)) : (e[h](v(t), a + t), e[h](v(t + n), a + t + n), e.setValueAtTime(b, o)), e[h](s, o + i);
};
function Lp(e, t, n, r, i, s) {
  const u = {
    threshold: t ?? -3,
    ratio: n ?? 10,
    knee: r ?? 10,
    attack: i ?? 5e-3,
    release: s ?? 0.05
  };
  return new DynamicsCompressorNode(e, u);
}
const yn = (e, t = "linear", n) => {
  const [u, a, o, f] = e;
  if (u == null && a == null && o == null && f == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const h = o ?? (u != null && a == null || u == null && a == null ? 1 : 1e-3);
  return [Math.max(u ?? 0, 1e-3), Math.max(a ?? 0, 1e-3), Math.min(h, 1), Math.max(f ?? 0, 0.01)];
};
function bi(e, t, n, r, i, s, u, a, o, f, h, m, p, b) {
  const M = "exponential", [v, E, I, _] = yn([i, s, u, a], M, [5e-3, 0.14, 0, 0.1]);
  let X, S;
  if (p === "ladder" ? (X = Jt(e, "ladder-processor", { frequency: n, q: r, drive: b }), S = X.parameters.get("frequency")) : (X = e.createBiquadFilter(), X.type = t, X.Q.value = r, X.frequency.value = n, S = X.frequency), (i ?? s ?? u ?? a ?? o) !== void 0) {
    o = mn(o, 1, !0), m = mn(m, 0, !0);
    const B = Math.abs(o), k = B * m;
    let V = dr(2 ** -k * n, 0, 2e4), q = dr(2 ** (B - k) * n, 0, 2e4);
    return o < 0 && ([V, q] = [q, V]), gn(S, v, E, I, _, V, q, f, h, M), X;
  }
  return X;
}
let no = (e) => e < 0.5 ? 1 : 1 - (e - 0.5) / 0.5;
function Gp(e, t, n = 0) {
  const r = xe();
  if (!n)
    return e;
  let i = r.createGain(), s = r.createGain();
  e.connect(i), t.connect(s), i.gain.value = no(n), s.gain.value = no(1 - n);
  let u = r.createGain();
  return i.connect(u), s.connect(u), u;
}
let JM = ["linear", "exponential"];
function Ur(e, t, n, r) {
  if (!(t.pattack ?? t.pdecay ?? t.psustain ?? t.prelease ?? t.penv))
    return;
  const s = mn(t.penv, 1, !0), u = JM[t.pcurve ?? 0];
  let [a, o, f, h] = yn(
    [t.pattack, t.pdecay, t.psustain, t.prelease],
    u,
    [0.2, 1e-3, 1, 1e-3]
  ), m = t.panchor ?? f;
  const p = s * 100, b = 0 - p * m, M = p - p * m;
  gn(e, a, o, f, h, b, M, n, r, u);
}
function Jr(e, t, n) {
  const { vibmod: r = 0.5, vib: i } = t;
  let s;
  if (i > 0) {
    s = xe().createOscillator(), s.frequency.value = i;
    const u = xe().createGain();
    return u.gain.value = r * 100, s.connect(u), u.connect(e), s.start(n), s;
  }
}
function iu(e, t, n, r) {
  const i = e.createConstantSource();
  return i.start(n), i.stop(r), i.onended = () => {
    t();
  }, i;
}
const YM = (e, t = 1, n = "sine") => {
  const r = xe(), i = r.createOscillator();
  i.type = n, i.frequency.value = e, i.start();
  const s = new GainNode(r, { gain: t });
  return i.connect(s), { node: s, stop: (u) => i.stop(u) };
}, QM = (e, t, n, r = "sine") => {
  const s = e.value * t, u = s * n;
  return YM(s, u, r);
};
function wi(e, t, n) {
  const {
    fmh: r = 1,
    fmi: i,
    fmenv: s = "exp",
    fmattack: u,
    fmdecay: a,
    fmsustain: o,
    fmrelease: f,
    fmvelocity: h,
    fmwave: m = "sine",
    duration: p
  } = t;
  let b, M = () => {
  };
  if (i) {
    const E = xe().createGain(), I = QM(e, r, i, m);
    if (b = I.node, M = I.stop, ![u, a, o, f, h].find((_) => _ !== void 0))
      b.connect(e);
    else {
      const [_, X, S, x] = yn([u, a, o, f]), B = n + p;
      gn(
        E.gain,
        _,
        X,
        S,
        x,
        0,
        1,
        n,
        B,
        s === "exp" ? "exponential" : "linear"
      ), b.connect(E), E.connect(e);
    }
  }
  return { stop: M };
}
let Gt = [], En = 0;
const mi = 4;
let eC = (e) => {
  let t = [], n = {
    get() {
      return n.lc || n.listen(() => {
      })(), n.value;
    },
    lc: 0,
    listen(r) {
      return n.lc = t.push(r), () => {
        for (let s = En + mi; s < Gt.length; )
          Gt[s] === r ? Gt.splice(s, mi) : s += mi;
        let i = t.indexOf(r);
        ~i && (t.splice(i, 1), --n.lc || n.off());
      };
    },
    notify(r, i) {
      let s = !Gt.length;
      for (let u of t)
        Gt.push(
          u,
          n.value,
          r,
          i
        );
      if (s) {
        for (En = 0; En < Gt.length; En += mi)
          Gt[En](
            Gt[En + 1],
            Gt[En + 2],
            Gt[En + 3]
          );
        Gt.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let i = n.value;
      i !== r && (n.value = r, n.notify(i));
    },
    subscribe(r) {
      let i = n.listen(r);
      return r(n.value), i;
    },
    value: e
  };
  return n;
}, tC = (e = {}) => {
  let t = eC(e);
  return t.setKey = function(n, r) {
    let i = t.value;
    typeof r > "u" && n in t.value ? (t.value = { ...t.value }, delete t.value[n], t.notify(i, n)) : t.value[n] !== r && (t.value = {
      ...t.value,
      [n]: r
    }, t.notify(i, n));
  }, t;
};
const Ku = {}, Ms = {}, nC = (e) => Ku[e];
function rC(e, t) {
  var n = 1024;
  if (e < n) return e + " B";
  var r = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], i = -1;
  do
    e /= n, ++i;
  while (e >= n);
  return e.toFixed(1) + " " + r[i];
}
function Xp(e, t) {
  const { s: n, n: r = 0, speed: i = 1 } = e;
  let s = HM(e, 36), u = s - 36, a, o = 0;
  if (Array.isArray(t))
    o = eo(r, t.length), a = t[o];
  else {
    const m = (b) => Wi(b) - s, p = Object.keys(t).filter((b) => !b.startsWith("_")).reduce(
      (b, M, v) => !b || Math.abs(m(M)) < Math.abs(m(b)) ? M : b,
      null
    );
    u = -m(p), o = eo(r, t[p].length), a = t[p][o];
  }
  const f = `${n}:${o}`;
  let h = Math.abs(i) * Math.pow(2, u / 12);
  return { transpose: u, sampleUrl: a, index: o, midi: s, label: f, playbackRate: h };
}
const Zp = async (e, t, n) => {
  let { sampleUrl: r, label: i, playbackRate: s } = Xp(e, t);
  n && (r = await n(r));
  const u = xe(), a = await Hu(r, u, i);
  return e.unit === "c" && (s = s * a.duration), { buffer: a, playbackRate: s };
}, Wp = async (e, t, n) => {
  let { buffer: r, playbackRate: i } = await Zp(e, t, n);
  e.speed < 0 && (r = Op(r));
  const u = xe().createBufferSource();
  u.buffer = r, u.playbackRate.value = i;
  const { s: a, loopBegin: o = 0, loopEnd: f = 1, begin: h = 0, end: m = 1 } = e, p = h * u.buffer.duration;
  (a.startsWith("wt_") ? 1 : e.loop) && (u.loop = !0, u.loopStart = o * u.buffer.duration - p, u.loopEnd = f * u.buffer.duration - p);
  const M = u.buffer.duration / u.playbackRate.value, v = (m - h) * M;
  return { bufferSource: u, offset: p, bufferDuration: M, sliceDuration: v };
}, Hu = (e, t, n, r = 0) => {
  const i = n ? `sound "${n}:${r}"` : "sample";
  if (e = e.replace("#", "%23"), !Ms[e]) {
    xt(`[sampler] load ${i}..`, "load-sample", { url: e });
    const s = Date.now();
    Ms[e] = fetch(e).then((u) => u.arrayBuffer()).then(async (u) => {
      const a = Date.now() - s, o = rC(u.byteLength);
      xt(`[sampler] load ${i}... done! loaded ${o} in ${a}ms`, "loaded-sample", { url: e });
      const f = await t.decodeAudioData(u);
      return Ku[e] = f, f;
    });
  }
  return Ms[e];
};
function Op(e) {
  const t = xe(), n = t.createBuffer(e.numberOfChannels, e.length, t.sampleRate);
  for (let r = 0; r < e.numberOfChannels; r++)
    n.copyToChannel(e.getChannelData(r).slice().reverse(), r, r);
  return n;
}
const iC = (e) => Ku[e];
function zp(e) {
  if (e.startsWith("bubo:")) {
    const [t, n] = e.split(":");
    e = `github:Bubobubobubobubo/dough-${n}`;
  }
  return e;
}
function jp(e, t = "") {
  if (!e.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, r] = e.split("github:");
  return r = r.endsWith("/") ? r.slice(0, -1) : r, r.split("/").length === 2 && (r += "/main"), `https://raw.githubusercontent.com/${r}/${t}`;
}
const $p = (e, t, n = e._base || "") => Object.entries(e).forEach(([r, i]) => {
  if (typeof i == "string" && (i = [i]), typeof i != "object")
    throw new Error("wrong sample map format for " + r);
  n = i._base || n, n = zp(n), n.startsWith("github:") && (n = jp(n, ""));
  const s = (u) => n + u;
  Array.isArray(i) ? i = i.map(s) : i = Object.fromEntries(
    Object.entries(i).map(([u, a]) => [u, (typeof a == "string" ? [a] : a).map(s)])
  ), t(r, i);
});
let qp = {};
function sC(e, t) {
  qp[e] = t;
}
function uC(e) {
  const t = Object.entries(qp).find(([n]) => e.startsWith(n));
  if (t)
    return t[1];
}
const Kp = async (e, t = e._base || "", n = {}) => {
  if (typeof e == "string") {
    const s = uC(e);
    if (s)
      return s(e);
    if (e = zp(e), e.startsWith("github:") && (e = jp(e, "strudel.json")), e.startsWith("local:") && (e = "http://localhost:5432"), e.startsWith("shabda:")) {
      let [a, o] = e.split("shabda:");
      e = `https://shabda.ndre.gr/${o}.json?strudel=1`;
    }
    if (e.startsWith("shabda/speech")) {
      let [a, o] = e.split("shabda/speech");
      o = o.startsWith("/") ? o.substring(1) : o;
      let [f, h] = o.split(":"), m = "f", p = "en-GB";
      f && ([p, m] = f.split("/")), e = `https://shabda.ndre.gr/speech/${h}.json?gender=${m}&language=${p}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const u = e.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(e).then((a) => a.json()).then((a) => Kp(a, t || a._base || u, n)).catch((a) => {
      throw console.error(a), new Error(`error loading "${e}"`);
    });
  }
  const { prebake: r, tag: i } = n;
  $p(
    e,
    (s, u) => Wn(s, (a, o, f) => Hp(a, o, f, u), {
      type: "sample",
      samples: u,
      baseUrl: t,
      prebake: r,
      tag: i
    }),
    t
  );
}, ro = [];
async function Hp(e, t, n, r, i) {
  let {
    s,
    nudge: u = 0,
    // TODO: is this in seconds?
    cut: a,
    loop: o,
    clip: f = void 0,
    // if set, samples will be cut off when the hap ends
    n: h = 0,
    speed: m = 1,
    // sample playback speed
    duration: p
  } = t;
  if (m === 0)
    return;
  const b = xe();
  let [M, v, E, I] = yn([t.attack, t.decay, t.sustain, t.release]);
  const { bufferSource: _, sliceDuration: X, offset: S } = await Wp(t, r, i);
  if (b.currentTime > e) {
    xt(`[sampler] still loading sound "${s}:${h}"`, "highlight");
    return;
  }
  if (!_) {
    xt(`[sampler] could not load "${s}:${h}"`, "error");
    return;
  }
  let x = Jr(_.detune, t, e);
  const B = e + u;
  _.start(B, S);
  const k = b.createGain(), V = _.connect(k);
  f == null && o == null && t.release == null && (p = X);
  let q = e + p;
  gn(V.gain, M, v, E, I, 0, 1, e, q, "linear"), Ur(_.detune, t, e, q);
  const G = b.createGain();
  V.connect(G), _.onended = function() {
    _.disconnect(), x?.stop(), V.disconnect(), G.disconnect(), n();
  };
  let Y = q + I + 0.01;
  _.stop(Y);
  const O = { node: G, bufferSource: _, stop: (te) => {
    _.stop(te);
  } };
  if (a !== void 0) {
    const te = ro[a];
    te && (te.node.gain.setValueAtTime(1, B), te.node.gain.linearRampToValueAtTime(0, B + 0.01)), ro[a] = O;
  }
  return O;
}
const Uu = 128, su = "System Standard";
let Up = Uu;
function Jp(e) {
  Up = parseInt(e) ?? Uu;
}
const mr = tC();
function Wn(e, t, n = {}) {
  e = e.toLowerCase().replace(/\s+/g, "_"), mr.setKey(e, { onTrigger: t, data: n });
}
let Yp = (e) => e;
function Xn(e) {
  return Yp(e);
}
function aC(e) {
  Yp = e;
}
function uu(e) {
  for (const n in e)
    e[n.toLowerCase()] = e[n];
  const t = mr.get();
  for (const n in t) {
    const [r, i] = n.split("_");
    if (!i) continue;
    const s = e[r];
    if (s) {
      if (typeof s == "string")
        t[`${s}_${i}`.toLowerCase()] = t[n];
      else if (Array.isArray(s))
        for (const u of s)
          t[`${u}_${i}`.toLowerCase()] = t[n];
    }
  }
  mr.set({ ...t });
}
async function oC(e) {
  const n = await (await fetch(e)).json();
  uu(n);
}
async function cC(...e) {
  switch (e.length) {
    case 1:
      return typeof e[0] == "string" ? oC(e[0]) : uu(e[0]);
    case 2:
      return uu({ [e[0]]: e[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + e.length);
  }
}
function Mi(e) {
  return mr.get()[e.toLowerCase()];
}
const Qp = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let e = await navigator.mediaDevices.enumerateDevices();
  e = e.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const t = /* @__PURE__ */ new Map();
  return t.set(su, ""), e.forEach((n) => {
    t.set(n.label, n.deviceId);
  }), t;
}, ed = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  delayfeedback: 0.5,
  delaytime: 0.25,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
let Ju = new Map(Object.entries(ed));
function Yu(e, t) {
  Ju.set(e, t);
}
function He(e) {
  return Ju.get(e);
}
function lC(e) {
  Object.keys(e).forEach((t) => {
    Yu(t, e[t]);
  });
}
function td() {
  Ju = new Map(Object.entries(ed));
}
function fC(e) {
  td(), e === "1.0" && Yu("fanchor", 0.5);
}
const hC = () => mr.set({});
let Si;
const nd = () => (Si = new AudioContext(), Si), xe = () => Si || nd();
function pC() {
  return xe().currentTime;
}
let Cs;
function dC() {
  return Cs || (Cs = xe().audioWorklet.addModule(UM)), Cs;
}
async function rd(e = {}) {
  const { disableWorklets: t = !1, maxPolyphony: n, audioDeviceName: r = su } = e;
  if (Jp(n), typeof window > "u")
    return;
  const i = xe();
  if (r != null && r != su)
    try {
      const u = (await Qp()).get(r), a = (u ?? "").length > 0;
      i.sinkId !== u && a && await i.setSinkId(u), xt(
        `[superdough] Audio Device set to ${r}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      xt("[superdough] failed to set audio interface", "warning");
    }
  if (await i.resume(), t) {
    xt("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await dC(), xt("[superdough] AudioWorklets loaded");
  } catch (s) {
    console.warn("could not load AudioWorklet effects", s);
  }
  xt("[superdough] ready");
}
let vs;
async function id(e) {
  return vs || (vs = new Promise((t) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await rd(e), t();
    });
  })), vs;
}
let wn = {}, Bi, fr;
function sd() {
  const e = xe(), t = e.destination.maxChannelCount;
  e.destination.channelCount = t, Bi = new ChannelMergerNode(e, { numberOfInputs: e.destination.channelCount }), fr = new GainNode(e), Bi.connect(fr), fr.connect(e.destination);
}
const Oi = (e, t = [0, 1]) => {
  const n = xe();
  Bi == null && sd();
  const r = new StereoPannerNode(n);
  e.connect(r);
  const i = new ChannelSplitterNode(n, {
    numberOfOutputs: r.channelCount
  });
  r.connect(i), t.forEach((s, u) => {
    i.connect(Bi, u % r.channelCount, dr(s, 0, n.destination.channelCount - 1));
  });
}, mC = () => {
  fr != null && (fr.gain.linearRampToValueAtTime(0, xe().currentTime + 0.01), fr = null);
};
function gC(e, t, n, r) {
  if (n = dr(n, 0, 0.98), !wn[e]) {
    const s = xe().createFeedbackDelay(1, t, n);
    s.start?.(r), Oi(s, [0, 1]), wn[e] = s;
  }
  return wn[e].delayTime.value !== t && wn[e].delayTime.setValueAtTime(t, r), wn[e].feedback.value !== n && wn[e].feedback.setValueAtTime(n, r), wn[e];
}
function yC(e, t, n = 1, r = 0.5, i = 1e3, s = 2e3) {
  const u = xe(), a = u.createGain();
  a.gain.value = s * 2, Jt(u, "lfo-processor", {
    frequency: n,
    depth: 1,
    skew: 0,
    phaseoffset: 0,
    time: e,
    end: t,
    shape: 1,
    dcoffset: -0.5
  }).connect(a);
  const f = 2;
  let h = 0;
  const m = [];
  for (let p = 0; p < f; p++) {
    const b = u.createBiquadFilter();
    b.type = "notch", b.gain.value = 1, b.frequency.value = i + h, b.Q.value = 2 - Math.min(Math.max(r * 2, 0), 1.9), a.connect(b.detune), h += 282, p > 0 && m[p - 1].connect(b), m.push(b);
  }
  return m[m.length - 1];
}
function AC(e) {
  e = e ?? 0;
  const t = ["12db", "ladder", "24db"];
  return typeof e == "number" ? t[Math.floor(Rp(e, t.length))] : e;
}
let Ut = {}, gi = (e, t) => e !== void 0 && e !== t;
function bC(e, t, n, r, i, s) {
  if (!Ut[e]) {
    const a = xe().createReverb(t, n, r, i, s);
    Oi(a, [0, 1]), Ut[e] = a;
  }
  return (gi(t, Ut[e].duration) || gi(n, Ut[e].fade) || gi(r, Ut[e].lp) || gi(i, Ut[e].dim) || Ut[e].ir !== s) && Ut[e].generate(t, n, r, i, s), Ut[e];
}
let ft = {}, On = {};
function ud(e, t = 1024, n = 0.5) {
  if (!ft[e]) {
    const r = xe().createAnalyser();
    r.fftSize = t, r.smoothingTimeConstant = n, ft[e] = r, On[e] = new Float32Array(ft[e].frequencyBinCount);
  }
  return ft[e].fftSize !== t && (ft[e].fftSize = t, On[e] = new Float32Array(ft[e].frequencyBinCount)), ft[e];
}
function zi(e = "time", t = 1) {
  const n = {
    time: () => ft[t]?.getFloatTimeDomainData(On[t]),
    frequency: () => ft[t]?.getFloatFrequencyData(On[t])
  }[e];
  if (!n)
    throw new Error(`getAnalyzerData: ${e} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), On[t];
}
function Ps(e, t, n) {
  const r = pn(n);
  return e.connect(r), r.connect(t), r;
}
function MC() {
  wn = {}, Ut = {}, ft = {}, On = {};
}
let Nr = /* @__PURE__ */ new Map();
const ji = async (e, t, n) => {
  const r = xe();
  t = typeof t == "string" && t.startsWith("=") ? Number(t.slice(1)) : r.currentTime + t;
  let { stretch: i } = e;
  if (i != null && (t = t - 0.04), typeof e != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${e}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (e.duration = n, t < r.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${t.toFixed(2)}, now: ${r.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    s = He("s"),
    bank: u,
    source: a,
    gain: o = He("gain"),
    postgain: f = He("postgain"),
    density: h = He("density"),
    // filters
    fanchor: m = He("fanchor"),
    drive: p = 0.69,
    // low pass
    cutoff: b,
    lpenv: M,
    lpattack: v,
    lpdecay: E,
    lpsustain: I,
    lprelease: _,
    resonance: X = He("resonance"),
    // high pass
    hpenv: S,
    hcutoff: x,
    hpattack: B,
    hpdecay: k,
    hpsustain: V,
    hprelease: q,
    hresonance: G = He("hresonance"),
    // band pass
    bpenv: Y,
    bandf: W,
    bpattack: O,
    bpdecay: te,
    bpsustain: Ae,
    bprelease: pe,
    bandq: fe = He("bandq"),
    channels: Q = He("channels"),
    //phaser
    phaserrate: ke,
    phaserdepth: oe = He("phaserdepth"),
    phasersweep: ge,
    phasercenter: $,
    //
    coarse: ve,
    crush: st,
    shape: je,
    shapevol: be = He("shapevol"),
    distort: Ke,
    distortvol: Fe = He("distortvol"),
    pan: $e,
    vowel: vt,
    delay: ot = He("delay"),
    delayfeedback: Ie = He("delayfeedback"),
    delaytime: sn = He("delaytime"),
    orbit: Le = He("orbit"),
    room: $t,
    roomfade: Vt,
    roomlp: Nt,
    roomdim: un,
    roomsize: Rn,
    ir: qt,
    i: an = He("i"),
    velocity: Kt = He("velocity"),
    analyze: At,
    // analyser wet
    fft: Pn = He("fft"),
    // fftSize 0 - 10
    compressor: ye,
    compressorRatio: We,
    compressorKnee: ue,
    compressorAttack: Oe,
    compressorRelease: Be
  } = e;
  o = Xn(mn(o, 1)), f = Xn(f), be = Xn(be), Fe = Xn(Fe), ot = Xn(ot), Kt = Xn(Kt), o *= Kt;
  const Ln = Math.round(Math.random() * 1e6);
  for (let ce = 0; ce <= Nr.size - Up; ce++) {
    const ct = Nr.entries().next(), tt = ct.value[1], lt = ct.value[0], er = t + 0.25;
    tt?.node?.gain?.linearRampToValueAtTime(0, er), tt?.stop?.(er), Nr.delete(lt);
  }
  Q = (Array.isArray(Q) ? Q : [Q]).map((ce) => ce - 1);
  let Ht = [];
  u && s && (s = `${u}_${s}`, e.s = s);
  let ut;
  if (a)
    ut = a(t, e, n);
  else if (Mi(s)) {
    const { onTrigger: ce } = Mi(s), tt = await ce(t, e, () => {
      Ht.forEach((lt) => lt?.disconnect()), Nr.delete(Ln);
    });
    tt && (ut = tt.node, Nr.set(Ln, tt));
  } else
    throw new Error(`sound ${s} not found! Is it loaded?`);
  if (!ut)
    return;
  if (r.currentTime > t) {
    xt("[webaudio] skip hap: still loading", r.currentTime - t);
    return;
  }
  const Ve = [];
  Ve.push(ut), i !== void 0 && Ve.push(Jt(r, "phase-vocoder-processor", { pitchFactor: i })), Ve.push(pn(o));
  const bt = AC(e.ftype);
  if (b !== void 0) {
    let ce = () => bi(
      r,
      "lowpass",
      b,
      X,
      v,
      E,
      I,
      _,
      M,
      t,
      t + n,
      m,
      bt,
      p
    );
    Ve.push(ce()), bt === "24db" && Ve.push(ce());
  }
  if (x !== void 0) {
    let ce = () => bi(
      r,
      "highpass",
      x,
      G,
      B,
      k,
      V,
      q,
      S,
      t,
      t + n,
      m
    );
    Ve.push(ce()), bt === "24db" && Ve.push(ce());
  }
  if (W !== void 0) {
    let ce = () => bi(
      r,
      "bandpass",
      W,
      fe,
      O,
      te,
      Ae,
      pe,
      Y,
      t,
      t + n,
      m
    );
    Ve.push(ce()), bt === "24db" && Ve.push(ce());
  }
  if (vt !== void 0) {
    const ce = r.createVowelFilter(vt);
    Ve.push(ce);
  }
  if (ve !== void 0 && Ve.push(Jt(r, "coarse-processor", { coarse: ve })), st !== void 0 && Ve.push(Jt(r, "crush-processor", { crush: st })), je !== void 0 && Ve.push(Jt(r, "shape-processor", { shape: je, postgain: be })), Ke !== void 0 && Ve.push(Jt(r, "distort-processor", { distort: Ke, postgain: Fe })), ye !== void 0 && Ve.push(
    Lp(r, ye, We, ue, Oe, Be)
  ), $e !== void 0) {
    const ce = r.createStereoPanner();
    ce.pan.value = 2 * $e - 1, Ve.push(ce);
  }
  if (ke !== void 0 && oe > 0) {
    const ce = yC(t, t + n, ke, oe, $, ge);
    Ve.push(ce);
  }
  const _e = new GainNode(r, { gain: f });
  Ve.push(_e), Oi(_e, Q);
  let Gn;
  if (ot > 0 && sn > 0 && Ie > 0) {
    const ce = gC(Le, sn, Ie, t);
    Gn = Ps(_e, ce, ot), Ht.push(Gn);
  }
  let Qn;
  if ($t > 0) {
    let ce;
    if (qt !== void 0) {
      let tt, lt = Mi(qt);
      Array.isArray(lt) ? tt = lt.data.samples[an % lt.data.samples.length] : typeof lt == "object" && (tt = Object.values(lt.data.samples).flat()[an % Object.values(lt.data.samples).length]), ce = await Hu(tt, r, qt, 0);
    }
    const ct = bC(Le, Rn, Vt, Nt, un, ce);
    Qn = Ps(_e, ct, $t), Ht.push(Qn);
  }
  let Ne;
  if (At) {
    const ce = ud(At, 2 ** (Pn + 5));
    Ne = Ps(_e, ce, 1), Ht.push(Ne);
  }
  Ve.slice(1).reduce((ce, ct) => ce.connect(ct), Ve[0]), Ht = Ht.concat(Ve);
}, CC = (e, t, n, r) => {
  ji(t, e - n, t.duration / r);
};
let Ds = {};
function vC(e, t) {
  const n = xe();
  if (Ds[e])
    return Ds[e];
  const r = 2 * n.sampleRate, i = n.createBuffer(1, r, n.sampleRate), s = i.getChannelData(0);
  let u = 0, a, o, f, h, m, p, b;
  a = o = f = h = m = p = b = 0;
  for (let M = 0; M < r; M++)
    if (e === "white")
      s[M] = Math.random() * 2 - 1;
    else if (e === "brown") {
      let v = Math.random() * 2 - 1;
      s[M] = (u + 0.02 * v) / 1.02, u = s[M];
    } else if (e === "pink") {
      let v = Math.random() * 2 - 1;
      a = 0.99886 * a + v * 0.0555179, o = 0.99332 * o + v * 0.0750759, f = 0.969 * f + v * 0.153852, h = 0.8665 * h + v * 0.3104856, m = 0.55 * m + v * 0.5329522, p = -0.7616 * p - v * 0.016898, s[M] = a + o + f + h + m + p + b + v * 0.5362, s[M] *= 0.11, b = v * 0.115926;
    } else if (e === "crackle") {
      const v = t * 0.01;
      Math.random() < v ? s[M] = Math.random() * 2 - 1 : s[M] = 0;
    }
  return e !== "crackle" && (Ds[e] = i), i;
}
function ad(e = "white", t, n = 0.02) {
  const i = xe().createBufferSource();
  return i.buffer = vC(e, n), i.loop = !0, i.start(t), {
    node: i,
    stop: (s) => i.stop(s)
  };
}
function PC(e, t, n) {
  const r = ad("pink", n);
  return {
    node: Gp(e, r.node, t),
    stop: (s) => r?.stop(s)
  };
}
const au = (e) => {
  let { note: t, freq: n } = e;
  return t = t || 36, typeof t == "string" && (t = Wi(t)), !n && typeof t == "number" && (n = Tp(t)), Number(n);
};
function io(e) {
  e.disconnect(), e.parameters.get("end")?.setValueAtTime(0, 0);
}
const DC = ["triangle", "square", "sawtooth", "sine"], FC = ["pink", "white", "brown", "crackle"];
function od() {
  [...DC].forEach((e) => {
    Wn(
      e,
      (t, n, r) => {
        const [i, s, u, a] = yn(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let o = ld(e, t, n), { node: f, stop: h, triggerRelease: m } = o;
        const p = pn(0.3), { duration: b } = n;
        f.onended = () => {
          f.disconnect(), p.disconnect(), r();
        };
        const M = pn(1);
        let v = f.connect(p).connect(M);
        const E = t + b;
        gn(v.gain, i, s, u, a, 0, 1, t, E, "linear");
        const I = E + a + 0.01;
        return m?.(I), h(I), {
          node: v,
          stop: (_) => {
            h(_);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), Wn(
    "supersaw",
    (e, t, n) => {
      const r = xe();
      let { duration: i, n: s, unison: u = 5, spread: a = 0.6, detune: o } = t;
      o = o ?? s ?? 0.18;
      const f = au(t), [h, m, p, b] = yn(
        [t.attack, t.decay, t.sustain, t.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), M = e + i, v = M + b + 0.01, E = dr(u, 1, 100);
      let I = E > 1 ? dr(a, 0, 1) : 0, _ = Jt(
        r,
        "supersaw-oscillator",
        {
          frequency: f,
          begin: e,
          end: v,
          freqspread: o,
          voices: E,
          panspread: I
        },
        {
          outputChannelCount: [2]
        }
      );
      const X = 1 / Math.sqrt(E);
      Ur(_.parameters.get("detune"), t, e, M);
      const S = Jr(_.parameters.get("detune"), t, e), x = wi(_.parameters.get("frequency"), t, e);
      let B = pn(1);
      B = _.connect(B), gn(B.gain, h, m, p, b, 0, 0.3 * X, e, M, "linear");
      let k = iu(
        r,
        () => {
          io(_), B.disconnect(), n(), x?.stop(), S?.stop();
        },
        e,
        v
      );
      return {
        node: B,
        stop: (V) => {
          k.stop(V);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), Wn(
    "pulse",
    (e, t, n) => {
      const r = xe();
      let { duration: i, n: s = 0.5 } = t;
      const u = au(t), [a, o, f, h] = yn(
        [t.attack, t.decay, t.sustain, t.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), m = e + i, p = m + h + 0.01;
      let b = Jt(
        r,
        "pulse-oscillator",
        {
          frequency: u,
          begin: e,
          end: p,
          pulsewidth: s
        },
        {
          outputChannelCount: [2]
        }
      );
      Ur(b.parameters.get("detune"), t, e, m);
      const M = Jr(b.parameters.get("detune"), t, e), v = wi(b.parameters.get("frequency"), t, e);
      let E = pn(1);
      E = b.connect(E), gn(E.gain, a, o, f, h, 0, 1, e, m, "linear");
      let I = iu(
        r,
        () => {
          io(b), E.disconnect(), n(), v?.stop(), M?.stop();
        },
        e,
        p
      );
      return {
        node: E,
        stop: (_) => {
          I.stop(_);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...FC].forEach((e) => {
    Wn(
      e,
      (t, n, r) => {
        const [i, s, u, a] = yn(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let o, { density: f } = n;
        o = ad(e, t, f);
        let { node: h, stop: m, triggerRelease: p } = o;
        const b = pn(0.3), { duration: M } = n;
        h.onended = () => {
          h.disconnect(), b.disconnect(), r();
        };
        const v = pn(1);
        let E = h.connect(b).connect(v);
        const I = t + M;
        gn(E.gain, i, s, u, a, 0, 1, t, I, "linear");
        const _ = I + a + 0.01;
        return p?.(_), m(_), {
          node: E,
          stop: (X) => {
            m(X);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
function cd(e, t) {
  const n = new Float32Array(e + 1), r = new Float32Array(e + 1), i = xe(), s = i.createOscillator(), u = {
    sawtooth: (f) => [0, -1 / f],
    square: (f) => [0, f % 2 === 0 ? 0 : 1 / f],
    triangle: (f) => [f % 2 === 0 ? 0 : 1 / (f * f), 0]
  };
  if (!u[t])
    throw new Error(`unknown wave type ${t}`);
  n[0] = 0, r[0] = 0;
  let a = 1;
  for (; a <= e; ) {
    const [f, h] = u[t](a);
    n[a] = f, r[a] = h, a++;
  }
  const o = i.createPeriodicWave(n, r);
  return s.setPeriodicWave(o), s;
}
function ld(e, t, n) {
  let { n: r, duration: i, noise: s = 0 } = n, u;
  !r || e === "sine" ? (u = xe().createOscillator(), u.type = e || "triangle") : u = cd(r, e), u.frequency.value = au(n), u.start(t);
  let a = Jr(u.detune, n, t);
  Ur(u.detune, n, t, t + i);
  const o = wi(u.frequency, n, t);
  let f;
  return s && (f = PC(u, s, t)), {
    node: f?.node || u,
    stop: (h) => {
      o.stop(h), a?.stop(h), f?.stop(h), u.stop(h);
    },
    triggerRelease: (h) => {
    }
  };
}
function EC(e = 1, t = 0.05, n = 220, r = 0, i = 0, s = 0.1, u = 0, a = 1, o = 0, f = 0, h = 0, m = 0, p = 0, b = 0, M = 0, v = 0, E = 0, I = 1, _ = 0, X = 0) {
  let S = Math.PI * 2, x = xe().sampleRate, B = (ke) => ke > 0 ? 1 : -1, k = o *= 500 * S / x / x, V = n *= (1 + t * 2 * Math.random() - t) * S / x, q = [], G = 0, Y = 0, W = 0, O = 1, te = 0, Ae = 0, pe = 0, fe, Q;
  for (r = r * x + 9, _ *= x, i *= x, s *= x, E *= x, f *= 500 * S / x ** 3, M *= S / x, h *= S / x, m *= x, p = p * x | 0, Q = r + _ + i + s + E | 0; W < Q; q[W++] = pe)
    ++Ae % (v * 100 | 0) || (pe = u ? u > 1 ? u > 2 ? u > 3 ? Math.sin((G % S) ** 3) : Math.max(Math.min(Math.tan(G), 1), -1) : 1 - (2 * G / S % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(G / S) - G / S) : Math.sin(G), pe = (p ? 1 - X + X * Math.sin(S * W / p) : 1) * B(pe) * Math.abs(pe) ** a * // curve 0=square, 2=pointy
    e * 1 * // envelope
    (W < r ? W / r : W < r + _ ? 1 - (W - r) / _ * (1 - I) : W < r + _ + i ? I : W < Q - E ? (Q - W - E) / s * // release falloff
    I : 0), pe = E ? pe / 2 + (E > W ? 0 : (W < Q - E ? 1 : (Q - W) / E) * // release delay
    q[W - E | 0] / 2) : pe), fe = (n += o += f) * // frequency
    Math.cos(M * Y++), G += fe - fe * b * (1 - (Math.sin(W) + 1) * 1e9 % 2), O && ++O > m && (n += h, V += h, O = 0), p && !(++te % p) && (n = V, o = k, O ||= 1);
  return q;
}
const fd = (e, t) => {
  let {
    s: n,
    note: r = 36,
    freq: i,
    //
    zrand: s = 0,
    attack: u = 0,
    decay: a = 0,
    sustain: o = 0.8,
    release: f = 0.1,
    curve: h = 1,
    slide: m = 0,
    deltaSlide: p = 0,
    pitchJump: b = 0,
    pitchJumpTime: M = 0,
    lfo: v = 0,
    znoise: E = 0,
    zmod: I = 0,
    zcrush: _ = 0,
    zdelay: X = 0,
    tremolo: S = 0,
    duration: x = 0.2,
    zzfx: B
  } = e;
  const k = Math.max(x - u - a, 0);
  typeof r == "string" && (r = Wi(r)), !i && typeof r == "number" && (i = Tp(r)), n = n.replace("z_", "");
  const V = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  h = n === "square" ? 0 : h;
  const G = (
    /* ZZFX. */
    EC(...B || [
      0.25,
      // volume
      s,
      i,
      u,
      k,
      f,
      V,
      h,
      m,
      p,
      b,
      M,
      v,
      E,
      I,
      _,
      X,
      o,
      // sustain volume!
      a,
      S
    ])
  ), Y = xe(), W = Y.createBuffer(1, G.length, Y.sampleRate);
  W.getChannelData(0).set(G);
  const O = xe().createBufferSource();
  return O.buffer = W, O.start(t), {
    node: O
  };
};
function xC() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((e) => {
    Wn(
      e,
      (t, n, r) => {
        const { node: i } = fd({ s: e, ...n }, t);
        return i.onended = () => {
          i.disconnect(), r();
        }, {
          node: i,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let hr;
async function hd(e, t) {
  const n = `dsp-worklet-${Date.now()}`, r = `${t}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, s = `data:text/javascript;base64,${btoa(r)}`;
  await e.audioWorklet.addModule(s);
  const u = new AudioWorkletNode(e, n);
  return { node: u, stop: () => u.port.postMessage("stop") };
}
const pd = () => {
  hr && (hr?.stop(), hr?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (e) => {
  e.data === "strudel-stop" ? pd() : e.data?.dough && hr?.node.port.postMessage(e.data);
});
const wC = async (e) => {
  const t = xe();
  pd(), hr = await hd(t, e), hr.node.connect(t.destination);
};
function dd(e, t, n, r, i) {
  window.postMessage({ time: i, dough: t.value, currentTime: n, duration: t.duration, cps: r });
}
const { Pattern: md, logger: SC, repl: BC } = Ip;
Np(SC);
const gd = (e) => (e.ensureObjectValue(), e.value), yd = (e, t, n, r) => ji(gd(t), e - n, t.duration / r), Ad = (e, t, n, r, i) => ji(gd(e), i ? `=${i}` : t, n);
md.prototype.webaudio = function() {
  return this.onTrigger(yd);
};
function bd(e = {}) {
  return e = {
    getTime: () => xe().currentTime,
    defaultOutput: Ad,
    ...e
  }, BC(e);
}
md.prototype.dough = function() {
  return this.onTrigger(dd, 1);
};
const Jn = (e = "test-canvas", t) => {
  let { contextType: n = "2d", pixelated: r = !1, pixelRatio: i = window.devicePixelRatio } = {}, s = document.querySelector("#" + e);
  if (!s) {
    s = document.createElement("canvas"), s.id = e, s.width = window.innerWidth * i, s.height = window.innerHeight * i, s.style = "pointer-events:none;width:100%;height:100%;position:fixed;top:0;left:0", r && (s.style.imageRendering = "pixelated"), document.body.prepend(s);
    let u;
    window.addEventListener("resize", () => {
      u && clearTimeout(u), u = setTimeout(() => {
        s.width = window.innerWidth * i, s.height = window.innerHeight * i;
      }, 200);
    });
  }
  return s.getContext(n, { willReadFrequently: !0 });
};
let jr = {};
function _C(e) {
  jr[e] !== void 0 && (cancelAnimationFrame(jr[e]), delete jr[e]);
}
let hn = {};
z.prototype.draw = function(e, t) {
  if (typeof window > "u")
    return this;
  let { id: n = 1, lookbehind: r = 0, lookahead: i = 0 } = t, s = Math.max(ru(), 0);
  _C(n), r = Math.abs(r), hn[n] = (hn[n] || []).filter((f) => !f.isInFuture(s));
  let u = this.queryArc(s, s + i).filter((f) => f.hasOnset());
  hn[n] = hn[n].concat(u);
  let a;
  const o = () => {
    const f = ru(), h = f + i;
    hn[n] = hn[n].filter((b) => b.isInNearPast(r, f));
    let m = Math.max(a || h, h - 1 / 10);
    const p = this.queryArc(m, h).filter((b) => b.hasOnset());
    hn[n] = hn[n].concat(p), a = h, e(hn[n], f, h, this), jr[n] = requestAnimationFrame(o);
  };
  return jr[n] = requestAnimationFrame(o), this;
};
z.prototype.onPaint = function(e) {
  return this.withState((t) => {
    t.controls.painters || (t.controls.painters = []), t.controls.painters.push(e);
  });
};
z.prototype.getPainters = function() {
  let e = [];
  return this.queryArc(0, 0, { painters: e }), e;
};
let kC = {
  background: "#222",
  foreground: "#75baff",
  caret: "#ffcc00",
  selection: "rgba(128, 203, 196, 0.5)",
  selectionMatch: "#036dd626",
  lineHighlight: "#00000050",
  gutterBackground: "transparent",
  gutterForeground: "#8a919966"
};
function An() {
  return kC;
}
let so = "#22222210";
z.prototype.animate = function({ callback: e, sync: t = !1, smear: n = 0.5 } = {}) {
  window.frame && cancelAnimationFrame(window.frame);
  const r = Jn();
  let { clientWidth: i, clientHeight: s } = r.canvas;
  i *= window.devicePixelRatio, s *= window.devicePixelRatio;
  let u = n === 0 ? "99" : Number((1 - n) * 100).toFixed(0);
  u = u.length === 1 ? `0${u}` : u, so = `#200010${u}`;
  const a = (o) => {
    let f;
    o = Math.round(o), f = this.slow(1e3).queryArc(o, o), r.fillStyle = so, r.fillRect(0, 0, i, s), f.forEach((h) => {
      let { x: m, y: p, w: b, h: M, s: v, r: E, angle: I = 0, fill: _ = "darkseagreen" } = h.value;
      if (b *= i, M *= s, E !== void 0 && I !== void 0) {
        const S = I * 2 * Math.PI, [x, B] = [(i - b) / 2, (s - M) / 2];
        m = x + Math.cos(S) * E * x, p = B + Math.sin(S) * E * B;
      } else
        m *= i - b, p *= s - M;
      const X = { ...h.value, x: m, y: p, w: b, h: M };
      r.fillStyle = _, v === "rect" ? r.fillRect(m, p, b, M) : v === "ellipse" && (r.beginPath(), r.ellipse(m + b / 2, p + M / 2, b / 2, M / 2, 0, 0, 2 * Math.PI), r.fill()), e && e(r, X, h);
    }), window.frame = requestAnimationFrame(a);
  };
  return window.frame = requestAnimationFrame(a), Se;
};
const { x: Md, y: mF, w: gF, h: yF, angle: AF, r: bF, fill: MF, smear: CF } = Vu("x", "y", "w", "h", "angle", "r", "fill", "smear");
T("rescale", function(e, t) {
  return t.mul(Md(e).w(e).y(e).h(e));
});
T("moveXY", function(e, t, n) {
  return n.add(Md(e).y(t));
});
T("zoomIn", function(e, t) {
  const n = Ye(1).sub(e).div(2);
  return t.rescale(e).move(n, n);
});
const Tr = (e, t, n) => e * (n - t) + t, uo = (e) => {
  let { value: t } = e;
  typeof e.value != "object" && (t = { value: t });
  let { note: n, n: r, freq: i, s } = t;
  if (i)
    return Cu(i);
  if (n = n ?? r, typeof n == "string")
    try {
      return In(n);
    } catch {
      return 0;
    }
  return typeof n == "number" ? n : s ? "_" + s : t;
};
z.prototype.pianoroll = function(e = {}) {
  let { cycles: t = 4, playhead: n = 0.5, overscan: r = 0, hideNegative: i = !1, ctx: s = Jn(), id: u = 1 } = e, a = -t * n, o = t * (1 - n);
  const f = (h, m) => (!i || h.whole.begin >= 0) && h.isWithinTime(m + a, m + o);
  return this.draw(
    (h, m) => {
      Cd({
        ...e,
        time: m,
        ctx: s,
        haps: h.filter((p) => f(p, m))
      });
    },
    {
      lookbehind: a - r,
      lookahead: o + r,
      id: u
    }
  ), this;
};
function Cd({
  time: e,
  haps: t,
  cycles: n = 4,
  playhead: r = 0.5,
  flipTime: i = 0,
  flipValues: s = 0,
  hideNegative: u = !1,
  inactive: a = An().foreground,
  active: o = An().foreground,
  background: f = "transparent",
  smear: h = 0,
  playheadColor: m = An().foreground,
  minMidi: p = 10,
  maxMidi: b = 90,
  autorange: M = 0,
  timeframe: v,
  fold: E = 1,
  vertical: I = 0,
  labels: _ = !1,
  fill: X = 1,
  fillActive: S = !1,
  strokeActive: x = !0,
  stroke: B,
  hideInactive: k = 0,
  colorizeInactive: V = 1,
  fontFamily: q,
  ctx: G,
  id: Y
} = {}) {
  const W = G.canvas.width, O = G.canvas.height;
  let te = -n * r, Ae = n * (1 - r);
  Y && (t = t.filter((Fe) => Fe.hasTag(Y))), v && (console.warn("timeframe is deprecated! use from/to instead"), te = 0, Ae = v);
  const pe = I ? O : W, fe = I ? W : O;
  let Q = I ? [pe, 0] : [0, pe];
  const ke = Ae - te, oe = I ? [0, fe] : [fe, 0];
  let ge = b - p + 1, $ = fe / ge, ve = [];
  i && Q.reverse(), s && oe.reverse();
  const { min: st, max: je, values: be } = t.reduce(
    ({ min: Fe, max: $e, values: vt }, ot) => {
      const Ie = uo(ot);
      return {
        min: Ie < Fe ? Ie : Fe,
        max: Ie > $e ? Ie : $e,
        values: vt.includes(Ie) ? vt : [...vt, Ie]
      };
    },
    { min: 1 / 0, max: -1 / 0, values: [] }
  );
  M && (p = st, b = je, ge = b - p + 1), ve = be.sort(
    (Fe, $e) => typeof Fe == "number" && typeof $e == "number" ? Fe - $e : typeof Fe == "number" ? 1 : String(Fe).localeCompare(String($e))
  ), $ = E ? fe / ve.length : fe / ge, G.fillStyle = f, G.globalAlpha = 1, h || (G.clearRect(0, 0, W, O), G.fillRect(0, 0, W, O)), t.forEach((Fe) => {
    const $e = Fe.whole.begin <= e && Fe.endClipped > e;
    let vt = B ?? (x && $e), ot = !$e && X || $e && S;
    if (k && !$e)
      return;
    let Ie = Fe.value?.color;
    o = Ie || o, a = V && Ie || a, Ie = $e ? o : a, G.fillStyle = ot ? Ie : "transparent", G.strokeStyle = Ie;
    const { velocity: sn = 1, gain: Le = 1 } = Fe.value || {};
    G.globalAlpha = sn * Le;
    const $t = (Fe.whole.begin - (i ? Ae : te)) / ke, Vt = Tr($t, ...Q);
    let Nt = Tr(Fe.duration / ke, 0, pe);
    const un = uo(Fe), Rn = E ? ve.indexOf(un) / ve.length : (Number(un) - p) / ge, qt = Tr(Rn, ...oe);
    let an = 0;
    const Kt = Tr(e / ke, ...Q);
    let At;
    if (I ? At = [
      qt + 1 - (s ? $ : 0),
      // x
      pe - Kt + Vt + an + 1 - (i ? 0 : Nt),
      // y
      $ - 2,
      // width
      Nt - 2
      // height
    ] : At = [
      Vt - Kt + an + 1 - (i ? Nt : 0),
      // x
      qt + 1 - (s ? 0 : $),
      // y
      Nt - 2,
      // widith
      $ - 2
      // height
    ], vt && G.strokeRect(...At), ot && G.fillRect(...At), _) {
      const Pn = Fe.value.note ?? Fe.value.s + (Fe.value.n ? `:${Fe.value.n}` : ""), { label: ye, activeLabel: We } = Fe.value, Oe = ($e && We || ye) ?? Pn;
      let Be = I ? Nt : $ * 0.75;
      G.font = `${Be}px ${q || "monospace"}`, G.fillStyle = /* isActive &&  */
      ot ? "black" : Ie, G.textBaseline = "top", G.fillText(Oe, ...At);
    }
  }), G.globalAlpha = 1;
  const Ke = Tr(-te / ke, ...Q);
  return G.strokeStyle = m, G.beginPath(), I ? (G.moveTo(0, Ke), G.lineTo(fe, Ke)) : (G.moveTo(Ke, 0), G.lineTo(Ke, fe)), G.stroke(), this;
}
function IC(e, t = {}) {
  let [n, r] = e;
  n = Math.abs(n);
  const i = r + n, s = i !== 0 ? n / i : 0;
  return { fold: 1, ...t, cycles: i, playhead: s };
}
const VC = (e = {}) => (t, n, r, i) => Cd({ ctx: t, time: n, haps: r, ...IC(i, e) });
z.prototype.punchcard = function(e) {
  return this.onPaint(VC(e));
};
z.prototype.wordfall = function(e) {
  return this.punchcard({ vertical: 1, labels: 1, stroke: 0, fillActive: 1, active: "white", ...e });
};
function NC(e, t, n, r) {
  const i = (e - 90) * Math.PI / 180;
  return [n + Math.cos(i) * t, r + Math.sin(i) * t];
}
const ao = (e, t, n, r, i = 0) => NC((e + i) * 360, t * e, n, r);
function oo(e) {
  let {
    ctx: t,
    from: n = 0,
    to: r = 3,
    margin: i = 50,
    cx: s = 100,
    cy: u = 100,
    rotate: a = 0,
    thickness: o = i / 2,
    color: f = An().foreground,
    cap: h = "round",
    stretch: m = 1,
    fromOpacity: p = 1,
    toOpacity: b = 1
  } = e;
  n *= m, r *= m, a *= m, t.lineWidth = o, t.lineCap = h, t.strokeStyle = f, t.globalAlpha = p, t.beginPath();
  let [M, v] = ao(n, i, s, u, a);
  t.moveTo(M, v);
  const E = 1 / 60;
  let I = n;
  for (; I <= r; ) {
    const [_, X] = ao(I, i, s, u, a);
    t.globalAlpha = (I - n) / (r - n) * b, t.lineTo(_, X), I += E;
  }
  t.stroke();
}
function TC(e) {
  let {
    stretch: t = 1,
    size: n = 80,
    thickness: r = n / 2,
    cap: i = "butt",
    // round butt squar,
    inset: s = 3,
    // start angl,
    playheadColor: u = "#ffffff",
    playheadLength: a = 0.02,
    playheadThickness: o = r,
    padding: f = 0,
    steady: h = 1,
    activeColor: m = An().foreground,
    inactiveColor: p = An().gutterForeground,
    colorizeInactive: b = 0,
    fade: M = !0,
    // logSpiral = true,
    ctx: v,
    time: E,
    haps: I,
    drawTime: _,
    id: X
  } = e;
  X && (I = I.filter((W) => W.hasTag(X)));
  const [S, x] = [v.canvas.width, v.canvas.height];
  v.clearRect(0, 0, S * 2, x * 2);
  const [B, k] = [S / 2, x / 2], V = {
    margin: n / t,
    cx: B,
    cy: k,
    stretch: t,
    cap: i,
    thickness: r
  }, q = {
    ...V,
    thickness: o,
    from: s - a,
    to: s,
    color: u
  }, [G] = _, Y = h * E;
  I.forEach((W) => {
    const O = W.whole.begin <= E && W.endClipped > E, te = W.whole.begin - E + s, Ae = W.endClipped - E + s - f, pe = W.value?.color || m, fe = b || O ? pe : p, Q = M ? 1 - Math.abs((W.whole.begin - E) / G) : 1;
    oo({
      ctx: v,
      ...V,
      from: te,
      to: Ae,
      rotate: Y,
      color: fe,
      fromOpacity: Q,
      toOpacity: Q
    });
  }), oo({
    ctx: v,
    ...q,
    rotate: Y
  });
}
z.prototype.spiral = function(e = {}) {
  return this.onPaint((t, n, r, i) => TC({ ctx: t, time: n, haps: r, drawTime: i, ...e }));
};
const RC = qn(36), co = (e, t, n, r) => {
  r = r * Math.PI * 2;
  const i = Math.sin(r) * n + e, s = Math.cos(r) * n + t;
  return [i, s];
}, lo = (e, t) => 0.5 - Math.log2(e / t) % 1;
function LC({
  haps: e,
  ctx: t,
  id: n,
  hapcircles: r = 1,
  circle: i = 0,
  edo: s = 12,
  root: u = RC,
  thickness: a = 3,
  hapRadius: o = 6,
  mode: f = "flake",
  margin: h = 10
} = {}) {
  const m = f === "polygon", p = f === "flake", b = t.canvas.width, M = t.canvas.height;
  t.clearRect(0, 0, b, M);
  const v = An().foreground, I = Math.min(b, M) / 2 - a / 2 - o - h, _ = b / 2, X = M / 2;
  n && (e = e.filter((x) => x.hasTag(n))), t.strokeStyle = v, t.fillStyle = v, t.globalAlpha = 1, t.lineWidth = a, i && (t.beginPath(), t.arc(_, X, I, 0, 2 * Math.PI), t.stroke()), s && (Array.from({ length: s }, (x, B) => {
    const k = lo(u * Math.pow(2, B / s), u), [V, q] = co(_, X, I, k);
    t.beginPath(), t.arc(V, q, o, 0, 2 * Math.PI), t.fill();
  }), t.stroke());
  let S = [];
  t.lineWidth = o, e.forEach((x) => {
    let B;
    try {
      B = pc(x);
    } catch {
      return;
    }
    const k = lo(B, u), [V, q] = co(_, X, I, k), G = x.value.color || v;
    t.strokeStyle = G, t.fillStyle = G;
    const { velocity: Y = 1, gain: W = 1 } = x.value || {}, O = Y * W;
    t.globalAlpha = O, S.push([V, q, k, G, O]), t.beginPath(), r && (t.moveTo(V + o, q), t.arc(V, q, o, 0, 2 * Math.PI), t.fill()), p && (t.moveTo(_, X), t.lineTo(V, q)), t.stroke();
  }), t.strokeStyle = v, t.globalAlpha = 1, m && S.length && (S = S.sort((x, B) => x[2] - B[2]), t.beginPath(), t.moveTo(S[0][0], S[0][1]), S.forEach(([x, B, k, V, q]) => {
    t.strokeStyle = V, t.globalAlpha = q, t.lineTo(x, B);
  }), t.lineTo(S[0][0], S[0][1]), t.stroke());
}
z.prototype.pitchwheel = function(e = {}) {
  let { ctx: t = Jn(), id: n = 1 } = e;
  return this.tag(n).onPaint(
    (r, i, s) => LC({
      ...e,
      time: i,
      ctx: t,
      haps: s.filter((u) => u.isActive(i)),
      id: n
    })
  );
};
function vd(e, {
  align: t = !0,
  color: n = "white",
  thickness: r = 3,
  scale: i = 0.25,
  pos: s = 0.75,
  trigger: u = 0,
  ctx: a = Jn(),
  id: o = 1
} = {}) {
  a.lineWidth = r, a.strokeStyle = n;
  let f = a.canvas;
  if (!e) {
    a.beginPath();
    let v = s * f.height;
    a.moveTo(0, v), a.lineTo(f.width, v), a.stroke();
    return;
  }
  const h = zi("time", o);
  a.beginPath();
  const m = e.frequencyBinCount;
  let p = t ? Array.from(h).findIndex((v, E, I) => E && I[E - 1] > -u && v <= -u) : 0;
  p = Math.max(p, 0);
  const b = f.width * 1 / m;
  let M = 0;
  for (let v = p; v < m; v++) {
    const E = h[v] + 1, I = (s - i * (E - 1)) * f.height;
    v === 0 ? a.moveTo(M, I) : a.lineTo(M, I), M += b;
  }
  a.stroke();
}
function Pd(e, { color: t = "white", scale: n = 0.25, pos: r = 0.75, lean: i = 0.5, min: s = -150, max: u = 0, ctx: a = Jn(), id: o = 1 } = {}) {
  if (!e) {
    a.beginPath();
    let M = r * h.height;
    a.moveTo(0, M), a.lineTo(h.width, M), a.stroke();
    return;
  }
  const f = zi("frequency", o), h = a.canvas;
  a.fillStyle = t;
  const m = e.frequencyBinCount, p = h.width * 1 / m;
  let b = 0;
  for (let M = 0; M < m; M++) {
    const E = Ri((f[M] - s) / (u - s), 0, 1) * n, I = E * h.height, _ = (r - E * i) * h.height;
    a.fillRect(b, _, Math.max(p, 1), I), b += p;
  }
}
function Dd(e = 0, t = "0,0,0", n = Jn()) {
  e ? (n.fillStyle = `rgba(${t},${1 - e})`, n.fillRect(0, 0, n.canvas.width, n.canvas.height)) : n.clearRect(0, 0, n.canvas.width, n.canvas.height);
}
z.prototype.fscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    () => {
      Dd(e.smear, "0,0,0", e.ctx), ft[t] && Pd(ft[t], e);
    },
    { id: t }
  );
};
z.prototype.tscope = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (n) => {
      e.color = n[0]?.value?.color || An().foreground, e.color, Dd(e.smear, "0,0,0", e.ctx), vd(ft[t], e);
    },
    { id: t }
  );
};
z.prototype.scope = z.prototype.tscope;
let fo = {};
z.prototype.spectrum = function(e = {}) {
  let t = e.id ?? 1;
  return this.analyze(t).draw(
    (n) => {
      e.color = n[0]?.value?.color || fo[t] || An().foreground, fo[t] = e.color, GC(ft[t], e);
    },
    { id: t }
  );
};
z.prototype.scope = z.prototype.tscope;
const Fs = /* @__PURE__ */ new Map();
function GC(e, { thickness: t = 3, speed: n = 1, min: r = -80, max: i = 0, ctx: s = Jn(), id: u = 1, color: a } = {}) {
  if (s.lineWidth = t, s.strokeStyle = a, !e)
    return;
  const o = n, f = zi("frequency", u), h = s.canvas;
  s.fillStyle = a;
  const m = e.frequencyBinCount;
  let p = Fs.get(u) || s.getImageData(0, 0, h.width, h.height);
  Fs.set(u, p), s.clearRect(0, 0, s.canvas.width, s.canvas.height), s.putImageData(p, -o, 0);
  let b = h.width - n;
  for (let M = 0; M < m; M++) {
    const v = Ri((f[M] - r) / (i - r), 0, 1);
    s.globalAlpha = v;
    const E = Math.log(M + 1) / Math.log(m) * h.height;
    s.fillRect(b, h.height - E, o, 2);
  }
  Fs.set(u, s.getImageData(0, 0, h.width, h.height));
}
const XC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_MAX_POLYPHONY: Uu,
  aliasBank: cC,
  get analysers() {
    return ft;
  },
  get analysersData() {
    return On;
  },
  applyFM: wi,
  applyGainCurve: Xn,
  connectToDestination: Oi,
  createFilter: bi,
  dough: wC,
  doughTrigger: dd,
  drawFrequencyScope: Pd,
  drawTimeScope: vd,
  drywet: Gp,
  dspWorklet: hd,
  gainNode: pn,
  getADSRValues: yn,
  getAnalyserById: ud,
  getAnalyzerData: zi,
  getAudioContext: xe,
  getAudioContextCurrentTime: pC,
  getAudioDevices: Qp,
  getCachedBuffer: nC,
  getCompressor: Lp,
  getDefaultValue: He,
  getLoadedBuffer: iC,
  getOscillator: ld,
  getParamADSR: gn,
  getPitchEnvelope: Ur,
  getSampleBuffer: Zp,
  getSampleBufferSource: Wp,
  getSampleInfo: Xp,
  getSound: Mi,
  getVibratoOscillator: Jr,
  getWorklet: Jt,
  getZZFX: fd,
  initAudio: rd,
  initAudioOnFirstClick: id,
  initializeAudioOutput: sd,
  loadBuffer: Hu,
  logger: xt,
  onTriggerSample: Hp,
  panic: mC,
  processSampleMap: $p,
  registerSamplesPrefix: sC,
  registerSound: Wn,
  registerSynthSounds: od,
  registerZZFXSounds: xC,
  resetDefaultValues: td,
  resetGlobalEffects: MC,
  resetLoadedSounds: hC,
  reverseBuffer: Op,
  samples: Kp,
  setDefaultAudioContext: nd,
  setDefaultValue: Yu,
  setDefaultValues: lC,
  setGainCurve: aC,
  setLogger: Np,
  setMaxPolyphony: Jp,
  setVersionDefaults: fC,
  soundMap: mr,
  superdough: ji,
  superdoughTrigger: CC,
  waveformN: cd,
  webAudioTimeout: iu,
  webaudioOutput: Ad,
  webaudioOutputTrigger: yd,
  webaudioRepl: bd
}, Symbol.toStringTag, { value: "Module" }));
function ZC(e, t) {
  function n() {
    this.constructor = e;
  }
  n.prototype = t.prototype, e.prototype = new n();
}
function Kn(e, t, n, r) {
  var i = Error.call(this, e);
  return Object.setPrototypeOf && Object.setPrototypeOf(i, Kn.prototype), i.expected = t, i.found = n, i.location = r, i.name = "SyntaxError", i;
}
ZC(Kn, Error);
function Es(e, t, n) {
  return n = n || " ", e.length > t ? e : (t -= e.length, n += n.repeat(t), e + n.slice(0, t));
}
Kn.prototype.format = function(e) {
  var t = "Error: " + this.message;
  if (this.location) {
    var n = null, r;
    for (r = 0; r < e.length; r++)
      if (e[r].source === this.location.source) {
        n = e[r].text.split(/\r\n|\n|\r/g);
        break;
      }
    var i = this.location.start, s = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i, u = this.location.source + ":" + s.line + ":" + s.column;
    if (n) {
      var a = this.location.end, o = Es("", s.line.toString().length, " "), f = n[i.line - 1], h = i.line === a.line ? a.column : f.length + 1, m = h - i.column || 1;
      t += `
 --> ` + u + `
` + o + ` |
` + s.line + " | " + f + `
` + o + " | " + Es("", i.column - 1, " ") + Es("", m, "^");
    } else
      t += `
 at ` + u;
  }
  return t;
};
Kn.buildMessage = function(e, t) {
  var n = {
    literal: function(f) {
      return '"' + i(f.text) + '"';
    },
    class: function(f) {
      var h = f.parts.map(function(m) {
        return Array.isArray(m) ? s(m[0]) + "-" + s(m[1]) : s(m);
      });
      return "[" + (f.inverted ? "^" : "") + h.join("") + "]";
    },
    any: function() {
      return "any character";
    },
    end: function() {
      return "end of input";
    },
    other: function(f) {
      return f.description;
    }
  };
  function r(f) {
    return f.charCodeAt(0).toString(16).toUpperCase();
  }
  function i(f) {
    return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
      return "\\x0" + r(h);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
      return "\\x" + r(h);
    });
  }
  function s(f) {
    return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(h) {
      return "\\x0" + r(h);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(h) {
      return "\\x" + r(h);
    });
  }
  function u(f) {
    return n[f.type](f);
  }
  function a(f) {
    var h = f.map(u), m, p;
    if (h.sort(), h.length > 0) {
      for (m = 1, p = 1; m < h.length; m++)
        h[m - 1] !== h[m] && (h[p] = h[m], p++);
      h.length = p;
    }
    switch (h.length) {
      case 1:
        return h[0];
      case 2:
        return h[0] + " or " + h[1];
      default:
        return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
    }
  }
  function o(f) {
    return f ? '"' + i(f) + '"' : "end of input";
  }
  return "Expected " + a(e) + " but " + o(t) + " found.";
};
function Fd(e, t) {
  t = t !== void 0 ? t : {};
  var n = {}, r = t.grammarSource, i = { start: Xa }, s = Xa, u = ".", a = "-", o = "0", f = ",", h = "|", m = "[", p = "]", b = "{", M = "}", v = "%", E = "<", I = ">", _ = "!", X = "(", S = ")", x = "/", B = "*", k = "?", V = ":", q = "..", G = "^", Y = "struct", W = "target", O = "euclid", te = "slow", Ae = "rotL", pe = "rotR", fe = "fast", Q = "scale", ke = "//", oe = "cat", ge = "$", $ = "setcps", ve = "setbpm", st = "hush", je = /^[1-9]/, be = /^[eE]/, Ke = /^[+\-]/, Fe = /^[0-9]/, $e = /^[ \n\r\t\xA0]/, vt = /^["']/, ot = /^[#\--.0-9A-Z\^-_a-z~\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376-\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4-\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u09FC\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60-\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD-\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, Ie = /^[@_]/, sn = /^[^\n]/, Le = ms("number"), $t = Pe(".", !1), Vt = cn([["1", "9"]], !1, !1), Nt = cn(["e", "E"], !1, !1), un = cn(["+", "-"], !1, !1), Rn = Pe("-", !1), qt = Pe("0", !1), an = cn([["0", "9"]], !1, !1), Kt = ms("whitespace"), At = cn([" ", `
`, "\r", "	", " "], !1, !1), Pn = Pe(",", !1), ye = Pe("|", !1), We = cn(['"', "'"], !1, !1), ue = ms('a letter, a number, "-", "#", ".", "^", "_"'), Oe = cn(["#", ["-", "."], ["0", "9"], ["A", "Z"], ["^", "_"], ["a", "z"], "~", "ª", "µ", "º", ["À", "Ö"], ["Ø", "ö"], ["ø", "ˁ"], ["ˆ", "ˑ"], ["ˠ", "ˤ"], "ˬ", "ˮ", ["Ͱ", "ʹ"], ["Ͷ", "ͷ"], ["ͺ", "ͽ"], "Ϳ", "Ά", ["Έ", "Ί"], "Ό", ["Ύ", "Ρ"], ["Σ", "ϵ"], ["Ϸ", "ҁ"], ["Ҋ", "ԯ"], ["Ա", "Ֆ"], "ՙ", ["ՠ", "ֈ"], ["א", "ת"], ["ׯ", "ײ"], ["ؠ", "ي"], ["ٮ", "ٯ"], ["ٱ", "ۓ"], "ە", ["ۥ", "ۦ"], ["ۮ", "ۯ"], ["ۺ", "ۼ"], "ۿ", "ܐ", ["ܒ", "ܯ"], ["ݍ", "ޥ"], "ޱ", ["ߊ", "ߪ"], ["ߴ", "ߵ"], "ߺ", ["ࠀ", "ࠕ"], "ࠚ", "ࠤ", "ࠨ", ["ࡀ", "ࡘ"], ["ࡠ", "ࡪ"], ["ࢠ", "ࢴ"], ["ࢶ", "ࢽ"], ["ऄ", "ह"], "ऽ", "ॐ", ["क़", "ॡ"], ["ॱ", "ঀ"], ["অ", "ঌ"], ["এ", "ঐ"], ["ও", "ন"], ["প", "র"], "ল", ["শ", "হ"], "ঽ", "ৎ", ["ড়", "ঢ়"], ["য়", "ৡ"], ["ৰ", "ৱ"], "ৼ", ["ਅ", "ਊ"], ["ਏ", "ਐ"], ["ਓ", "ਨ"], ["ਪ", "ਰ"], ["ਲ", "ਲ਼"], ["ਵ", "ਸ਼"], ["ਸ", "ਹ"], ["ਖ਼", "ੜ"], "ਫ਼", ["ੲ", "ੴ"], ["અ", "ઍ"], ["એ", "ઑ"], ["ઓ", "ન"], ["પ", "ર"], ["લ", "ળ"], ["વ", "હ"], "ઽ", "ૐ", ["ૠ", "ૡ"], "ૹ", ["ଅ", "ଌ"], ["ଏ", "ଐ"], ["ଓ", "ନ"], ["ପ", "ର"], ["ଲ", "ଳ"], ["ଵ", "ହ"], "ଽ", ["ଡ଼", "ଢ଼"], ["ୟ", "ୡ"], "ୱ", "ஃ", ["அ", "ஊ"], ["எ", "ஐ"], ["ஒ", "க"], ["ங", "ச"], "ஜ", ["ஞ", "ட"], ["ண", "த"], ["ந", "ப"], ["ம", "ஹ"], "ௐ", ["అ", "ఌ"], ["ఎ", "ఐ"], ["ఒ", "న"], ["ప", "హ"], "ఽ", ["ౘ", "ౚ"], ["ౠ", "ౡ"], "ಀ", ["ಅ", "ಌ"], ["ಎ", "ಐ"], ["ಒ", "ನ"], ["ಪ", "ಳ"], ["ವ", "ಹ"], "ಽ", "ೞ", ["ೠ", "ೡ"], ["ೱ", "ೲ"], ["അ", "ഌ"], ["എ", "ഐ"], ["ഒ", "ഺ"], "ഽ", "ൎ", ["ൔ", "ൖ"], ["ൟ", "ൡ"], ["ൺ", "ൿ"], ["අ", "ඖ"], ["ක", "න"], ["ඳ", "ර"], "ල", ["ව", "ෆ"], ["ก", "ะ"], ["า", "ำ"], ["เ", "ๆ"], ["ກ", "ຂ"], "ຄ", ["ງ", "ຈ"], "ຊ", "ຍ", ["ດ", "ທ"], ["ນ", "ຟ"], ["ມ", "ຣ"], "ລ", "ວ", ["ສ", "ຫ"], ["ອ", "ະ"], ["າ", "ຳ"], "ຽ", ["ເ", "ໄ"], "ໆ", ["ໜ", "ໟ"], "ༀ", ["ཀ", "ཇ"], ["ཉ", "ཬ"], ["ྈ", "ྌ"], ["က", "ဪ"], "ဿ", ["ၐ", "ၕ"], ["ၚ", "ၝ"], "ၡ", ["ၥ", "ၦ"], ["ၮ", "ၰ"], ["ၵ", "ႁ"], "ႎ", ["Ⴀ", "Ⴥ"], "Ⴧ", "Ⴭ", ["ა", "ჺ"], ["ჼ", "ቈ"], ["ቊ", "ቍ"], ["ቐ", "ቖ"], "ቘ", ["ቚ", "ቝ"], ["በ", "ኈ"], ["ኊ", "ኍ"], ["ነ", "ኰ"], ["ኲ", "ኵ"], ["ኸ", "ኾ"], "ዀ", ["ዂ", "ዅ"], ["ወ", "ዖ"], ["ዘ", "ጐ"], ["ጒ", "ጕ"], ["ጘ", "ፚ"], ["ᎀ", "ᎏ"], ["Ꭰ", "Ᏽ"], ["ᏸ", "ᏽ"], ["ᐁ", "ᙬ"], ["ᙯ", "ᙿ"], ["ᚁ", "ᚚ"], ["ᚠ", "ᛪ"], ["ᛮ", "ᛸ"], ["ᜀ", "ᜌ"], ["ᜎ", "ᜑ"], ["ᜠ", "ᜱ"], ["ᝀ", "ᝑ"], ["ᝠ", "ᝬ"], ["ᝮ", "ᝰ"], ["ក", "ឳ"], "ៗ", "ៜ", ["ᠠ", "ᡸ"], ["ᢀ", "ᢄ"], ["ᢇ", "ᢨ"], "ᢪ", ["ᢰ", "ᣵ"], ["ᤀ", "ᤞ"], ["ᥐ", "ᥭ"], ["ᥰ", "ᥴ"], ["ᦀ", "ᦫ"], ["ᦰ", "ᧉ"], ["ᨀ", "ᨖ"], ["ᨠ", "ᩔ"], "ᪧ", ["ᬅ", "ᬳ"], ["ᭅ", "ᭋ"], ["ᮃ", "ᮠ"], ["ᮮ", "ᮯ"], ["ᮺ", "ᯥ"], ["ᰀ", "ᰣ"], ["ᱍ", "ᱏ"], ["ᱚ", "ᱽ"], ["ᲀ", "ᲈ"], ["Ა", "Ჺ"], ["Ჽ", "Ჿ"], ["ᳩ", "ᳬ"], ["ᳮ", "ᳱ"], ["ᳵ", "ᳶ"], ["ᴀ", "ᶿ"], ["Ḁ", "ἕ"], ["Ἐ", "Ἕ"], ["ἠ", "ὅ"], ["Ὀ", "Ὅ"], ["ὐ", "ὗ"], "Ὑ", "Ὓ", "Ὕ", ["Ὗ", "ώ"], ["ᾀ", "ᾴ"], ["ᾶ", "ᾼ"], "ι", ["ῂ", "ῄ"], ["ῆ", "ῌ"], ["ῐ", "ΐ"], ["ῖ", "Ί"], ["ῠ", "Ῥ"], ["ῲ", "ῴ"], ["ῶ", "ῼ"], "ⁱ", "ⁿ", ["ₐ", "ₜ"], "ℂ", "ℇ", ["ℊ", "ℓ"], "ℕ", ["ℙ", "ℝ"], "ℤ", "Ω", "ℨ", ["K", "ℭ"], ["ℯ", "ℹ"], ["ℼ", "ℿ"], ["ⅅ", "ⅉ"], "ⅎ", ["Ⅰ", "ↈ"], ["Ⰰ", "Ⱞ"], ["ⰰ", "ⱞ"], ["Ⱡ", "ⳤ"], ["Ⳬ", "ⳮ"], ["Ⳳ", "ⳳ"], ["ⴀ", "ⴥ"], "ⴧ", "ⴭ", ["ⴰ", "ⵧ"], "ⵯ", ["ⶀ", "ⶖ"], ["ⶠ", "ⶦ"], ["ⶨ", "ⶮ"], ["ⶰ", "ⶶ"], ["ⶸ", "ⶾ"], ["ⷀ", "ⷆ"], ["ⷈ", "ⷎ"], ["ⷐ", "ⷖ"], ["ⷘ", "ⷞ"], "ⸯ", ["々", "〇"], ["〡", "〩"], ["〱", "〵"], ["〸", "〼"], ["ぁ", "ゖ"], ["ゝ", "ゟ"], ["ァ", "ヺ"], ["ー", "ヿ"], ["ㄅ", "ㄯ"], ["ㄱ", "ㆎ"], ["ㆠ", "ㆺ"], ["ㇰ", "ㇿ"], ["㐀", "䶵"], ["一", "鿯"], ["ꀀ", "ꒌ"], ["ꓐ", "ꓽ"], ["ꔀ", "ꘌ"], ["ꘐ", "ꘟ"], ["ꘪ", "ꘫ"], ["Ꙁ", "ꙮ"], ["ꙿ", "ꚝ"], ["ꚠ", "ꛯ"], ["ꜗ", "ꜟ"], ["Ꜣ", "ꞈ"], ["Ꞌ", "ꞹ"], ["ꟷ", "ꠁ"], ["ꠃ", "ꠅ"], ["ꠇ", "ꠊ"], ["ꠌ", "ꠢ"], ["ꡀ", "ꡳ"], ["ꢂ", "ꢳ"], ["ꣲ", "ꣷ"], "ꣻ", ["ꣽ", "ꣾ"], ["ꤊ", "ꤥ"], ["ꤰ", "ꥆ"], ["ꥠ", "ꥼ"], ["ꦄ", "ꦲ"], "ꧏ", ["ꧠ", "ꧤ"], ["ꧦ", "ꧯ"], ["ꧺ", "ꧾ"], ["ꨀ", "ꨨ"], ["ꩀ", "ꩂ"], ["ꩄ", "ꩋ"], ["ꩠ", "ꩶ"], "ꩺ", ["ꩾ", "ꪯ"], "ꪱ", ["ꪵ", "ꪶ"], ["ꪹ", "ꪽ"], "ꫀ", "ꫂ", ["ꫛ", "ꫝ"], ["ꫠ", "ꫪ"], ["ꫲ", "ꫴ"], ["ꬁ", "ꬆ"], ["ꬉ", "ꬎ"], ["ꬑ", "ꬖ"], ["ꬠ", "ꬦ"], ["ꬨ", "ꬮ"], ["ꬰ", "ꭚ"], ["ꭜ", "ꭥ"], ["ꭰ", "ꯢ"], ["가", "힣"], ["ힰ", "ퟆ"], ["ퟋ", "ퟻ"], ["豈", "舘"], ["並", "龎"], ["ﬀ", "ﬆ"], ["ﬓ", "ﬗ"], "יִ", ["ײַ", "ﬨ"], ["שׁ", "זּ"], ["טּ", "לּ"], "מּ", ["נּ", "סּ"], ["ףּ", "פּ"], ["צּ", "ﮱ"], ["ﯓ", "ﴽ"], ["ﵐ", "ﶏ"], ["ﶒ", "ﷇ"], ["ﷰ", "ﷻ"], ["ﹰ", "ﹴ"], ["ﹶ", "ﻼ"], ["Ａ", "Ｚ"], ["ａ", "ｚ"], ["ｦ", "ﾾ"], ["ￂ", "ￇ"], ["ￊ", "ￏ"], ["ￒ", "ￗ"], ["ￚ", "ￜ"]], !1, !1), Be = Pe("[", !1), Ln = Pe("]", !1), Ht = Pe("{", !1), ut = Pe("}", !1), Ve = Pe("%", !1), bt = Pe("<", !1), _e = Pe(">", !1), Gn = cn(["@", "_"], !1, !1), Qn = Pe("!", !1), Ne = Pe("(", !1), ce = Pe(")", !1), ct = Pe("/", !1), tt = Pe("*", !1), lt = Pe("?", !1), er = Pe(":", !1), ds = Pe("..", !1), c = Pe("^", !1), g = Pe("struct", !1), d = Pe("target", !1), y = Pe("euclid", !1), P = Pe("slow", !1), N = Pe("rotL", !1), L = Pe("rotR", !1), Z = Pe("fast", !1), U = Pe("scale", !1), Me = Pe("//", !1), ze = cn([`
`], !0, !1), on = Pe("cat", !1), Dn = Pe("$", !1), oi = Pe("setcps", !1), ci = Pe("setbpm", !1), Pt = Pe("hush", !1), wg = function() {
    return parseFloat(p2());
  }, Sg = function(l) {
    const C = l.join("");
    return C === "." || C === "_";
  }, Bg = function(l) {
    return new ny(l.join(""));
  }, _g = function(l) {
    return l;
  }, kg = function(l, C) {
    return l.arguments_.stepsPerCycle = C, l;
  }, Ig = function(l) {
    return l;
  }, Vg = function(l) {
    return l.arguments_.alignment = "polymeter_slowcat", l;
  }, Ng = function(l) {
    return (C) => C.options_.weight = (C.options_.weight ?? 1) + (l ?? 2) - 1;
  }, Tg = function(l) {
    return (C) => {
      const F = (C.options_.reps ?? 1) + (l ?? 2) - 1;
      C.options_.reps = F, C.options_.ops = C.options_.ops.filter((R) => R.type_ !== "replicate"), C.options_.ops.push({ type_: "replicate", arguments_: { amount: F } }), C.options_.weight = F;
    };
  }, Rg = function(l, C, F) {
    return (R) => R.options_.ops.push({ type_: "bjorklund", arguments_: { pulse: l, step: C, rotation: F } });
  }, Lg = function(l) {
    return (C) => C.options_.ops.push({ type_: "stretch", arguments_: { amount: l, type: "slow" } });
  }, Gg = function(l) {
    return (C) => C.options_.ops.push({ type_: "stretch", arguments_: { amount: l, type: "fast" } });
  }, Xg = function(l) {
    return (C) => C.options_.ops.push({ type_: "degradeBy", arguments_: { amount: l, seed: bs++ } });
  }, Zg = function(l) {
    return (C) => C.options_.ops.push({ type_: "tail", arguments_: { element: l } });
  }, Wg = function(l) {
    return (C) => C.options_.ops.push({ type_: "range", arguments_: { element: l } });
  }, Og = function(l, C) {
    const F = new iy(l, { ops: [], weight: 1, reps: 1 });
    for (const R of C)
      R(F);
    return F;
  }, zg = function(l, C) {
    return new pi(C, "fastcat", void 0, !!l);
  }, jg = function(l) {
    return { alignment: "stack", list: l };
  }, $g = function(l) {
    return { alignment: "rand", list: l, seed: bs++ };
  }, qg = function(l) {
    return { alignment: "feet", list: l, seed: bs++ };
  }, Kg = function(l, C) {
    return C && C.list.length > 0 ? new pi([l, ...C.list], C.alignment, C.seed) : l;
  }, Hg = function(l, C) {
    return new pi(C ? [l, ...C.list] : [l], "polymeter");
  }, Ug = function(l) {
    return l;
  }, Jg = function(l) {
    return { name: "struct", args: { mini: l } };
  }, Yg = function(l) {
    return { name: "target", args: { name: l } };
  }, Qg = function(l, C, F) {
    return { name: "bjorklund", args: { pulse: l, step: parseInt(C) } };
  }, e2 = function(l) {
    return { name: "stretch", args: { amount: l } };
  }, t2 = function(l) {
    return { name: "shift", args: { amount: "-" + l } };
  }, n2 = function(l) {
    return { name: "shift", args: { amount: l } };
  }, r2 = function(l) {
    return { name: "stretch", args: { amount: "1/" + l } };
  }, i2 = function(l) {
    return { name: "scale", args: { scale: l.join("") } };
  }, Ra = function(l, C) {
    return C;
  }, s2 = function(l, C) {
    return C.unshift(l), new pi(C, "slowcat");
  }, u2 = function(l) {
    return l;
  }, a2 = function(l, C) {
    return new ry(l.name, l.args, C);
  }, o2 = function(l) {
    return l;
  }, c2 = function(l) {
    return l;
  }, l2 = function(l) {
    return new As("setcps", { value: l });
  }, f2 = function(l) {
    return new As("setcps", { value: l / 120 / 2 });
  }, h2 = function() {
    return new As("hush");
  }, D = t.peg$currPos | 0, he = D, tr = [{ line: 1, column: 1 }], Tt = D, li = t.peg$maxFailExpected || [], ne = t.peg$silentFails | 0, kr;
  if (t.startRule) {
    if (!(t.startRule in i))
      throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
    s = i[t.startRule];
  }
  function p2() {
    return e.substring(he, D);
  }
  function La() {
    return gs(he, D);
  }
  function Pe(l, C) {
    return { type: "literal", text: l, ignoreCase: C };
  }
  function cn(l, C, F) {
    return { type: "class", parts: l, inverted: C, ignoreCase: F };
  }
  function d2() {
    return { type: "end" };
  }
  function ms(l) {
    return { type: "other", description: l };
  }
  function Ga(l) {
    var C = tr[l], F;
    if (C)
      return C;
    if (l >= tr.length)
      F = tr.length - 1;
    else
      for (F = l; !tr[--F]; )
        ;
    for (C = tr[F], C = {
      line: C.line,
      column: C.column
    }; F < l; )
      e.charCodeAt(F) === 10 ? (C.line++, C.column = 1) : C.column++, F++;
    return tr[l] = C, C;
  }
  function gs(l, C, F) {
    var R = Ga(l), re = Ga(C), Ge = {
      source: r,
      start: {
        offset: l,
        line: R.line,
        column: R.column
      },
      end: {
        offset: C,
        line: re.line,
        column: re.column
      }
    };
    return Ge;
  }
  function se(l) {
    D < Tt || (D > Tt && (Tt = D, li = []), li.push(l));
  }
  function m2(l, C, F) {
    return new Kn(
      Kn.buildMessage(l, C),
      l,
      C,
      F
    );
  }
  function Xa() {
    var l;
    return l = ty(), l;
  }
  function ln() {
    var l, C;
    return ne++, l = D, C2(), C = fi(), C !== n ? (M2(), b2(), he = l, l = wg()) : (D = l, l = n), ne--, l === n && ne === 0 && se(Le), l;
  }
  function g2() {
    var l;
    return e.charCodeAt(D) === 46 ? (l = u, D++) : (l = n, ne === 0 && se($t)), l;
  }
  function y2() {
    var l;
    return l = e.charAt(D), je.test(l) ? D++ : (l = n, ne === 0 && se(Vt)), l;
  }
  function A2() {
    var l;
    return l = e.charAt(D), be.test(l) ? D++ : (l = n, ne === 0 && se(Nt)), l;
  }
  function b2() {
    var l, C, F, R, re;
    if (l = D, C = A2(), C !== n) {
      if (F = e.charAt(D), Ke.test(F) ? D++ : (F = n, ne === 0 && se(un)), F === n && (F = null), R = [], re = nr(), re !== n)
        for (; re !== n; )
          R.push(re), re = nr();
      else
        R = n;
      R !== n ? (C = [C, F, R], l = C) : (D = l, l = n);
    } else
      D = l, l = n;
    return l;
  }
  function M2() {
    var l, C, F, R;
    if (l = D, C = g2(), C !== n) {
      if (F = [], R = nr(), R !== n)
        for (; R !== n; )
          F.push(R), R = nr();
      else
        F = n;
      F !== n ? (C = [C, F], l = C) : (D = l, l = n);
    } else
      D = l, l = n;
    return l;
  }
  function fi() {
    var l, C, F, R;
    if (l = v2(), l === n)
      if (l = D, C = y2(), C !== n) {
        for (F = [], R = nr(); R !== n; )
          F.push(R), R = nr();
        C = [C, F], l = C;
      } else
        D = l, l = n;
    return l;
  }
  function C2() {
    var l;
    return e.charCodeAt(D) === 45 ? (l = a, D++) : (l = n, ne === 0 && se(Rn)), l;
  }
  function v2() {
    var l;
    return e.charCodeAt(D) === 48 ? (l = o, D++) : (l = n, ne === 0 && se(qt)), l;
  }
  function nr() {
    var l;
    return l = e.charAt(D), Fe.test(l) ? D++ : (l = n, ne === 0 && se(an)), l;
  }
  function ae() {
    var l, C;
    for (ne++, l = [], C = e.charAt(D), $e.test(C) ? D++ : (C = n, ne === 0 && se(At)); C !== n; )
      l.push(C), C = e.charAt(D), $e.test(C) ? D++ : (C = n, ne === 0 && se(At));
    return ne--, C = n, ne === 0 && se(Kt), l;
  }
  function rr() {
    var l, C, F, R;
    return l = D, C = ae(), e.charCodeAt(D) === 44 ? (F = f, D++) : (F = n, ne === 0 && se(Pn)), F !== n ? (R = ae(), C = [C, F, R], l = C) : (D = l, l = n), l;
  }
  function Za() {
    var l, C, F, R;
    return l = D, C = ae(), e.charCodeAt(D) === 124 ? (F = h, D++) : (F = n, ne === 0 && se(ye)), F !== n ? (R = ae(), C = [C, F, R], l = C) : (D = l, l = n), l;
  }
  function Wa() {
    var l, C, F, R;
    return l = D, C = ae(), e.charCodeAt(D) === 46 ? (F = u, D++) : (F = n, ne === 0 && se($t)), F !== n ? (R = ae(), C = [C, F, R], l = C) : (D = l, l = n), l;
  }
  function ir() {
    var l;
    return l = e.charAt(D), vt.test(l) ? D++ : (l = n, ne === 0 && se(We)), l;
  }
  function hi() {
    var l;
    return ne++, l = e.charAt(D), ot.test(l) ? D++ : (l = n, ne === 0 && se(Oe)), ne--, l === n && ne === 0 && se(ue), l;
  }
  function Oa() {
    var l, C, F, R;
    if (l = D, ae(), C = [], F = hi(), F !== n)
      for (; F !== n; )
        C.push(F), F = hi();
    else
      C = n;
    return C !== n ? (F = ae(), he = D, R = Sg(C), R ? R = n : R = void 0, R !== n ? (he = l, l = Bg(C)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function P2() {
    var l, C, F, R;
    return l = D, ae(), e.charCodeAt(D) === 91 ? (C = m, D++) : (C = n, ne === 0 && se(Be)), C !== n ? (ae(), F = $a(), F !== n ? (ae(), e.charCodeAt(D) === 93 ? (R = p, D++) : (R = n, ne === 0 && se(Ln)), R !== n ? (ae(), he = l, l = _g(F)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function D2() {
    var l, C, F, R, re;
    return l = D, ae(), e.charCodeAt(D) === 123 ? (C = b, D++) : (C = n, ne === 0 && se(Ht)), C !== n ? (ae(), F = qa(), F !== n ? (ae(), e.charCodeAt(D) === 125 ? (R = M, D++) : (R = n, ne === 0 && se(ut)), R !== n ? (re = F2(), re === n && (re = null), ae(), he = l, l = kg(F, re)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function F2() {
    var l, C, F;
    return l = D, e.charCodeAt(D) === 37 ? (C = v, D++) : (C = n, ne === 0 && se(Ve)), C !== n ? (F = sr(), F !== n ? (he = l, l = Ig(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function E2() {
    var l, C, F, R;
    return l = D, ae(), e.charCodeAt(D) === 60 ? (C = E, D++) : (C = n, ne === 0 && se(bt)), C !== n ? (ae(), F = qa(), F !== n ? (ae(), e.charCodeAt(D) === 62 ? (R = I, D++) : (R = n, ne === 0 && se(_e)), R !== n ? (ae(), he = l, l = Vg(F)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function sr() {
    var l;
    return l = Oa(), l === n && (l = P2(), l === n && (l = D2(), l === n && (l = E2()))), l;
  }
  function za() {
    var l;
    return l = x2(), l === n && (l = S2(), l === n && (l = B2(), l === n && (l = _2(), l === n && (l = w2(), l === n && (l = k2(), l === n && (l = I2(), l === n && (l = V2()))))))), l;
  }
  function x2() {
    var l, C, F;
    return l = D, ae(), C = e.charAt(D), Ie.test(C) ? D++ : (C = n, ne === 0 && se(Gn)), C !== n ? (F = ln(), F === n && (F = null), he = l, l = Ng(F)) : (D = l, l = n), l;
  }
  function w2() {
    var l, C, F;
    return l = D, ae(), e.charCodeAt(D) === 33 ? (C = _, D++) : (C = n, ne === 0 && se(Qn)), C !== n ? (F = ln(), F === n && (F = null), he = l, l = Tg(F)) : (D = l, l = n), l;
  }
  function S2() {
    var l, C, F, R, re, Ge, Rt;
    return l = D, e.charCodeAt(D) === 40 ? (C = X, D++) : (C = n, ne === 0 && se(Ne)), C !== n ? (ae(), F = Ir(), F !== n ? (ae(), R = rr(), R !== n ? (ae(), re = Ir(), re !== n ? (ae(), rr(), ae(), Ge = Ir(), Ge === n && (Ge = null), ae(), e.charCodeAt(D) === 41 ? (Rt = S, D++) : (Rt = n, ne === 0 && se(ce)), Rt !== n ? (he = l, l = Rg(F, re, Ge)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function B2() {
    var l, C, F;
    return l = D, e.charCodeAt(D) === 47 ? (C = x, D++) : (C = n, ne === 0 && se(ct)), C !== n ? (F = sr(), F !== n ? (he = l, l = Lg(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function _2() {
    var l, C, F;
    return l = D, e.charCodeAt(D) === 42 ? (C = B, D++) : (C = n, ne === 0 && se(tt)), C !== n ? (F = sr(), F !== n ? (he = l, l = Gg(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function k2() {
    var l, C, F;
    return l = D, e.charCodeAt(D) === 63 ? (C = k, D++) : (C = n, ne === 0 && se(lt)), C !== n ? (F = ln(), F === n && (F = null), he = l, l = Xg(F)) : (D = l, l = n), l;
  }
  function I2() {
    var l, C, F;
    return l = D, e.charCodeAt(D) === 58 ? (C = V, D++) : (C = n, ne === 0 && se(er)), C !== n ? (F = sr(), F !== n ? (he = l, l = Zg(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function V2() {
    var l, C, F;
    return l = D, e.substr(D, 2) === q ? (C = q, D += 2) : (C = n, ne === 0 && se(ds)), C !== n ? (F = sr(), F !== n ? (he = l, l = Wg(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Ir() {
    var l, C, F, R;
    if (l = D, C = sr(), C !== n) {
      for (F = [], R = za(); R !== n; )
        F.push(R), R = za();
      he = l, l = Og(C, F);
    } else
      D = l, l = n;
    return l;
  }
  function Fn() {
    var l, C, F, R;
    if (l = D, e.charCodeAt(D) === 94 ? (C = G, D++) : (C = n, ne === 0 && se(c)), C === n && (C = null), F = [], R = Ir(), R !== n)
      for (; R !== n; )
        F.push(R), R = Ir();
    else
      F = n;
    return F !== n ? (he = l, l = zg(C, F)) : (D = l, l = n), l;
  }
  function ja() {
    var l, C, F, R, re;
    if (l = D, C = [], F = D, R = rr(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n), F !== n)
      for (; F !== n; )
        C.push(F), F = D, R = rr(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n);
    else
      C = n;
    return C !== n && (he = l, C = jg(C)), l = C, l;
  }
  function N2() {
    var l, C, F, R, re;
    if (l = D, C = [], F = D, R = Za(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n), F !== n)
      for (; F !== n; )
        C.push(F), F = D, R = Za(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n);
    else
      C = n;
    return C !== n && (he = l, C = $g(C)), l = C, l;
  }
  function T2() {
    var l, C, F, R, re;
    if (l = D, C = [], F = D, R = Wa(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n), F !== n)
      for (; F !== n; )
        C.push(F), F = D, R = Wa(), R !== n ? (re = Fn(), re !== n ? F = re : (D = F, F = n)) : (D = F, F = n);
    else
      C = n;
    return C !== n && (he = l, C = qg(C)), l = C, l;
  }
  function $a() {
    var l, C, F;
    return l = D, C = Fn(), C !== n ? (F = ja(), F === n && (F = N2(), F === n && (F = T2())), F === n && (F = null), he = l, l = Kg(C, F)) : (D = l, l = n), l;
  }
  function qa() {
    var l, C, F;
    return l = D, C = Fn(), C !== n ? (F = ja(), F === n && (F = null), he = l, l = Hg(C, F)) : (D = l, l = n), l;
  }
  function R2() {
    var l, C, F, R;
    return l = D, ae(), C = ir(), C !== n ? (ae(), F = $a(), F !== n ? (ae(), R = ir(), R !== n ? (he = l, l = Ug(F)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function L2() {
    var l;
    return l = $2(), l === n && (l = W2(), l === n && (l = j2(), l === n && (l = X2(), l === n && (l = Z2(), l === n && (l = G2(), l === n && (l = z2(), l === n && (l = O2()))))))), l;
  }
  function G2() {
    var l, C, F;
    return l = D, e.substr(D, 6) === Y ? (C = Y, D += 6) : (C = n, ne === 0 && se(g)), C !== n ? (ae(), F = ur(), F !== n ? (he = l, l = Jg(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function X2() {
    var l, C, F, R, re;
    return l = D, e.substr(D, 6) === W ? (C = W, D += 6) : (C = n, ne === 0 && se(d)), C !== n ? (ae(), F = ir(), F !== n ? (R = Oa(), R !== n ? (re = ir(), re !== n ? (he = l, l = Yg(R)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Z2() {
    var l, C, F, R;
    return l = D, e.substr(D, 6) === O ? (C = O, D += 6) : (C = n, ne === 0 && se(y)), C !== n ? (ae(), F = fi(), F !== n ? (ae(), R = fi(), R !== n ? (ae(), fi(), he = l, l = Qg(F, R)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function W2() {
    var l, C, F;
    return l = D, e.substr(D, 4) === te ? (C = te, D += 4) : (C = n, ne === 0 && se(P)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = e2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function O2() {
    var l, C, F;
    return l = D, e.substr(D, 4) === Ae ? (C = Ae, D += 4) : (C = n, ne === 0 && se(N)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = t2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function z2() {
    var l, C, F;
    return l = D, e.substr(D, 4) === pe ? (C = pe, D += 4) : (C = n, ne === 0 && se(L)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = n2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function j2() {
    var l, C, F;
    return l = D, e.substr(D, 4) === fe ? (C = fe, D += 4) : (C = n, ne === 0 && se(Z)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = r2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function $2() {
    var l, C, F, R, re;
    if (l = D, e.substr(D, 5) === Q ? (C = Q, D += 5) : (C = n, ne === 0 && se(U)), C !== n)
      if (ae(), F = ir(), F !== n) {
        if (R = [], re = hi(), re !== n)
          for (; re !== n; )
            R.push(re), re = hi();
        else
          R = n;
        R !== n ? (re = ir(), re !== n ? (he = l, l = i2(R)) : (D = l, l = n)) : (D = l, l = n);
      } else
        D = l, l = n;
    else
      D = l, l = n;
    return l;
  }
  function ys() {
    var l, C, F, R;
    if (l = D, e.substr(D, 2) === ke ? (C = ke, D += 2) : (C = n, ne === 0 && se(Me)), C !== n) {
      for (F = [], R = e.charAt(D), sn.test(R) ? D++ : (R = n, ne === 0 && se(ze)); R !== n; )
        F.push(R), R = e.charAt(D), sn.test(R) ? D++ : (R = n, ne === 0 && se(ze));
      C = [C, F], l = C;
    } else
      D = l, l = n;
    return l;
  }
  function q2() {
    var l, C, F, R, re, Ge, Rt, ar;
    if (l = D, e.substr(D, 3) === oe ? (C = oe, D += 3) : (C = n, ne === 0 && se(on)), C !== n)
      if (ae(), e.charCodeAt(D) === 91 ? (F = m, D++) : (F = n, ne === 0 && se(Be)), F !== n)
        if (ae(), R = ur(), R !== n) {
          for (re = [], Ge = D, Rt = rr(), Rt !== n ? (ar = ur(), ar !== n ? (he = Ge, Ge = Ra(R, ar)) : (D = Ge, Ge = n)) : (D = Ge, Ge = n); Ge !== n; )
            re.push(Ge), Ge = D, Rt = rr(), Rt !== n ? (ar = ur(), ar !== n ? (he = Ge, Ge = Ra(R, ar)) : (D = Ge, Ge = n)) : (D = Ge, Ge = n);
          Ge = ae(), e.charCodeAt(D) === 93 ? (Rt = p, D++) : (Rt = n, ne === 0 && se(Ln)), Rt !== n ? (he = l, l = s2(R, re)) : (D = l, l = n);
        } else
          D = l, l = n;
      else
        D = l, l = n;
    else
      D = l, l = n;
    return l;
  }
  function K2() {
    var l;
    return l = q2(), l === n && (l = R2()), l;
  }
  function ur() {
    var l, C, F, R, re;
    if (l = D, C = K2(), C !== n) {
      for (ae(), F = [], R = ys(); R !== n; )
        F.push(R), R = ys();
      he = l, l = u2(C);
    } else
      D = l, l = n;
    return l === n && (l = D, C = L2(), C !== n ? (ae(), e.charCodeAt(D) === 36 ? (F = ge, D++) : (F = n, ne === 0 && se(Dn)), F !== n ? (R = ae(), re = ur(), re !== n ? (he = l, l = a2(C, re)) : (D = l, l = n)) : (D = l, l = n)) : (D = l, l = n)), l;
  }
  function H2() {
    var l, C;
    return l = D, C = ur(), C !== n && (he = l, C = o2(C)), l = C, l === n && (l = ys()), l;
  }
  function U2() {
    var l;
    return l = H2(), l;
  }
  function J2() {
    var l, C;
    return l = D, ae(), C = Y2(), C === n && (C = Q2(), C === n && (C = ey())), C !== n ? (ae(), he = l, l = c2(C)) : (D = l, l = n), l;
  }
  function Y2() {
    var l, C, F;
    return l = D, e.substr(D, 6) === $ ? (C = $, D += 6) : (C = n, ne === 0 && se(oi)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = l2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function Q2() {
    var l, C, F;
    return l = D, e.substr(D, 6) === ve ? (C = ve, D += 6) : (C = n, ne === 0 && se(ci)), C !== n ? (ae(), F = ln(), F !== n ? (he = l, l = f2(F)) : (D = l, l = n)) : (D = l, l = n), l;
  }
  function ey() {
    var l, C;
    return l = D, e.substr(D, 4) === st ? (C = st, D += 4) : (C = n, ne === 0 && se(Pt)), C !== n && (he = l, C = h2()), l = C, l;
  }
  function ty() {
    var l;
    return l = U2(), l === n && (l = J2()), l;
  }
  var ny = function(l) {
    this.type_ = "atom", this.source_ = l, this.location_ = La();
  }, pi = function(l, C, F, R) {
    this.type_ = "pattern", this.arguments_ = { alignment: C, _steps: R }, F !== void 0 && (this.arguments_.seed = F), this.source_ = l;
  }, ry = function(l, C, F) {
    this.type_ = l, this.arguments_ = C, this.source_ = F;
  }, iy = function(l, C) {
    this.type_ = "element", this.source_ = l, this.options_ = C, this.location_ = La();
  }, As = function(l, C) {
    this.type_ = "command", this.name_ = l, this.options_ = C;
  }, bs = 0;
  if (kr = s(), t.peg$library)
    return (
      /** @type {any} */
      {
        peg$result: kr,
        peg$currPos: D,
        peg$FAILED: n,
        peg$maxFailExpected: li,
        peg$maxFailPos: Tt
      }
    );
  if (kr !== n && D === e.length)
    return kr;
  throw kr !== n && D < e.length && se(d2()), m2(
    li,
    Tt < e.length ? e.charAt(Tt) : null,
    Tt < e.length ? gs(Tt, Tt + 1) : gs(Tt, Tt)
  );
}
const WC = [
  "start"
], Ed = 3e-4, OC = (e, t) => (n, r) => {
  const u = e.source_[r].options_?.ops, a = n.__steps_source;
  if (u)
    for (const o of u)
      switch (o.type_) {
        case "stretch": {
          const f = ["fast", "slow"], { type: h, amount: m } = o.arguments_;
          if (!f.includes(h))
            throw new Error(`mini: stretch: type must be one of ${f.join("|")} but got ${h}`);
          n = K(n)[h](t(m));
          break;
        }
        case "replicate": {
          const { amount: f } = o.arguments_;
          n = K(n), n = n._repeatCycles(f)._fast(f);
          break;
        }
        case "bjorklund": {
          o.arguments_.rotation ? n = n.euclidRot(t(o.arguments_.pulse), t(o.arguments_.step), t(o.arguments_.rotation)) : n = n.euclid(t(o.arguments_.pulse), t(o.arguments_.step));
          break;
        }
        case "degradeBy": {
          n = K(n)._degradeByWith(gt.early(Ed * o.arguments_.seed), o.arguments_.amount ?? 0.5);
          break;
        }
        case "tail": {
          const f = t(o.arguments_.element);
          n = n.fmap((h) => (m) => Array.isArray(h) ? [...h, m] : [h, m]).appLeft(f);
          break;
        }
        case "range": {
          const f = t(o.arguments_.element);
          n = K(n);
          const h = (p, b, M = 1) => Array.from(
            { length: Math.abs(b - p) / M + 1 },
            (v, E) => p < b ? p + E * M : p - E * M
          );
          n = ((p, b) => p.squeezeBind((M) => b.bind((v) => yt(...h(M, v)))))(n, f);
          break;
        }
        default:
          console.warn(`operator "${o.type_}" not implemented`);
      }
  return n.__steps_source = n.__steps_source || a, n;
};
function vr(e, t, n, r = 0) {
  n?.(e);
  const i = (s) => vr(s, t, n, r);
  switch (e.type_) {
    case "pattern": {
      const s = e.source_.map((f) => i(f)).map(OC(e, i)), u = e.arguments_.alignment, a = s.filter((f) => f.__steps_source);
      let o;
      switch (u) {
        case "stack": {
          o = Te(...s), a.length && (o._steps = Zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "polymeter_slowcat": {
          o = Te(...s.map((f) => f._slow(f.__weight))), a.length && (o._steps = Zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "polymeter": {
          const f = e.arguments_.stepsPerCycle ? i(e.arguments_.stepsPerCycle).fmap((m) => j(m)) : Ye(j(s.length > 0 ? s[0].__weight : 1)), h = s.map((m) => m.fast(f.fmap((p) => p.div(m.__weight))));
          o = Te(...h);
          break;
        }
        case "rand": {
          o = ju(gt.early(Ed * e.arguments_.seed).segment(1), s), a.length && (o._steps = Zt(...a.map((f) => j(f._steps))));
          break;
        }
        case "feet": {
          o = yt(...s);
          break;
        }
        default: {
          if (e.source_.some((h) => !!h.options_?.weight)) {
            const h = e.source_.reduce(
              (m, p) => m.add(p.options_?.weight || j(1)),
              j(0)
            );
            o = ku(
              ...e.source_.map((m, p) => [m.options_?.weight || j(1), s[p]])
            ), o.__weight = h, o._steps = h, a.length && (o._steps = o._steps.mul(Zt(...a.map((m) => j(m._steps)))));
          } else
            o = Bt(...s), o._steps = s.length;
          e.arguments_._steps && (o.__steps_source = !0);
        }
      }
      return a.length && (o.__steps_source = !0), o;
    }
    case "element":
      return i(e.source_);
    case "atom": {
      if (e.source_ === "~" || e.source_ === "-")
        return Se;
      if (!e.location_)
        return console.warn("no location for", e), e.source_;
      const s = isNaN(Number(e.source_)) ? e.source_ : Number(e.source_);
      if (r === -1)
        return Ye(s);
      const [u, a] = Qu(t, e, r);
      return Ye(s).withLoc(u, a);
    }
    case "stretch":
      return i(e.source_).slow(i(e.arguments_.amount));
    default:
      return console.warn(`node type "${e.type_}" not implemented -> returning silence`), Se;
  }
}
const Qu = (e, t, n = 0) => {
  const { start: r, end: i } = t.location_, s = e?.split("").slice(r.offset, i.offset).join(""), [u = 0, a = 0] = s ? s.split(t.source_).map((o) => o.split("").filter((f) => f === " ").length) : [];
  return [r.offset + u + n, i.offset - a + n];
}, ni = (e, t = 0, n = e) => {
  try {
    return Fd(e);
  } catch (r) {
    const i = [r.location.start.offset + t, r.location.end.offset + t], s = n.slice(0, i[0]).split(`
`).length;
    throw new Error(`[mini] parse error at line ${s}: ${r.message}`);
  }
}, xd = (e, t, n) => {
  const r = ni(e, t, n);
  let i = [];
  return vr(
    r,
    e,
    (s) => {
      s.type_ === "atom" && i.push(s);
    },
    -1
  ), i;
}, ea = (e, t = 0, n) => xd(e, t, n).map((r) => Qu(e, r, t)), ta = (...e) => {
  const t = e.map((n) => {
    const r = `"${n}"`, i = ni(r);
    return vr(i, r);
  });
  return Bt(...t);
}, zC = (e, t) => {
  const n = `"${e}"`, r = ni(n);
  return vr(r, n, null, t);
}, jC = (e) => {
  const t = ni(e);
  return vr(t, e);
};
function $C(e) {
  return typeof e == "string" ? ta(e) : K(e);
}
function wd() {
  Ec(ta);
}
const qC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StartRules: WC,
  SyntaxError: Kn,
  getLeafLocation: Qu,
  getLeafLocations: ea,
  getLeaves: xd,
  h: jC,
  m: zC,
  mini: ta,
  mini2ast: ni,
  miniAllStrings: wd,
  minify: $C,
  parse: Fd,
  patternifyAST: vr
}, Symbol.toStringTag, { value: "Module" }));
var KC = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], Sd = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], HC = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", Bd = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", xs = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, ws = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", UC = {
  5: ws,
  "5module": ws + " export import",
  6: ws + " const class extends export import super"
}, JC = /^in(stanceof)?$/, YC = new RegExp("[" + Bd + "]"), QC = new RegExp("[" + Bd + HC + "]");
function ou(e, t) {
  for (var n = 65536, r = 0; r < t.length; r += 2) {
    if (n += t[r], n > e)
      return !1;
    if (n += t[r + 1], n >= e)
      return !0;
  }
  return !1;
}
function bn(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && YC.test(String.fromCharCode(e)) : t === !1 ? !1 : ou(e, Sd);
}
function gr(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && QC.test(String.fromCharCode(e)) : t === !1 ? !1 : ou(e, Sd) || ou(e, KC);
}
var Ee = function(t, n) {
  n === void 0 && (n = {}), this.label = t, this.keyword = n.keyword, this.beforeExpr = !!n.beforeExpr, this.startsExpr = !!n.startsExpr, this.isLoop = !!n.isLoop, this.isAssign = !!n.isAssign, this.prefix = !!n.prefix, this.postfix = !!n.postfix, this.binop = n.binop || null, this.updateContext = null;
};
function Dt(e, t) {
  return new Ee(e, { beforeExpr: !0, binop: t });
}
var Ft = { beforeExpr: !0 }, pt = { startsExpr: !0 }, na = {};
function De(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, na[e] = new Ee(e, t);
}
var A = {
  num: new Ee("num", pt),
  regexp: new Ee("regexp", pt),
  string: new Ee("string", pt),
  name: new Ee("name", pt),
  privateId: new Ee("privateId", pt),
  eof: new Ee("eof"),
  // Punctuation token types.
  bracketL: new Ee("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new Ee("]"),
  braceL: new Ee("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new Ee("}"),
  parenL: new Ee("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new Ee(")"),
  comma: new Ee(",", Ft),
  semi: new Ee(";", Ft),
  colon: new Ee(":", Ft),
  dot: new Ee("."),
  question: new Ee("?", Ft),
  questionDot: new Ee("?."),
  arrow: new Ee("=>", Ft),
  template: new Ee("template"),
  invalidTemplate: new Ee("invalidTemplate"),
  ellipsis: new Ee("...", Ft),
  backQuote: new Ee("`", pt),
  dollarBraceL: new Ee("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new Ee("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new Ee("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new Ee("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new Ee("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: Dt("||", 1),
  logicalAND: Dt("&&", 2),
  bitwiseOR: Dt("|", 3),
  bitwiseXOR: Dt("^", 4),
  bitwiseAND: Dt("&", 5),
  equality: Dt("==/!=/===/!==", 6),
  relational: Dt("</>/<=/>=", 7),
  bitShift: Dt("<</>>/>>>", 8),
  plusMin: new Ee("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: Dt("%", 10),
  star: Dt("*", 10),
  slash: Dt("/", 10),
  starstar: new Ee("**", { beforeExpr: !0 }),
  coalesce: Dt("??", 1),
  // Keyword token types.
  _break: De("break"),
  _case: De("case", Ft),
  _catch: De("catch"),
  _continue: De("continue"),
  _debugger: De("debugger"),
  _default: De("default", Ft),
  _do: De("do", { isLoop: !0, beforeExpr: !0 }),
  _else: De("else", Ft),
  _finally: De("finally"),
  _for: De("for", { isLoop: !0 }),
  _function: De("function", pt),
  _if: De("if"),
  _return: De("return", Ft),
  _switch: De("switch"),
  _throw: De("throw", Ft),
  _try: De("try"),
  _var: De("var"),
  _const: De("const"),
  _while: De("while", { isLoop: !0 }),
  _with: De("with"),
  _new: De("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: De("this", pt),
  _super: De("super", pt),
  _class: De("class", pt),
  _extends: De("extends", Ft),
  _export: De("export"),
  _import: De("import", pt),
  _null: De("null", pt),
  _true: De("true", pt),
  _false: De("false", pt),
  _in: De("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: De("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: De("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: De("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: De("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, kt = /\r\n?|\n|\u2028|\u2029/, ev = new RegExp(kt.source, "g");
function Pr(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function _d(e, t, n) {
  n === void 0 && (n = e.length);
  for (var r = t; r < n; r++) {
    var i = e.charCodeAt(r);
    if (Pr(i))
      return r < n - 1 && i === 13 && e.charCodeAt(r + 1) === 10 ? r + 2 : r + 1;
  }
  return -1;
}
var kd = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Et = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Id = Object.prototype, tv = Id.hasOwnProperty, nv = Id.toString, Dr = Object.hasOwn || function(e, t) {
  return tv.call(e, t);
}, ho = Array.isArray || function(e) {
  return nv.call(e) === "[object Array]";
}, po = /* @__PURE__ */ Object.create(null);
function Sn(e) {
  return po[e] || (po[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function Mn(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
var rv = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Yr = function(t, n) {
  this.line = t, this.column = n;
};
Yr.prototype.offset = function(t) {
  return new Yr(this.line, this.column + t);
};
var $i = function(t, n, r) {
  this.start = n, this.end = r, t.sourceFile !== null && (this.source = t.sourceFile);
};
function Vd(e, t) {
  for (var n = 1, r = 0; ; ) {
    var i = _d(e, r, t);
    if (i < 0)
      return new Yr(n, t - r);
    ++n, r = i;
  }
}
var cu = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, mo = !1;
function iv(e) {
  var t = {};
  for (var n in cu)
    t[n] = e && Dr(e, n) ? e[n] : cu[n];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!mo && typeof console == "object" && console.warn && (mo = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14), ho(t.onToken)) {
    var r = t.onToken;
    t.onToken = function(i) {
      return r.push(i);
    };
  }
  return ho(t.onComment) && (t.onComment = sv(t, t.onComment)), t;
}
function sv(e, t) {
  return function(n, r, i, s, u, a) {
    var o = {
      type: n ? "Block" : "Line",
      value: r,
      start: i,
      end: s
    };
    e.locations && (o.loc = new $i(this, u, a)), e.ranges && (o.range = [i, s]), t.push(o);
  };
}
var Qr = 1, Fr = 2, ra = 4, Nd = 8, Td = 16, Rd = 32, ia = 64, Ld = 128, ri = 256, sa = Qr | Fr | ri;
function ua(e, t) {
  return Fr | (e ? ra : 0) | (t ? Nd : 0);
}
var _i = 0, aa = 1, vn = 2, Gd = 3, Xd = 4, Zd = 5, Qe = function(t, n, r) {
  this.options = t = iv(t), this.sourceFile = t.sourceFile, this.keywords = Sn(UC[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var i = "";
  t.allowReserved !== !0 && (i = xs[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (i += " await")), this.reservedWords = Sn(i);
  var s = (i ? i + " " : "") + xs.strict;
  this.reservedWordsStrict = Sn(s), this.reservedWordsStrictBind = Sn(s + " " + xs.strictBind), this.input = String(n), this.containsEsc = !1, r ? (this.pos = r, this.lineStart = this.input.lastIndexOf(`
`, r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(kt).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = A.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Qr), this.regexpState = null, this.privateNameStack = [];
}, nn = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
Qe.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
nn.inFunction.get = function() {
  return (this.currentVarScope().flags & Fr) > 0;
};
nn.inGenerator.get = function() {
  return (this.currentVarScope().flags & Nd) > 0 && !this.currentVarScope().inClassFieldInit;
};
nn.inAsync.get = function() {
  return (this.currentVarScope().flags & ra) > 0 && !this.currentVarScope().inClassFieldInit;
};
nn.canAwait.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e];
    if (t.inClassFieldInit || t.flags & ri)
      return !1;
    if (t.flags & Fr)
      return (t.flags & ra) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
nn.allowSuper.get = function() {
  var e = this.currentThisScope(), t = e.flags, n = e.inClassFieldInit;
  return (t & ia) > 0 || n || this.options.allowSuperOutsideMethod;
};
nn.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & Ld) > 0;
};
nn.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
nn.allowNewDotTarget.get = function() {
  var e = this.currentThisScope(), t = e.flags, n = e.inClassFieldInit;
  return (t & (Fr | ri)) > 0 || n;
};
nn.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & ri) > 0;
};
Qe.extend = function() {
  for (var t = [], n = arguments.length; n--; ) t[n] = arguments[n];
  for (var r = this, i = 0; i < t.length; i++)
    r = t[i](r);
  return r;
};
Qe.parse = function(t, n) {
  return new this(n, t).parse();
};
Qe.parseExpressionAt = function(t, n, r) {
  var i = new this(r, t, n);
  return i.nextToken(), i.parseExpression();
};
Qe.tokenizer = function(t, n) {
  return new this(n, t);
};
Object.defineProperties(Qe.prototype, nn);
var ht = Qe.prototype, uv = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
ht.strictDirective = function(e) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    Et.lastIndex = e, e += Et.exec(this.input)[0].length;
    var t = uv.exec(this.input.slice(e));
    if (!t)
      return !1;
    if ((t[1] || t[2]) === "use strict") {
      Et.lastIndex = e + t[0].length;
      var n = Et.exec(this.input), r = n.index + n[0].length, i = this.input.charAt(r);
      return i === ";" || i === "}" || kt.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || i === "!" && this.input.charAt(r + 1) === "=");
    }
    e += t[0].length, Et.lastIndex = e, e += Et.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
ht.eat = function(e) {
  return this.type === e ? (this.next(), !0) : !1;
};
ht.isContextual = function(e) {
  return this.type === A.name && this.value === e && !this.containsEsc;
};
ht.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), !0) : !1;
};
ht.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
ht.canInsertSemicolon = function() {
  return this.type === A.eof || this.type === A.braceR || kt.test(this.input.slice(this.lastTokEnd, this.start));
};
ht.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
ht.semicolon = function() {
  !this.eat(A.semi) && !this.insertSemicolon() && this.unexpected();
};
ht.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
};
ht.expect = function(e) {
  this.eat(e) || this.unexpected();
};
ht.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
var qi = function() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
ht.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var n = t ? e.parenthesizedAssign : e.parenthesizedBind;
    n > -1 && this.raiseRecoverable(n, t ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
ht.checkExpressionErrors = function(e, t) {
  if (!e)
    return !1;
  var n = e.shorthandAssign, r = e.doubleProto;
  if (!t)
    return n >= 0 || r >= 0;
  n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
ht.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
ht.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var ee = Qe.prototype;
ee.parseTopLevel = function(e) {
  var t = /* @__PURE__ */ Object.create(null);
  for (e.body || (e.body = []); this.type !== A.eof; ) {
    var n = this.parseStatement(null, !0, t);
    e.body.push(n);
  }
  if (this.inModule)
    for (var r = 0, i = Object.keys(this.undefinedExports); r < i.length; r += 1) {
      var s = i[r];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var oa = { kind: "loop" }, av = { kind: "switch" };
ee.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  Et.lastIndex = this.pos;
  var t = Et.exec(this.input), n = this.pos + t[0].length, r = this.input.charCodeAt(n);
  if (r === 91 || r === 92)
    return !0;
  if (e)
    return !1;
  if (r === 123 || r > 55295 && r < 56320)
    return !0;
  if (bn(r, !0)) {
    for (var i = n + 1; gr(r = this.input.charCodeAt(i), !0); )
      ++i;
    if (r === 92 || r > 55295 && r < 56320)
      return !0;
    var s = this.input.slice(n, i);
    if (!JC.test(s))
      return !0;
  }
  return !1;
};
ee.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  Et.lastIndex = this.pos;
  var e = Et.exec(this.input), t = this.pos + e[0].length, n;
  return !kt.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(gr(n = this.input.charCodeAt(t + 8)) || n > 55295 && n < 56320));
};
ee.parseStatement = function(e, t, n) {
  var r = this.type, i = this.startNode(), s;
  switch (this.isLet(e) && (r = A._var, s = "let"), r) {
    case A._break:
    case A._continue:
      return this.parseBreakContinueStatement(i, r.keyword);
    case A._debugger:
      return this.parseDebuggerStatement(i);
    case A._do:
      return this.parseDoStatement(i);
    case A._for:
      return this.parseForStatement(i);
    case A._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i, !1, !e);
    case A._class:
      return e && this.unexpected(), this.parseClass(i, !0);
    case A._if:
      return this.parseIfStatement(i);
    case A._return:
      return this.parseReturnStatement(i);
    case A._switch:
      return this.parseSwitchStatement(i);
    case A._throw:
      return this.parseThrowStatement(i);
    case A._try:
      return this.parseTryStatement(i);
    case A._const:
    case A._var:
      return s = s || this.value, e && s !== "var" && this.unexpected(), this.parseVarStatement(i, s);
    case A._while:
      return this.parseWhileStatement(i);
    case A._with:
      return this.parseWithStatement(i);
    case A.braceL:
      return this.parseBlock(!0, i);
    case A.semi:
      return this.parseEmptyStatement(i);
    case A._export:
    case A._import:
      if (this.options.ecmaVersion > 10 && r === A._import) {
        Et.lastIndex = this.pos;
        var u = Et.exec(this.input), a = this.pos + u[0].length, o = this.input.charCodeAt(a);
        if (o === 40 || o === 46)
          return this.parseExpressionStatement(i, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === A._import ? this.parseImport(i) : this.parseExport(i, n);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !e);
      var f = this.value, h = this.parseExpression();
      return r === A.name && h.type === "Identifier" && this.eat(A.colon) ? this.parseLabeledStatement(i, f, h, e) : this.parseExpressionStatement(i, h);
  }
};
ee.parseBreakContinueStatement = function(e, t) {
  var n = t === "break";
  this.next(), this.eat(A.semi) || this.insertSemicolon() ? e.label = null : this.type !== A.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var r = 0; r < this.labels.length; ++r) {
    var i = this.labels[r];
    if ((e.label == null || i.name === e.label.name) && (i.kind != null && (n || i.kind === "loop") || e.label && n))
      break;
  }
  return r === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, n ? "BreakStatement" : "ContinueStatement");
};
ee.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
ee.parseDoStatement = function(e) {
  return this.next(), this.labels.push(oa), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(A._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(A.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
ee.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(oa), this.enterScope(0), this.expect(A.parenL), this.type === A.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var n = this.isLet();
  if (this.type === A._var || this.type === A._const || n) {
    var r = this.startNode(), i = n ? "let" : this.value;
    return this.next(), this.parseVar(r, !0, i), this.finishNode(r, "VariableDeclaration"), (this.type === A._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && r.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === A._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, r)) : (t > -1 && this.unexpected(t), this.parseFor(e, r));
  }
  var s = this.isContextual("let"), u = !1, a = this.containsEsc, o = new qi(), f = this.start, h = t > -1 ? this.parseExprSubscripts(o, "await") : this.parseExpression(!0, o);
  return this.type === A._in || (u = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === A._in && this.unexpected(t), e.await = !0) : u && this.options.ecmaVersion >= 8 && (h.start === f && !a && h.type === "Identifier" && h.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (e.await = !1)), s && u && this.raise(h.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(h, !1, o), this.checkLValPattern(h), this.parseForIn(e, h)) : (this.checkExpressionErrors(o, !0), t > -1 && this.unexpected(t), this.parseFor(e, h));
};
ee.parseFunctionStatement = function(e, t, n) {
  return this.next(), this.parseFunction(e, $r | (n ? 0 : lu), !1, t);
};
ee.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(A._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
ee.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(A.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
ee.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(A.braceL), this.labels.push(av), this.enterScope(0);
  for (var t, n = !1; this.type !== A.braceR; )
    if (this.type === A._case || this.type === A._default) {
      var r = this.type === A._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), r ? t.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, t.test = null), this.expect(A.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
ee.parseThrowStatement = function(e) {
  return this.next(), kt.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var ov = [];
ee.parseCatchClauseParam = function() {
  var e = this.parseBindingAtom(), t = e.type === "Identifier";
  return this.enterScope(t ? Rd : 0), this.checkLValPattern(e, t ? Xd : vn), this.expect(A.parenR), e;
};
ee.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === A._catch) {
    var t = this.startNode();
    this.next(), this.eat(A.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(A._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
ee.parseVarStatement = function(e, t, n) {
  return this.next(), this.parseVar(e, !1, t, n), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
ee.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(oa), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
ee.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
ee.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
ee.parseLabeledStatement = function(e, t, n, r) {
  for (var i = 0, s = this.labels; i < s.length; i += 1) {
    var u = s[i];
    u.name === t && this.raise(n.start, "Label '" + t + "' is already declared");
  }
  for (var a = this.type.isLoop ? "loop" : this.type === A._switch ? "switch" : null, o = this.labels.length - 1; o >= 0; o--) {
    var f = this.labels[o];
    if (f.statementStart === e.start)
      f.statementStart = this.start, f.kind = a;
    else
      break;
  }
  return this.labels.push({ name: t, kind: a, statementStart: this.start }), e.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.labels.pop(), e.label = n, this.finishNode(e, "LabeledStatement");
};
ee.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
ee.parseBlock = function(e, t, n) {
  for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(A.braceL), e && this.enterScope(0); this.type !== A.braceR; ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return n && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
ee.parseFor = function(e, t) {
  return e.init = t, this.expect(A.semi), e.test = this.type === A.semi ? null : this.parseExpression(), this.expect(A.semi), e.update = this.type === A.parenR ? null : this.parseExpression(), this.expect(A.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
ee.parseForIn = function(e, t) {
  var n = this.type === A._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!n || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
    t.start,
    (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), e.left = t, e.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(A.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
};
ee.parseVar = function(e, t, n, r) {
  for (e.declarations = [], e.kind = n; ; ) {
    var i = this.startNode();
    if (this.parseVarId(i, n), this.eat(A.eq) ? i.init = this.parseMaybeAssign(t) : !r && n === "const" && !(this.type === A._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !r && i.id.type !== "Identifier" && !(t && (this.type === A._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(A.comma))
      break;
  }
  return e;
};
ee.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? aa : vn, !1);
};
var $r = 1, lu = 2, Wd = 4;
ee.parseFunction = function(e, t, n, r, i) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) && (this.type === A.star && t & lu && this.unexpected(), e.generator = this.eat(A.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), t & $r && (e.id = t & Wd && this.type !== A.name ? null : this.parseIdent(), e.id && !(t & lu) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? aa : vn : Gd));
  var s = this.yieldPos, u = this.awaitPos, a = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(ua(e.async, e.generator)), t & $r || (e.id = this.type === A.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, n, !1, i), this.yieldPos = s, this.awaitPos = u, this.awaitIdentPos = a, this.finishNode(e, t & $r ? "FunctionDeclaration" : "FunctionExpression");
};
ee.parseFunctionParams = function(e) {
  this.expect(A.parenL), e.params = this.parseBindingList(A.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
ee.parseClass = function(e, t) {
  this.next();
  var n = this.strict;
  this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
  var r = this.enterClassBody(), i = this.startNode(), s = !1;
  for (i.body = [], this.expect(A.braceL); this.type !== A.braceR; ) {
    var u = this.parseClassElement(e.superClass !== null);
    u && (i.body.push(u), u.type === "MethodDefinition" && u.kind === "constructor" ? (s && this.raiseRecoverable(u.start, "Duplicate constructor in the same class"), s = !0) : u.key && u.key.type === "PrivateIdentifier" && cv(r, u) && this.raiseRecoverable(u.key.start, "Identifier '#" + u.key.name + "' has already been declared"));
  }
  return this.strict = n, this.next(), e.body = this.finishNode(i, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
ee.parseClassElement = function(e) {
  if (this.eat(A.semi))
    return null;
  var t = this.options.ecmaVersion, n = this.startNode(), r = "", i = !1, s = !1, u = "method", a = !1;
  if (this.eatContextual("static")) {
    if (t >= 13 && this.eat(A.braceL))
      return this.parseClassStaticBlock(n), n;
    this.isClassElementNameStart() || this.type === A.star ? a = !0 : r = "static";
  }
  if (n.static = a, !r && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === A.star) && !this.canInsertSemicolon() ? s = !0 : r = "async"), !r && (t >= 9 || !s) && this.eat(A.star) && (i = !0), !r && !s && !i) {
    var o = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? u = o : r = o);
  }
  if (r ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = r, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), t < 13 || this.type === A.parenL || u !== "method" || i || s) {
    var f = !n.static && ki(n, "constructor"), h = f && e;
    f && u !== "method" && this.raise(n.key.start, "Constructor can't have get/set modifier"), n.kind = f ? "constructor" : u, this.parseClassMethod(n, i, s, h);
  } else
    this.parseClassField(n);
  return n;
};
ee.isClassElementNameStart = function() {
  return this.type === A.name || this.type === A.privateId || this.type === A.num || this.type === A.string || this.type === A.bracketL || this.type.keyword;
};
ee.parseClassElementName = function(e) {
  this.type === A.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
};
ee.parseClassMethod = function(e, t, n, r) {
  var i = e.key;
  e.kind === "constructor" ? (t && this.raise(i.start, "Constructor can't be a generator"), n && this.raise(i.start, "Constructor can't be an async method")) : e.static && ki(e, "prototype") && this.raise(i.start, "Classes may not have a static property named prototype");
  var s = e.value = this.parseMethod(t, n, r);
  return e.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"), e.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"), e.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
};
ee.parseClassField = function(e) {
  if (ki(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && ki(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(A.eq)) {
    var t = this.currentThisScope(), n = t.inClassFieldInit;
    t.inClassFieldInit = !0, e.value = this.parseMaybeAssign(), t.inClassFieldInit = n;
  } else
    e.value = null;
  return this.semicolon(), this.finishNode(e, "PropertyDefinition");
};
ee.parseClassStaticBlock = function(e) {
  e.body = [];
  var t = this.labels;
  for (this.labels = [], this.enterScope(ri | ia); this.type !== A.braceR; ) {
    var n = this.parseStatement(null);
    e.body.push(n);
  }
  return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
};
ee.parseClassId = function(e, t) {
  this.type === A.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, vn, !1)) : (t === !0 && this.unexpected(), e.id = null);
};
ee.parseClassSuper = function(e) {
  e.superClass = this.eat(A._extends) ? this.parseExprSubscripts(null, !1) : null;
};
ee.enterClassBody = function() {
  var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(e), e.declared;
};
ee.exitClassBody = function() {
  var e = this.privateNameStack.pop(), t = e.declared, n = e.used;
  if (this.options.checkPrivateFields)
    for (var r = this.privateNameStack.length, i = r === 0 ? null : this.privateNameStack[r - 1], s = 0; s < n.length; ++s) {
      var u = n[s];
      Dr(t, u.name) || (i ? i.used.push(u) : this.raiseRecoverable(u.start, "Private field '#" + u.name + "' must be declared in an enclosing class"));
    }
};
function cv(e, t) {
  var n = t.key.name, r = e[n], i = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (i = (t.static ? "s" : "i") + t.kind), r === "iget" && i === "iset" || r === "iset" && i === "iget" || r === "sget" && i === "sset" || r === "sset" && i === "sget" ? (e[n] = "true", !1) : r ? !0 : (e[n] = i, !1);
}
function ki(e, t) {
  var n = e.computed, r = e.key;
  return !n && (r.type === "Identifier" && r.name === t || r.type === "Literal" && r.value === t);
}
ee.parseExportAllDeclaration = function(e, t) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== A.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
};
ee.parseExport = function(e, t) {
  if (this.next(), this.eat(A.star))
    return this.parseExportAllDeclaration(e, t);
  if (this.eat(A._default))
    return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== A.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    else {
      for (var n = 0, r = e.specifiers; n < r.length; n += 1) {
        var i = r[n];
        this.checkUnreserved(i.local), this.checkLocalExport(i.local), i.local.type === "Literal" && this.raise(i.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
ee.parseExportDeclaration = function(e) {
  return this.parseStatement(null);
};
ee.parseExportDefaultDeclaration = function() {
  var e;
  if (this.type === A._function || (e = this.isAsyncFunction())) {
    var t = this.startNode();
    return this.next(), e && this.next(), this.parseFunction(t, $r | Wd, !1, e);
  } else if (this.type === A._class) {
    var n = this.startNode();
    return this.parseClass(n, "nullableID");
  } else {
    var r = this.parseMaybeAssign();
    return this.semicolon(), r;
  }
};
ee.checkExport = function(e, t, n) {
  e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Dr(e, t) && this.raiseRecoverable(n, "Duplicate export '" + t + "'"), e[t] = !0);
};
ee.checkPatternExport = function(e, t) {
  var n = t.type;
  if (n === "Identifier")
    this.checkExport(e, t, t.start);
  else if (n === "ObjectPattern")
    for (var r = 0, i = t.properties; r < i.length; r += 1) {
      var s = i[r];
      this.checkPatternExport(e, s);
    }
  else if (n === "ArrayPattern")
    for (var u = 0, a = t.elements; u < a.length; u += 1) {
      var o = a[u];
      o && this.checkPatternExport(e, o);
    }
  else n === "Property" ? this.checkPatternExport(e, t.value) : n === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : n === "RestElement" && this.checkPatternExport(e, t.argument);
};
ee.checkVariableExport = function(e, t) {
  if (e)
    for (var n = 0, r = t; n < r.length; n += 1) {
      var i = r[n];
      this.checkPatternExport(e, i.id);
    }
};
ee.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
ee.parseExportSpecifier = function(e) {
  var t = this.startNode();
  return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
    e,
    t.exported,
    t.exported.start
  ), this.finishNode(t, "ExportSpecifier");
};
ee.parseExportSpecifiers = function(e) {
  var t = [], n = !0;
  for (this.expect(A.braceL); !this.eat(A.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(A.comma), this.afterTrailingComma(A.braceR))
      break;
    t.push(this.parseExportSpecifier(e));
  }
  return t;
};
ee.parseImport = function(e) {
  return this.next(), this.type === A.string ? (e.specifiers = ov, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === A.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
ee.parseImportSpecifier = function() {
  var e = this.startNode();
  return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, vn), this.finishNode(e, "ImportSpecifier");
};
ee.parseImportDefaultSpecifier = function() {
  var e = this.startNode();
  return e.local = this.parseIdent(), this.checkLValSimple(e.local, vn), this.finishNode(e, "ImportDefaultSpecifier");
};
ee.parseImportNamespaceSpecifier = function() {
  var e = this.startNode();
  return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, vn), this.finishNode(e, "ImportNamespaceSpecifier");
};
ee.parseImportSpecifiers = function() {
  var e = [], t = !0;
  if (this.type === A.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(A.comma)))
    return e;
  if (this.type === A.star)
    return e.push(this.parseImportNamespaceSpecifier()), e;
  for (this.expect(A.braceL); !this.eat(A.braceR); ) {
    if (t)
      t = !1;
    else if (this.expect(A.comma), this.afterTrailingComma(A.braceR))
      break;
    e.push(this.parseImportSpecifier());
  }
  return e;
};
ee.parseWithClause = function() {
  var e = [];
  if (!this.eat(A._with))
    return e;
  this.expect(A.braceL);
  for (var t = {}, n = !0; !this.eat(A.braceR); ) {
    if (n)
      n = !1;
    else if (this.expect(A.comma), this.afterTrailingComma(A.braceR))
      break;
    var r = this.parseImportAttribute(), i = r.key.type === "Identifier" ? r.key.name : r.key.value;
    Dr(t, i) && this.raiseRecoverable(r.key.start, "Duplicate attribute key '" + i + "'"), t[i] = !0, e.push(r);
  }
  return e;
};
ee.parseImportAttribute = function() {
  var e = this.startNode();
  return e.key = this.type === A.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(A.colon), this.type !== A.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
};
ee.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === A.string) {
    var e = this.parseLiteral(this.value);
    return rv.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
  }
  return this.parseIdent(!0);
};
ee.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
ee.isDirectiveCandidate = function(e) {
  return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var It = Qe.prototype;
It.toAssignable = function(e, t, n) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
        for (var r = 0, i = e.properties; r < i.length; r += 1) {
          var s = i[r];
          this.toAssignable(s, t), s.type === "RestElement" && (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") && this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else n && this.checkPatternErrors(n, !0);
  return e;
};
It.toAssignableList = function(e, t) {
  for (var n = e.length, r = 0; r < n; r++) {
    var i = e[r];
    i && this.toAssignable(i, t);
  }
  if (n) {
    var s = e[n - 1];
    this.options.ecmaVersion === 6 && t && s && s.type === "RestElement" && s.argument.type !== "Identifier" && this.unexpected(s.argument.start);
  }
  return e;
};
It.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
};
It.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== A.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
It.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case A.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(A.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
      case A.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
It.parseBindingList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); )
    if (s ? s = !1 : this.expect(A.comma), t && this.type === A.comma)
      i.push(null);
    else {
      if (n && this.afterTrailingComma(e))
        break;
      if (this.type === A.ellipsis) {
        var u = this.parseRestBinding();
        this.parseBindingListItem(u), i.push(u), this.type === A.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else
        i.push(this.parseAssignableListItem(r));
    }
  return i;
};
It.parseAssignableListItem = function(e) {
  var t = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(t), t;
};
It.parseBindingListItem = function(e) {
  return e;
};
It.parseMaybeDefault = function(e, t, n) {
  if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(A.eq))
    return n;
  var r = this.startNodeAt(e, t);
  return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, "AssignmentPattern");
};
It.checkLValSimple = function(e, t, n) {
  t === void 0 && (t = _i);
  var r = t !== _i;
  switch (e.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (r ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (t === vn && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), n && (Dr(n, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), n[e.name] = !0), t !== Zd && this.declareName(e.name, t, e.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      r && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return r && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, n);
    default:
      this.raise(e.start, (r ? "Binding" : "Assigning to") + " rvalue");
  }
};
It.checkLValPattern = function(e, t, n) {
  switch (t === void 0 && (t = _i), e.type) {
    case "ObjectPattern":
      for (var r = 0, i = e.properties; r < i.length; r += 1) {
        var s = i[r];
        this.checkLValInnerPattern(s, t, n);
      }
      break;
    case "ArrayPattern":
      for (var u = 0, a = e.elements; u < a.length; u += 1) {
        var o = a[u];
        o && this.checkLValInnerPattern(o, t, n);
      }
      break;
    default:
      this.checkLValSimple(e, t, n);
  }
};
It.checkLValInnerPattern = function(e, t, n) {
  switch (t === void 0 && (t = _i), e.type) {
    case "Property":
      this.checkLValInnerPattern(e.value, t, n);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(e.left, t, n);
      break;
    case "RestElement":
      this.checkLValPattern(e.argument, t, n);
      break;
    default:
      this.checkLValPattern(e, t, n);
  }
};
var Xt = function(t, n, r, i, s) {
  this.token = t, this.isExpr = !!n, this.preserveSpace = !!r, this.override = i, this.generator = !!s;
}, Ze = {
  b_stat: new Xt("{", !1),
  b_expr: new Xt("{", !0),
  b_tmpl: new Xt("${", !1),
  p_stat: new Xt("(", !1),
  p_expr: new Xt("(", !0),
  q_tmpl: new Xt("`", !0, !0, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new Xt("function", !1),
  f_expr: new Xt("function", !0),
  f_expr_gen: new Xt("function", !0, !1, null, !0),
  f_gen: new Xt("function", !1, !1, null, !0)
}, Er = Qe.prototype;
Er.initialContext = function() {
  return [Ze.b_stat];
};
Er.curContext = function() {
  return this.context[this.context.length - 1];
};
Er.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === Ze.f_expr || t === Ze.f_stat ? !0 : e === A.colon && (t === Ze.b_stat || t === Ze.b_expr) ? !t.isExpr : e === A._return || e === A.name && this.exprAllowed ? kt.test(this.input.slice(this.lastTokEnd, this.start)) : e === A._else || e === A.semi || e === A.eof || e === A.parenR || e === A.arrow ? !0 : e === A.braceL ? t === Ze.b_stat : e === A._var || e === A._const || e === A.name ? !1 : !this.exprAllowed;
};
Er.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return !1;
};
Er.updateContext = function(e) {
  var t, n = this.type;
  n.keyword && e === A.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr;
};
Er.overrideContext = function(e) {
  this.curContext() !== e && (this.context[this.context.length - 1] = e);
};
A.parenR.updateContext = A.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var e = this.context.pop();
  e === Ze.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
A.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? Ze.b_stat : Ze.b_expr), this.exprAllowed = !0;
};
A.dollarBraceL.updateContext = function() {
  this.context.push(Ze.b_tmpl), this.exprAllowed = !0;
};
A.parenL.updateContext = function(e) {
  var t = e === A._if || e === A._for || e === A._with || e === A._while;
  this.context.push(t ? Ze.p_stat : Ze.p_expr), this.exprAllowed = !0;
};
A.incDec.updateContext = function() {
};
A._function.updateContext = A._class.updateContext = function(e) {
  e.beforeExpr && e !== A._else && !(e === A.semi && this.curContext() !== Ze.p_stat) && !(e === A._return && kt.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === A.colon || e === A.braceL) && this.curContext() === Ze.b_stat) ? this.context.push(Ze.f_expr) : this.context.push(Ze.f_stat), this.exprAllowed = !1;
};
A.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
A.backQuote.updateContext = function() {
  this.curContext() === Ze.q_tmpl ? this.context.pop() : this.context.push(Ze.q_tmpl), this.exprAllowed = !1;
};
A.star.updateContext = function(e) {
  if (e === A._function) {
    var t = this.context.length - 1;
    this.context[t] === Ze.f_expr ? this.context[t] = Ze.f_expr_gen : this.context[t] = Ze.f_gen;
  }
  this.exprAllowed = !0;
};
A.name.updateContext = function(e) {
  var t = !1;
  this.options.ecmaVersion >= 6 && e !== A.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
};
var le = Qe.prototype;
le.checkPropClash = function(e, t, n) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var r = e.key, i;
    switch (r.type) {
      case "Identifier":
        i = r.name;
        break;
      case "Literal":
        i = String(r.value);
        break;
      default:
        return;
    }
    var s = e.kind;
    if (this.options.ecmaVersion >= 6) {
      i === "__proto__" && s === "init" && (t.proto && (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), t.proto = !0);
      return;
    }
    i = "$" + i;
    var u = t[i];
    if (u) {
      var a;
      s === "init" ? a = this.strict && u.init || u.get || u.set : a = u.init || u[s], a && this.raiseRecoverable(r.start, "Redefinition of property");
    } else
      u = t[i] = {
        init: !1,
        get: !1,
        set: !1
      };
    u[s] = !0;
  }
};
le.parseExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeAssign(e, t);
  if (this.type === A.comma) {
    var s = this.startNodeAt(n, r);
    for (s.expressions = [i]; this.eat(A.comma); )
      s.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(s, "SequenceExpression");
  }
  return i;
};
le.parseMaybeAssign = function(e, t, n) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = !1;
  }
  var r = !1, i = -1, s = -1, u = -1;
  t ? (i = t.parenthesizedAssign, s = t.trailingComma, u = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new qi(), r = !0);
  var a = this.start, o = this.startLoc;
  (this.type === A.parenL || this.type === A.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
  var f = this.parseMaybeConditional(e, t);
  if (n && (f = n.call(this, f, a, o)), this.type.isAssign) {
    var h = this.startNodeAt(a, o);
    return h.operator = this.value, this.type === A.eq && (f = this.toAssignable(f, !1, t)), r || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= f.start && (t.shorthandAssign = -1), this.type === A.eq ? this.checkLValPattern(f) : this.checkLValSimple(f), h.left = f, this.next(), h.right = this.parseMaybeAssign(e), u > -1 && (t.doubleProto = u), this.finishNode(h, "AssignmentExpression");
  } else
    r && this.checkExpressionErrors(t, !0);
  return i > -1 && (t.parenthesizedAssign = i), s > -1 && (t.trailingComma = s), f;
};
le.parseMaybeConditional = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return i;
  if (this.eat(A.question)) {
    var s = this.startNodeAt(n, r);
    return s.test = i, s.consequent = this.parseMaybeAssign(), this.expect(A.colon), s.alternate = this.parseMaybeAssign(e), this.finishNode(s, "ConditionalExpression");
  }
  return i;
};
le.parseExprOps = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseMaybeUnary(t, !1, !1, e);
  return this.checkExpressionErrors(t) || i.start === n && i.type === "ArrowFunctionExpression" ? i : this.parseExprOp(i, n, r, -1, e);
};
le.parseExprOp = function(e, t, n, r, i) {
  var s = this.type.binop;
  if (s != null && (!i || this.type !== A._in) && s > r) {
    var u = this.type === A.logicalOR || this.type === A.logicalAND, a = this.type === A.coalesce;
    a && (s = A.logicalAND.binop);
    var o = this.value;
    this.next();
    var f = this.start, h = this.startLoc, m = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, i), f, h, s, i), p = this.buildBinary(t, n, e, m, o, u || a);
    return (u && this.type === A.coalesce || a && (this.type === A.logicalOR || this.type === A.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, t, n, r, i);
  }
  return e;
};
le.buildBinary = function(e, t, n, r, i, s) {
  r.type === "PrivateIdentifier" && this.raise(r.start, "Private identifier can only be left side of binary expression");
  var u = this.startNodeAt(e, t);
  return u.left = n, u.operator = i, u.right = r, this.finishNode(u, s ? "LogicalExpression" : "BinaryExpression");
};
le.parseMaybeUnary = function(e, t, n, r) {
  var i = this.start, s = this.startLoc, u;
  if (this.isContextual("await") && this.canAwait)
    u = this.parseAwait(r), t = !0;
  else if (this.type.prefix) {
    var a = this.startNode(), o = this.type === A.incDec;
    a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0, o, r), this.checkExpressionErrors(e, !0), o ? this.checkLValSimple(a.argument) : this.strict && a.operator === "delete" && Od(a.argument) ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : a.operator === "delete" && fu(a.argument) ? this.raiseRecoverable(a.start, "Private fields can not be deleted") : t = !0, u = this.finishNode(a, o ? "UpdateExpression" : "UnaryExpression");
  } else if (!t && this.type === A.privateId)
    (r || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), u = this.parsePrivateIdent(), this.type !== A._in && this.unexpected();
  else {
    if (u = this.parseExprSubscripts(e, r), this.checkExpressionErrors(e))
      return u;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var f = this.startNodeAt(i, s);
      f.operator = this.value, f.prefix = !1, f.argument = u, this.checkLValSimple(u), this.next(), u = this.finishNode(f, "UpdateExpression");
    }
  }
  if (!n && this.eat(A.starstar))
    if (t)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(i, s, u, this.parseMaybeUnary(null, !1, !1, r), "**", !1);
  else
    return u;
};
function Od(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && Od(e.expression);
}
function fu(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && fu(e.expression) || e.type === "ParenthesizedExpression" && fu(e.expression);
}
le.parseExprSubscripts = function(e, t) {
  var n = this.start, r = this.startLoc, i = this.parseExprAtom(e, t);
  if (i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return i;
  var s = this.parseSubscripts(i, n, r, !1, t);
  return e && s.type === "MemberExpression" && (e.parenthesizedAssign >= s.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= s.start && (e.parenthesizedBind = -1), e.trailingComma >= s.start && (e.trailingComma = -1)), s;
};
le.parseSubscripts = function(e, t, n, r, i) {
  for (var s = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, u = !1; ; ) {
    var a = this.parseSubscript(e, t, n, r, s, u, i);
    if (a.optional && (u = !0), a === e || a.type === "ArrowFunctionExpression") {
      if (u) {
        var o = this.startNodeAt(t, n);
        o.expression = a, a = this.finishNode(o, "ChainExpression");
      }
      return a;
    }
    e = a;
  }
};
le.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(A.arrow);
};
le.parseSubscriptAsyncArrow = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !0, r);
};
le.parseSubscript = function(e, t, n, r, i, s, u) {
  var a = this.options.ecmaVersion >= 11, o = a && this.eat(A.questionDot);
  r && o && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var f = this.eat(A.bracketL);
  if (f || o && this.type !== A.parenL && this.type !== A.backQuote || this.eat(A.dot)) {
    var h = this.startNodeAt(t, n);
    h.object = e, f ? (h.property = this.parseExpression(), this.expect(A.bracketR)) : this.type === A.privateId && e.type !== "Super" ? h.property = this.parsePrivateIdent() : h.property = this.parseIdent(this.options.allowReserved !== "never"), h.computed = !!f, a && (h.optional = o), e = this.finishNode(h, "MemberExpression");
  } else if (!r && this.eat(A.parenL)) {
    var m = new qi(), p = this.yieldPos, b = this.awaitPos, M = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var v = this.parseExprList(A.parenR, this.options.ecmaVersion >= 8, !1, m);
    if (i && !o && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(m, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = b, this.awaitIdentPos = M, this.parseSubscriptAsyncArrow(t, n, v, u);
    this.checkExpressionErrors(m, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = b || this.awaitPos, this.awaitIdentPos = M || this.awaitIdentPos;
    var E = this.startNodeAt(t, n);
    E.callee = e, E.arguments = v, a && (E.optional = o), e = this.finishNode(E, "CallExpression");
  } else if (this.type === A.backQuote) {
    (o || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var I = this.startNodeAt(t, n);
    I.tag = e, I.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(I, "TaggedTemplateExpression");
  }
  return e;
};
le.parseExprAtom = function(e, t, n) {
  this.type === A.slash && this.readRegexp();
  var r, i = this.potentialArrowAt === this.start;
  switch (this.type) {
    case A._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === A.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== A.dot && this.type !== A.bracketL && this.type !== A.parenL && this.unexpected(), this.finishNode(r, "Super");
    case A._this:
      return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
    case A.name:
      var s = this.start, u = this.startLoc, a = this.containsEsc, o = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !a && o.name === "async" && !this.canInsertSemicolon() && this.eat(A._function))
        return this.overrideContext(Ze.f_expr), this.parseFunction(this.startNodeAt(s, u), 0, !1, !0, t);
      if (i && !this.canInsertSemicolon()) {
        if (this.eat(A.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, u), [o], !1, t);
        if (this.options.ecmaVersion >= 8 && o.name === "async" && this.type === A.name && !a && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return o = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(A.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, u), [o], !0, t);
      }
      return o;
    case A.regexp:
      var f = this.value;
      return r = this.parseLiteral(f.value), r.regex = { pattern: f.pattern, flags: f.flags }, r;
    case A.num:
    case A.string:
      return this.parseLiteral(this.value);
    case A._null:
    case A._true:
    case A._false:
      return r = this.startNode(), r.value = this.type === A._null ? null : this.type === A._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
    case A.parenL:
      var h = this.start, m = this.parseParenAndDistinguishExpression(i, t);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(m) && (e.parenthesizedAssign = h), e.parenthesizedBind < 0 && (e.parenthesizedBind = h)), m;
    case A.bracketL:
      return r = this.startNode(), this.next(), r.elements = this.parseExprList(A.bracketR, !0, !0, e), this.finishNode(r, "ArrayExpression");
    case A.braceL:
      return this.overrideContext(Ze.b_expr), this.parseObj(!1, e);
    case A._function:
      return r = this.startNode(), this.next(), this.parseFunction(r, 0);
    case A._class:
      return this.parseClass(this.startNode(), !1);
    case A._new:
      return this.parseNew();
    case A.backQuote:
      return this.parseTemplate();
    case A._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
le.parseExprAtomDefault = function() {
  this.unexpected();
};
le.parseExprImport = function(e) {
  var t = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === A.parenL && !e)
    return this.parseDynamicImport(t);
  if (this.type === A.dot) {
    var n = this.startNodeAt(t.start, t.loc && t.loc.start);
    return n.name = "import", t.meta = this.finishNode(n, "Identifier"), this.parseImportMeta(t);
  } else
    this.unexpected();
};
le.parseDynamicImport = function(e) {
  if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
    this.eat(A.parenR) ? e.options = null : (this.expect(A.comma), this.afterTrailingComma(A.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(A.parenR) || (this.expect(A.comma), this.afterTrailingComma(A.parenR) || this.unexpected())));
  else if (!this.eat(A.parenR)) {
    var t = this.start;
    this.eat(A.comma) && this.eat(A.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
  }
  return this.finishNode(e, "ImportExpression");
};
le.parseImportMeta = function(e) {
  this.next();
  var t = this.containsEsc;
  return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
};
le.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
};
le.parseParenExpression = function() {
  this.expect(A.parenL);
  var e = this.parseExpression();
  return this.expect(A.parenR), e;
};
le.shouldParseArrow = function(e) {
  return !this.canInsertSemicolon();
};
le.parseParenAndDistinguishExpression = function(e, t) {
  var n = this.start, r = this.startLoc, i, s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var u = this.start, a = this.startLoc, o = [], f = !0, h = !1, m = new qi(), p = this.yieldPos, b = this.awaitPos, M;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== A.parenR; )
      if (f ? f = !1 : this.expect(A.comma), s && this.afterTrailingComma(A.parenR, !0)) {
        h = !0;
        break;
      } else if (this.type === A.ellipsis) {
        M = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === A.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        o.push(this.parseMaybeAssign(!1, m, this.parseParenItem));
    var v = this.lastTokEnd, E = this.lastTokEndLoc;
    if (this.expect(A.parenR), e && this.shouldParseArrow(o) && this.eat(A.arrow))
      return this.checkPatternErrors(m, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = b, this.parseParenArrowList(n, r, o, t);
    (!o.length || h) && this.unexpected(this.lastTokStart), M && this.unexpected(M), this.checkExpressionErrors(m, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = b || this.awaitPos, o.length > 1 ? (i = this.startNodeAt(u, a), i.expressions = o, this.finishNodeAt(i, "SequenceExpression", v, E)) : i = o[0];
  } else
    i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var I = this.startNodeAt(n, r);
    return I.expression = i, this.finishNode(I, "ParenthesizedExpression");
  } else
    return i;
};
le.parseParenItem = function(e) {
  return e;
};
le.parseParenArrowList = function(e, t, n, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), n, !1, r);
};
var lv = [];
le.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var e = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === A.dot) {
    var t = this.startNodeAt(e.start, e.loc && e.loc.start);
    t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
    var n = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
  }
  var r = this.start, i = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), r, i, !0, !1), this.eat(A.parenL) ? e.arguments = this.parseExprList(A.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = lv, this.finishNode(e, "NewExpression");
};
le.parseTemplateElement = function(e) {
  var t = e.isTagged, n = this.startNode();
  return this.type === A.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
    raw: this.value.replace(/\r\n?/g, `
`),
    cooked: null
  }) : n.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), n.tail = this.type === A.backQuote, this.finishNode(n, "TemplateElement");
};
le.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = !1);
  var n = this.startNode();
  this.next(), n.expressions = [];
  var r = this.parseTemplateElement({ isTagged: t });
  for (n.quasis = [r]; !r.tail; )
    this.type === A.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(A.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(A.braceR), n.quasis.push(r = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(n, "TemplateLiteral");
};
le.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === A.name || this.type === A.num || this.type === A.string || this.type === A.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === A.star) && !kt.test(this.input.slice(this.lastTokEnd, this.start));
};
le.parseObj = function(e, t) {
  var n = this.startNode(), r = !0, i = {};
  for (n.properties = [], this.next(); !this.eat(A.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(A.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(A.braceR))
      break;
    var s = this.parseProperty(e, t);
    e || this.checkPropClash(s, i, t), n.properties.push(s);
  }
  return this.finishNode(n, e ? "ObjectPattern" : "ObjectExpression");
};
le.parseProperty = function(e, t) {
  var n = this.startNode(), r, i, s, u;
  if (this.options.ecmaVersion >= 9 && this.eat(A.ellipsis))
    return e ? (n.argument = this.parseIdent(!1), this.type === A.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(n, "RestElement")) : (n.argument = this.parseMaybeAssign(!1, t), this.type === A.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(n, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (n.method = !1, n.shorthand = !1, (e || t) && (s = this.start, u = this.startLoc), e || (r = this.eat(A.star)));
  var a = this.containsEsc;
  return this.parsePropertyName(n), !e && !a && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(n) ? (i = !0, r = this.options.ecmaVersion >= 9 && this.eat(A.star), this.parsePropertyName(n)) : i = !1, this.parsePropertyValue(n, e, r, i, s, u, t, a), this.finishNode(n, "Property");
};
le.parseGetterSetter = function(e) {
  e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1);
  var t = e.kind === "get" ? 0 : 1;
  if (e.value.params.length !== t) {
    var n = e.value.start;
    e.kind === "get" ? this.raiseRecoverable(n, "getter should have no params") : this.raiseRecoverable(n, "setter should have exactly one param");
  } else
    e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
};
le.parsePropertyValue = function(e, t, n, r, i, s, u, a) {
  (n || r) && this.type === A.colon && this.unexpected(), this.eat(A.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, u), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === A.parenL ? (t && this.unexpected(), e.kind = "init", e.method = !0, e.value = this.parseMethod(n, r)) : !t && !a && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== A.comma && this.type !== A.braceR && this.type !== A.eq ? ((n || r) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((n || r) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = i), e.kind = "init", t ? e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key)) : this.type === A.eq && u ? (u.shorthandAssign < 0 && (u.shorthandAssign = this.start), e.value = this.parseMaybeDefault(i, s, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = !0) : this.unexpected();
};
le.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(A.bracketL))
      return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(A.bracketR), e.key;
    e.computed = !1;
  }
  return e.key = this.type === A.num || this.type === A.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
le.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
};
le.parseMethod = function(e, t, n) {
  var r = this.startNode(), i = this.yieldPos, s = this.awaitPos, u = this.awaitIdentPos;
  return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(ua(t, r.generator) | ia | (n ? Ld : 0)), this.expect(A.parenL), r.params = this.parseBindingList(A.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1, !0, !1), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = u, this.finishNode(r, "FunctionExpression");
};
le.parseArrowExpression = function(e, t, n, r) {
  var i = this.yieldPos, s = this.awaitPos, u = this.awaitIdentPos;
  return this.enterScope(ua(n, !1) | Td), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, r), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = u, this.finishNode(e, "ArrowFunctionExpression");
};
le.parseFunctionBody = function(e, t, n, r) {
  var i = t && this.type !== A.braceL, s = this.strict, u = !1;
  if (i)
    e.body = this.parseMaybeAssign(r), e.expression = !0, this.checkParams(e, !1);
  else {
    var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!s || a) && (u = this.strictDirective(this.end), u && a && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], u && (this.strict = !0), this.checkParams(e, !s && !u && !t && !n && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, Zd), e.body = this.parseBlock(!1, void 0, u && !s), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = o;
  }
  this.exitScope();
};
le.isSimpleParamList = function(e) {
  for (var t = 0, n = e; t < n.length; t += 1) {
    var r = n[t];
    if (r.type !== "Identifier")
      return !1;
  }
  return !0;
};
le.checkParams = function(e, t) {
  for (var n = /* @__PURE__ */ Object.create(null), r = 0, i = e.params; r < i.length; r += 1) {
    var s = i[r];
    this.checkLValInnerPattern(s, aa, t ? null : n);
  }
};
le.parseExprList = function(e, t, n, r) {
  for (var i = [], s = !0; !this.eat(e); ) {
    if (s)
      s = !1;
    else if (this.expect(A.comma), t && this.afterTrailingComma(e))
      break;
    var u = void 0;
    n && this.type === A.comma ? u = null : this.type === A.ellipsis ? (u = this.parseSpread(r), r && this.type === A.comma && r.trailingComma < 0 && (r.trailingComma = this.start)) : u = this.parseMaybeAssign(!1, r), i.push(u);
  }
  return i;
};
le.checkUnreserved = function(e) {
  var t = e.start, n = e.end, r = e.name;
  if (this.inGenerator && r === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && r === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (r === "arguments" || r === "await") && this.raise(t, "Cannot use " + r + " in class static initialization block"), this.keywords.test(r) && this.raise(t, "Unexpected keyword '" + r + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, n).indexOf("\\") !== -1)) {
    var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
    i.test(r) && (!this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + r + "' is reserved"));
  }
};
le.parseIdent = function(e) {
  var t = this.parseIdentNode();
  return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t;
};
le.parseIdentNode = function() {
  var e = this.startNode();
  return this.type === A.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = A.name) : this.unexpected(), e;
};
le.parsePrivateIdent = function() {
  var e = this.startNode();
  return this.type === A.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
};
le.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === A.semi || this.canInsertSemicolon() || this.type !== A.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(A.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
le.parseAwait = function(e) {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
};
var Ii = Qe.prototype;
Ii.raise = function(e, t) {
  var n = Vd(this.input, e);
  t += " (" + n.line + ":" + n.column + ")";
  var r = new SyntaxError(t);
  throw r.pos = e, r.loc = n, r.raisedAt = this.pos, r;
};
Ii.raiseRecoverable = Ii.raise;
Ii.curPosition = function() {
  if (this.options.locations)
    return new Yr(this.curLine, this.pos - this.lineStart);
};
var Nn = Qe.prototype, fv = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
Nn.enterScope = function(e) {
  this.scopeStack.push(new fv(e));
};
Nn.exitScope = function() {
  this.scopeStack.pop();
};
Nn.treatFunctionsAsVarInScope = function(e) {
  return e.flags & Fr || !this.inModule && e.flags & Qr;
};
Nn.declareName = function(e, t, n) {
  var r = !1;
  if (t === vn) {
    var i = this.currentScope();
    r = i.lexical.indexOf(e) > -1 || i.functions.indexOf(e) > -1 || i.var.indexOf(e) > -1, i.lexical.push(e), this.inModule && i.flags & Qr && delete this.undefinedExports[e];
  } else if (t === Xd) {
    var s = this.currentScope();
    s.lexical.push(e);
  } else if (t === Gd) {
    var u = this.currentScope();
    this.treatFunctionsAsVar ? r = u.lexical.indexOf(e) > -1 : r = u.lexical.indexOf(e) > -1 || u.var.indexOf(e) > -1, u.functions.push(e);
  } else
    for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var o = this.scopeStack[a];
      if (o.lexical.indexOf(e) > -1 && !(o.flags & Rd && o.lexical[0] === e) || !this.treatFunctionsAsVarInScope(o) && o.functions.indexOf(e) > -1) {
        r = !0;
        break;
      }
      if (o.var.push(e), this.inModule && o.flags & Qr && delete this.undefinedExports[e], o.flags & sa)
        break;
    }
  r && this.raiseRecoverable(n, "Identifier '" + e + "' has already been declared");
};
Nn.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Nn.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Nn.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & sa)
      return t;
  }
};
Nn.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & sa && !(t.flags & Td))
      return t;
  }
};
var Ki = function(t, n, r) {
  this.type = "", this.start = n, this.end = 0, t.options.locations && (this.loc = new $i(t, r)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [n, 0]);
}, ii = Qe.prototype;
ii.startNode = function() {
  return new Ki(this, this.start, this.startLoc);
};
ii.startNodeAt = function(e, t) {
  return new Ki(this, e, t);
};
function zd(e, t, n, r) {
  return e.type = t, e.end = n, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = n), e;
}
ii.finishNode = function(e, t) {
  return zd.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
ii.finishNodeAt = function(e, t, n, r) {
  return zd.call(this, e, t, n, r);
};
ii.copyNode = function(e) {
  var t = new Ki(this, e.start, this.startLoc);
  for (var n in e)
    t[n] = e[n];
  return t;
};
var hv = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", jd = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", $d = jd + " Extended_Pictographic", qd = $d, Kd = qd + " EBase EComp EMod EPres ExtPict", Hd = Kd, pv = Hd, dv = {
  9: jd,
  10: $d,
  11: qd,
  12: Kd,
  13: Hd,
  14: pv
}, mv = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", gv = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: mv
}, go = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Ud = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Jd = Ud + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Yd = Jd + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Qd = Yd + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", em = Qd + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", yv = em + " " + hv, Av = {
  9: Ud,
  10: Jd,
  11: Yd,
  12: Qd,
  13: em,
  14: yv
}, tm = {};
function bv(e) {
  var t = tm[e] = {
    binary: Sn(dv[e] + " " + go),
    binaryOfStrings: Sn(gv[e]),
    nonBinary: {
      General_Category: Sn(go),
      Script: Sn(Av[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
for (var Ss = 0, yo = [9, 10, 11, 12, 13, 14]; Ss < yo.length; Ss += 1) {
  var Mv = yo[Ss];
  bv(Mv);
}
var J = Qe.prototype, Vi = function(t, n) {
  this.parent = t, this.base = n || this;
};
Vi.prototype.separatedFrom = function(t) {
  for (var n = this; n; n = n.parent)
    for (var r = t; r; r = r.parent)
      if (n.base === r.base && n !== r)
        return !0;
  return !1;
};
Vi.prototype.sibling = function() {
  return new Vi(this.parent, this.base);
};
var rn = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = tm[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
};
rn.prototype.reset = function(t, n, r) {
  var i = r.indexOf("v") !== -1, s = r.indexOf("u") !== -1;
  this.start = t | 0, this.source = n + "", this.flags = r, i && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
};
rn.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
rn.prototype.at = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return -1;
  var s = r.charCodeAt(t);
  if (!(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i)
    return s;
  var u = r.charCodeAt(t + 1);
  return u >= 56320 && u <= 57343 ? (s << 10) + u - 56613888 : s;
};
rn.prototype.nextIndex = function(t, n) {
  n === void 0 && (n = !1);
  var r = this.source, i = r.length;
  if (t >= i)
    return i;
  var s = r.charCodeAt(t), u;
  return !(n || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= i || (u = r.charCodeAt(t + 1)) < 56320 || u > 57343 ? t + 1 : t + 2;
};
rn.prototype.current = function(t) {
  return t === void 0 && (t = !1), this.at(this.pos, t);
};
rn.prototype.lookahead = function(t) {
  return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
};
rn.prototype.advance = function(t) {
  t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
};
rn.prototype.eat = function(t, n) {
  return n === void 0 && (n = !1), this.current(n) === t ? (this.advance(n), !0) : !1;
};
rn.prototype.eatChars = function(t, n) {
  n === void 0 && (n = !1);
  for (var r = this.pos, i = 0, s = t; i < s.length; i += 1) {
    var u = s[i], a = this.at(r, n);
    if (a === -1 || a !== u)
      return !1;
    r = this.nextIndex(r, n);
  }
  return this.pos = r, !0;
};
J.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, n = e.flags, r = !1, i = !1, s = 0; s < n.length; s++) {
    var u = n.charAt(s);
    t.indexOf(u) === -1 && this.raise(e.start, "Invalid regular expression flag"), n.indexOf(u, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), u === "u" && (r = !0), u === "v" && (i = !0);
  }
  this.options.ecmaVersion >= 15 && r && i && this.raise(e.start, "Invalid regular expression flag");
};
function Cv(e) {
  for (var t in e)
    return !0;
  return !1;
}
J.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && Cv(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
};
J.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* ] */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, n = e.backReferenceNames; t < n.length; t += 1) {
    var r = n[t];
    e.groupNames[r] || e.raise("Invalid named capture referenced");
  }
};
J.regexp_disjunction = function(e) {
  var t = this.options.ecmaVersion >= 16;
  for (t && (e.branchID = new Vi(e.branchID, null)), this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
  t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
J.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
J.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
};
J.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = !1, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return !0;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return !0;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var n = !1;
    if (this.options.ecmaVersion >= 9 && (n = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !n, !0;
  }
  return e.pos = t, !1;
};
J.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), !0) : !1;
};
J.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
J.regexp_eatBracedQuantifier = function(e, t) {
  var n = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var r = 0, i = -1;
    if (this.regexp_eatDecimalDigits(e) && (r = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return i !== -1 && i < r && !t && e.raise("numbers out of order in {} quantifier"), !0;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = n;
  }
  return !1;
};
J.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
J.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var n = this.regexp_eatModifiers(e), r = e.eat(
          45
          /* - */
        );
        if (n || r) {
          for (var i = 0; i < n.length; i++) {
            var s = n.charAt(i);
            n.indexOf(s, i + 1) > -1 && e.raise("Duplicate regular expression modifiers");
          }
          if (r) {
            var u = this.regexp_eatModifiers(e);
            !n && !u && e.current() === 58 && e.raise("Invalid regular expression modifiers");
            for (var a = 0; a < u.length; a++) {
              var o = u.charAt(a);
              (u.indexOf(o, a + 1) > -1 || n.indexOf(o) > -1) && e.raise("Duplicate regular expression modifiers");
            }
          }
        }
      }
      if (e.eat(
        58
        /* : */
      )) {
        if (this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ))
          return !0;
        e.raise("Unterminated group");
      }
    }
    e.pos = t;
  }
  return !1;
};
J.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, !0;
    e.raise("Unterminated group");
  }
  return !1;
};
J.regexp_eatModifiers = function(e) {
  for (var t = "", n = 0; (n = e.current()) !== -1 && vv(n); )
    t += Mn(n), e.advance();
  return t;
};
function vv(e) {
  return e === 105 || e === 109 || e === 115;
}
J.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
J.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
};
J.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return nm(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function nm(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
J.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, n = 0; (n = e.current()) !== -1 && !nm(n); )
    e.advance();
  return e.pos !== t;
};
J.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
};
J.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    this.regexp_eatGroupName(e) || e.raise("Invalid group");
    var t = this.options.ecmaVersion >= 16, n = e.groupNames[e.lastStringValue];
    if (n)
      if (t)
        for (var r = 0, i = n; r < i.length; r += 1) {
          var s = i[r];
          s.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
        }
      else
        e.raise("Duplicate capture group name");
    t ? (n || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
  }
};
J.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return !0;
    e.raise("Invalid capture group name");
  }
  return !1;
};
J.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += Mn(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += Mn(e.lastIntValue);
    return !0;
  }
  return !1;
};
J.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), Pv(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function Pv(e) {
  return bn(e, !0) || e === 36 || e === 95;
}
J.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, n = this.options.ecmaVersion >= 11, r = e.current(n);
  return e.advance(n), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (r = e.lastIntValue), Dv(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function Dv(e) {
  return gr(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
J.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
};
J.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var n = e.lastIntValue;
    if (e.switchU)
      return n > e.maxBackReference && (e.maxBackReference = n), !0;
    if (n <= e.numCapturingParens)
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), !0;
    e.raise("Invalid named reference");
  }
  return !1;
};
J.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
J.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
J.regexp_eatZero = function(e) {
  return e.current() === 48 && !Hi(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
};
J.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
};
J.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return rm(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
function rm(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
J.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
  t === void 0 && (t = !1);
  var n = e.pos, r = t || e.switchU;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var i = e.lastIntValue;
      if (r && i >= 55296 && i <= 56319) {
        var s = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var u = e.lastIntValue;
          if (u >= 56320 && u <= 57343)
            return e.lastIntValue = (i - 55296) * 1024 + (u - 56320) + 65536, !0;
        }
        e.pos = s, e.lastIntValue = i;
      }
      return !0;
    }
    if (r && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && Fv(e.lastIntValue))
      return !0;
    r && e.raise("Invalid unicode escape"), e.pos = n;
  }
  return !1;
};
function Fv(e) {
  return e >= 0 && e <= 1114111;
}
J.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, !0) : !1;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
J.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return !0;
  }
  return !1;
};
var im = 0, Cn = 1, wt = 2;
J.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (Ev(t))
    return e.lastIntValue = -1, e.advance(), Cn;
  var n = !1;
  if (e.switchU && this.options.ecmaVersion >= 9 && ((n = t === 80) || t === 112)) {
    e.lastIntValue = -1, e.advance();
    var r;
    if (e.eat(
      123
      /* { */
    ) && (r = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
      125
      /* } */
    ))
      return n && r === wt && e.raise("Invalid property name"), r;
    e.raise("Invalid property name");
  }
  return im;
};
function Ev(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
J.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var n = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var r = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, n, r), Cn;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var i = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, i);
  }
  return im;
};
J.regexp_validateUnicodePropertyNameAndValue = function(e, t, n) {
  Dr(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(n) || e.raise("Invalid property value");
};
J.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  if (e.unicodeProperties.binary.test(t))
    return Cn;
  if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
    return wt;
  e.raise("Invalid property name");
};
J.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; sm(t = e.current()); )
    e.lastStringValue += Mn(t), e.advance();
  return e.lastStringValue !== "";
};
function sm(e) {
  return rm(e) || e === 95;
}
J.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; xv(t = e.current()); )
    e.lastStringValue += Mn(t), e.advance();
  return e.lastStringValue !== "";
};
function xv(e) {
  return sm(e) || Hi(e);
}
J.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
J.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    var t = e.eat(
      94
      /* ^ */
    ), n = this.regexp_classContents(e);
    return e.eat(
      93
      /* ] */
    ) || e.raise("Unterminated character class"), t && n === wt && e.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
J.regexp_classContents = function(e) {
  return e.current() === 93 ? Cn : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Cn);
};
J.regexp_nonEmptyClassRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var n = e.lastIntValue;
      e.switchU && (t === -1 || n === -1) && e.raise("Invalid character class"), t !== -1 && n !== -1 && t > n && e.raise("Range out of order in character class");
    }
  }
};
J.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return !0;
    if (e.switchU) {
      var n = e.current();
      (n === 99 || om(n)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var r = e.current();
  return r !== 93 ? (e.lastIntValue = r, e.advance(), !0) : !1;
};
J.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, !0;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, !0;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return !0;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
J.regexp_classSetExpression = function(e) {
  var t = Cn, n;
  if (!this.regexp_eatClassSetRange(e)) if (n = this.regexp_eatClassSetOperand(e)) {
    n === wt && (t = wt);
    for (var r = e.pos; e.eatChars(
      [38, 38]
      /* && */
    ); ) {
      if (e.current() !== 38 && (n = this.regexp_eatClassSetOperand(e))) {
        n !== wt && (t = Cn);
        continue;
      }
      e.raise("Invalid character in character class");
    }
    if (r !== e.pos)
      return t;
    for (; e.eatChars(
      [45, 45]
      /* -- */
    ); )
      this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
    if (r !== e.pos)
      return t;
  } else
    e.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(e)) {
      if (n = this.regexp_eatClassSetOperand(e), !n)
        return t;
      n === wt && (t = wt);
    }
};
J.regexp_eatClassSetRange = function(e) {
  var t = e.pos;
  if (this.regexp_eatClassSetCharacter(e)) {
    var n = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      return n !== -1 && r !== -1 && n > r && e.raise("Range out of order in character class"), !0;
    }
    e.pos = t;
  }
  return !1;
};
J.regexp_eatClassSetOperand = function(e) {
  return this.regexp_eatClassSetCharacter(e) ? Cn : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
};
J.regexp_eatNestedClass = function(e) {
  var t = e.pos;
  if (e.eat(
    91
    /* [ */
  )) {
    var n = e.eat(
      94
      /* ^ */
    ), r = this.regexp_classContents(e);
    if (e.eat(
      93
      /* ] */
    ))
      return n && r === wt && e.raise("Negated character class may contain strings"), r;
    e.pos = t;
  }
  if (e.eat(
    92
    /* \ */
  )) {
    var i = this.regexp_eatCharacterClassEscape(e);
    if (i)
      return i;
    e.pos = t;
  }
  return null;
};
J.regexp_eatClassStringDisjunction = function(e) {
  var t = e.pos;
  if (e.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (e.eat(
      123
      /* { */
    )) {
      var n = this.regexp_classStringDisjunctionContents(e);
      if (e.eat(
        125
        /* } */
      ))
        return n;
    } else
      e.raise("Invalid escape");
    e.pos = t;
  }
  return null;
};
J.regexp_classStringDisjunctionContents = function(e) {
  for (var t = this.regexp_classString(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_classString(e) === wt && (t = wt);
  return t;
};
J.regexp_classString = function(e) {
  for (var t = 0; this.regexp_eatClassSetCharacter(e); )
    t++;
  return t === 1 ? Cn : wt;
};
J.regexp_eatClassSetCharacter = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
      98
      /* b */
    ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
  var n = e.current();
  return n < 0 || n === e.lookahead() && wv(n) || Sv(n) ? !1 : (e.advance(), e.lastIntValue = n, !0);
};
function wv(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function Sv(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
J.regexp_eatClassSetReservedPunctuator = function(e) {
  var t = e.current();
  return Bv(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function Bv(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
J.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return Hi(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
J.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return !0;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return !1;
};
J.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; Hi(n = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (n - 48), e.advance();
  return e.pos !== t;
};
function Hi(e) {
  return e >= 48 && e <= 57;
}
J.regexp_eatHexDigits = function(e) {
  var t = e.pos, n = 0;
  for (e.lastIntValue = 0; um(n = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + am(n), e.advance();
  return e.pos !== t;
};
function um(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function am(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
J.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var n = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + n * 8 + e.lastIntValue : e.lastIntValue = t * 8 + n;
    } else
      e.lastIntValue = t;
    return !0;
  }
  return !1;
};
J.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return om(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
};
function om(e) {
  return e >= 48 && e <= 55;
}
J.regexp_eatFixedHexDigits = function(e, t) {
  var n = e.pos;
  e.lastIntValue = 0;
  for (var r = 0; r < t; ++r) {
    var i = e.current();
    if (!um(i))
      return e.pos = n, !1;
    e.lastIntValue = 16 * e.lastIntValue + am(i), e.advance();
  }
  return !0;
};
var ca = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new $i(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
}, Ce = Qe.prototype;
Ce.next = function(e) {
  !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ca(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Ce.getToken = function() {
  return this.next(), new ca(this);
};
typeof Symbol < "u" && (Ce[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === A.eof,
        value: t
      };
    }
  };
});
Ce.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(A.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Ce.readToken = function(e) {
  return bn(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
Ce.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 56320)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
};
Ce.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, n = this.input.indexOf("*/", this.pos += 2);
  if (n === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations)
    for (var r = void 0, i = t; (r = _d(this.input, i, this.pos)) > -1; )
      ++this.curLine, i = this.lineStart = r;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(t + 2, n),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
Ce.skipLineComment = function(e) {
  for (var t = this.pos, n = this.options.onComment && this.curPosition(), r = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !Pr(r); )
    r = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    n,
    this.curPosition()
  );
};
Ce.skipSpace = function() {
  e: for (; this.pos < this.input.length; ) {
    var e = this.input.charCodeAt(this.pos);
    switch (e) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if (e > 8 && e < 14 || e >= 5760 && kd.test(String.fromCharCode(e)))
          ++this.pos;
        else
          break e;
    }
  }
};
Ce.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var n = this.type;
  this.type = e, this.value = t, this.updateContext(n);
};
Ce.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(!0);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(A.ellipsis)) : (++this.pos, this.finishToken(A.dot));
};
Ce.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(A.assign, 2) : this.finishOp(A.slash, 1);
};
Ce.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1, r = e === 42 ? A.star : A.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++n, r = A.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(A.assign, n + 1) : this.finishOp(r, n);
};
Ce.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t === e) {
    if (this.options.ecmaVersion >= 12) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n === 61)
        return this.finishOp(A.assign, 3);
    }
    return this.finishOp(e === 124 ? A.logicalOR : A.logicalAND, 2);
  }
  return t === 61 ? this.finishOp(A.assign, 2) : this.finishOp(e === 124 ? A.bitwiseOR : A.bitwiseAND, 1);
};
Ce.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(A.assign, 2) : this.finishOp(A.bitwiseXOR, 1);
};
Ce.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || kt.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(A.incDec, 2) : t === 61 ? this.finishOp(A.assign, 2) : this.finishOp(A.plusMin, 1);
};
Ce.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), n = 1;
  return t === e ? (n = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(A.assign, n + 1) : this.finishOp(A.bitShift, n)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (n = 2), this.finishOp(A.relational, n));
};
Ce.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(A.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(A.arrow)) : this.finishOp(e === 61 ? A.eq : A.prefix, 1);
};
Ce.readToken_question = function() {
  var e = this.options.ecmaVersion;
  if (e >= 11) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === 46) {
      var n = this.input.charCodeAt(this.pos + 2);
      if (n < 48 || n > 57)
        return this.finishOp(A.questionDot, 2);
    }
    if (t === 63) {
      if (e >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(A.assign, 3);
      }
      return this.finishOp(A.coalesce, 2);
    }
  }
  return this.finishOp(A.question, 1);
};
Ce.readToken_numberSign = function() {
  var e = this.options.ecmaVersion, t = 35;
  if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), bn(t, !0) || t === 92))
    return this.finishToken(A.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + Mn(t) + "'");
};
Ce.getTokenFromCode = function(e) {
  switch (e) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      return ++this.pos, this.finishToken(A.parenL);
    case 41:
      return ++this.pos, this.finishToken(A.parenR);
    case 59:
      return ++this.pos, this.finishToken(A.semi);
    case 44:
      return ++this.pos, this.finishToken(A.comma);
    case 91:
      return ++this.pos, this.finishToken(A.bracketL);
    case 93:
      return ++this.pos, this.finishToken(A.bracketR);
    case 123:
      return ++this.pos, this.finishToken(A.braceL);
    case 125:
      return ++this.pos, this.finishToken(A.braceR);
    case 58:
      return ++this.pos, this.finishToken(A.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(A.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(e);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(A.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + Mn(e) + "'");
};
Ce.finishOp = function(e, t) {
  var n = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, n);
};
Ce.readRegexp = function() {
  for (var e, t, n = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
    var r = this.input.charAt(this.pos);
    if (kt.test(r) && this.raise(n, "Unterminated regular expression"), e)
      e = !1;
    else {
      if (r === "[")
        t = !0;
      else if (r === "]" && t)
        t = !1;
      else if (r === "/" && !t)
        break;
      e = r === "\\";
    }
    ++this.pos;
  }
  var i = this.input.slice(n, this.pos);
  ++this.pos;
  var s = this.pos, u = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var a = this.regexpState || (this.regexpState = new rn(this));
  a.reset(n, i, u), this.validateRegExpFlags(a), this.validateRegExpPattern(a);
  var o = null;
  try {
    o = new RegExp(i, u);
  } catch {
  }
  return this.finishToken(A.regexp, { pattern: i, flags: u, value: o });
};
Ce.readInt = function(e, t, n) {
  for (var r = this.options.ecmaVersion >= 12 && t === void 0, i = n && this.input.charCodeAt(this.pos) === 48, s = this.pos, u = 0, a = 0, o = 0, f = t ?? 1 / 0; o < f; ++o, ++this.pos) {
    var h = this.input.charCodeAt(this.pos), m = void 0;
    if (r && h === 95) {
      i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), a === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), o === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), a = h;
      continue;
    }
    if (h >= 97 ? m = h - 97 + 10 : h >= 65 ? m = h - 65 + 10 : h >= 48 && h <= 57 ? m = h - 48 : m = 1 / 0, m >= e)
      break;
    a = h, u = u * e + m;
  }
  return r && a === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === s || t != null && this.pos - s !== t ? null : u;
};
function _v(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function cm(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
Ce.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var n = this.readInt(e);
  return n == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (n = cm(this.input.slice(t, this.pos)), ++this.pos) : bn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(A.num, n);
};
Ce.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
  var n = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  n && this.strict && this.raise(t, "Invalid number");
  var r = this.input.charCodeAt(this.pos);
  if (!n && !e && this.options.ecmaVersion >= 11 && r === 110) {
    var i = cm(this.input.slice(t, this.pos));
    return ++this.pos, bn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(A.num, i);
  }
  n && /[89]/.test(this.input.slice(t, this.pos)) && (n = !1), r === 46 && !n && (++this.pos, this.readInt(10), r = this.input.charCodeAt(this.pos)), (r === 69 || r === 101) && !n && (r = this.input.charCodeAt(++this.pos), (r === 43 || r === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), bn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = _v(this.input.slice(t, this.pos), n);
  return this.finishToken(A.num, s);
};
Ce.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var n = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(n, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
Ce.readString = function(e) {
  for (var t = "", n = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var r = this.input.charCodeAt(this.pos);
    if (r === e)
      break;
    r === 92 ? (t += this.input.slice(n, this.pos), t += this.readEscapedChar(!1), n = this.pos) : r === 8232 || r === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Pr(r) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(n, this.pos++), this.finishToken(A.string, t);
};
var lm = {};
Ce.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === lm)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = !1;
};
Ce.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw lm;
  this.raise(e, t);
};
Ce.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var n = this.input.charCodeAt(this.pos);
    if (n === 96 || n === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === A.template || this.type === A.invalidTemplate) ? n === 36 ? (this.pos += 2, this.finishToken(A.dollarBraceL)) : (++this.pos, this.finishToken(A.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(A.template, e));
    if (n === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
    else if (Pr(n)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, n) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(n);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
Ce.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      // fall through
      case "`":
        return this.finishToken(A.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        this.input[this.pos + 1] === `
` && ++this.pos;
      // fall through
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine, this.lineStart = this.pos + 1;
        break;
    }
  this.raise(this.start, "Unterminated template");
};
Ce.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return Mn(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    // '\r\n'
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), e) {
        var n = this.pos - 1;
        this.invalidStringToken(
          n,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8);
        return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(i);
      }
      return Pr(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
  }
};
Ce.readHexChar = function(e) {
  var t = this.pos, n = this.readInt(16, e);
  return n === null && this.invalidStringToken(t, "Bad character escape sequence"), n;
};
Ce.readWord1 = function() {
  this.containsEsc = !1;
  for (var e = "", t = !0, n = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var i = this.fullCharCodeAtPos();
    if (gr(i, r))
      this.pos += i <= 65535 ? 1 : 2;
    else if (i === 92) {
      this.containsEsc = !0, e += this.input.slice(n, this.pos);
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var u = this.readCodePoint();
      (t ? bn : gr)(u, r) || this.invalidStringToken(s, "Invalid Unicode escape"), e += Mn(u), n = this.pos;
    } else
      break;
    t = !1;
  }
  return e + this.input.slice(n, this.pos);
};
Ce.readWord = function() {
  var e = this.readWord1(), t = A.name;
  return this.keywords.test(e) && (t = na[e]), this.finishToken(t, e);
};
var kv = "8.14.0";
Qe.acorn = {
  Parser: Qe,
  version: kv,
  defaultOptions: cu,
  Position: Yr,
  SourceLocation: $i,
  getLineInfo: Vd,
  Node: Ki,
  TokenType: Ee,
  tokTypes: A,
  keywordTypes: na,
  TokContext: Xt,
  tokContexts: Ze,
  isIdentifierChar: gr,
  isIdentifierStart: bn,
  Token: ca,
  isNewLine: Pr,
  lineBreak: kt,
  lineBreakG: ev,
  nonASCIIwhitespace: kd
};
function Iv(e, t) {
  return Qe.parse(e, t);
}
var Vv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Nv(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var Bs = {}, _s = {}, Ao;
function Tv() {
  return Ao || (Ao = 1, function(e) {
    (function t(n) {
      var r, i, s, u, a, o;
      function f(x) {
        var B = {}, k, V;
        for (k in x)
          x.hasOwnProperty(k) && (V = x[k], typeof V == "object" && V !== null ? B[k] = f(V) : B[k] = V);
        return B;
      }
      function h(x, B) {
        var k, V, q, G;
        for (V = x.length, q = 0; V; )
          k = V >>> 1, G = q + k, B(x[G]) ? V = k : (q = G + 1, V -= k + 1);
        return q;
      }
      r = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, s = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, u = {}, a = {}, o = {}, i = {
        Break: u,
        Skip: a,
        Remove: o
      };
      function m(x, B) {
        this.parent = x, this.key = B;
      }
      m.prototype.replace = function(B) {
        this.parent[this.key] = B;
      }, m.prototype.remove = function() {
        return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
      };
      function p(x, B, k, V) {
        this.node = x, this.path = B, this.wrap = k, this.ref = V;
      }
      function b() {
      }
      b.prototype.path = function() {
        var B, k, V, q, G, Y;
        function W(O, te) {
          if (Array.isArray(te))
            for (V = 0, q = te.length; V < q; ++V)
              O.push(te[V]);
          else
            O.push(te);
        }
        if (!this.__current.path)
          return null;
        for (G = [], B = 2, k = this.__leavelist.length; B < k; ++B)
          Y = this.__leavelist[B], W(G, Y.path);
        return W(G, this.__current.path), G;
      }, b.prototype.type = function() {
        var x = this.current();
        return x.type || this.__current.wrap;
      }, b.prototype.parents = function() {
        var B, k, V;
        for (V = [], B = 1, k = this.__leavelist.length; B < k; ++B)
          V.push(this.__leavelist[B].node);
        return V;
      }, b.prototype.current = function() {
        return this.__current.node;
      }, b.prototype.__execute = function(B, k) {
        var V, q;
        return q = void 0, V = this.__current, this.__current = k, this.__state = null, B && (q = B.call(this, k.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = V, q;
      }, b.prototype.notify = function(B) {
        this.__state = B;
      }, b.prototype.skip = function() {
        this.notify(a);
      }, b.prototype.break = function() {
        this.notify(u);
      }, b.prototype.remove = function() {
        this.notify(o);
      }, b.prototype.__initialize = function(x, B) {
        this.visitor = B, this.root = x, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, B.fallback === "iteration" ? this.__fallback = Object.keys : typeof B.fallback == "function" && (this.__fallback = B.fallback), this.__keys = s, B.keys && (this.__keys = Object.assign(Object.create(this.__keys), B.keys));
      };
      function M(x) {
        return x == null ? !1 : typeof x == "object" && typeof x.type == "string";
      }
      function v(x, B) {
        return (x === r.ObjectExpression || x === r.ObjectPattern) && B === "properties";
      }
      function E(x, B) {
        for (var k = x.length - 1; k >= 0; --k)
          if (x[k].node === B)
            return !0;
        return !1;
      }
      b.prototype.traverse = function(B, k) {
        var V, q, G, Y, W, O, te, Ae, pe, fe, Q, ke;
        for (this.__initialize(B, k), ke = {}, V = this.__worklist, q = this.__leavelist, V.push(new p(B, null, null, null)), q.push(new p(null, null, null, null)); V.length; ) {
          if (G = V.pop(), G === ke) {
            if (G = q.pop(), O = this.__execute(k.leave, G), this.__state === u || O === u)
              return;
            continue;
          }
          if (G.node) {
            if (O = this.__execute(k.enter, G), this.__state === u || O === u)
              return;
            if (V.push(ke), q.push(G), this.__state === a || O === a)
              continue;
            if (Y = G.node, W = Y.type || G.wrap, fe = this.__keys[W], !fe)
              if (this.__fallback)
                fe = this.__fallback(Y);
              else
                throw new Error("Unknown node type " + W + ".");
            for (Ae = fe.length; (Ae -= 1) >= 0; )
              if (te = fe[Ae], Q = Y[te], !!Q) {
                if (Array.isArray(Q)) {
                  for (pe = Q.length; (pe -= 1) >= 0; )
                    if (Q[pe] && !E(q, Q[pe])) {
                      if (v(W, fe[Ae]))
                        G = new p(Q[pe], [te, pe], "Property", null);
                      else if (M(Q[pe]))
                        G = new p(Q[pe], [te, pe], null, null);
                      else
                        continue;
                      V.push(G);
                    }
                } else if (M(Q)) {
                  if (E(q, Q))
                    continue;
                  V.push(new p(Q, te, null, null));
                }
              }
          }
        }
      }, b.prototype.replace = function(B, k) {
        var V, q, G, Y, W, O, te, Ae, pe, fe, Q, ke, oe;
        function ge($) {
          var ve, st, je, be;
          if ($.ref.remove()) {
            for (st = $.ref.key, be = $.ref.parent, ve = V.length; ve--; )
              if (je = V[ve], je.ref && je.ref.parent === be) {
                if (je.ref.key < st)
                  break;
                --je.ref.key;
              }
          }
        }
        for (this.__initialize(B, k), Q = {}, V = this.__worklist, q = this.__leavelist, ke = {
          root: B
        }, O = new p(B, null, null, new m(ke, "root")), V.push(O), q.push(O); V.length; ) {
          if (O = V.pop(), O === Q) {
            if (O = q.pop(), W = this.__execute(k.leave, O), W !== void 0 && W !== u && W !== a && W !== o && O.ref.replace(W), (this.__state === o || W === o) && ge(O), this.__state === u || W === u)
              return ke.root;
            continue;
          }
          if (W = this.__execute(k.enter, O), W !== void 0 && W !== u && W !== a && W !== o && (O.ref.replace(W), O.node = W), (this.__state === o || W === o) && (ge(O), O.node = null), this.__state === u || W === u)
            return ke.root;
          if (G = O.node, !!G && (V.push(Q), q.push(O), !(this.__state === a || W === a))) {
            if (Y = G.type || O.wrap, pe = this.__keys[Y], !pe)
              if (this.__fallback)
                pe = this.__fallback(G);
              else
                throw new Error("Unknown node type " + Y + ".");
            for (te = pe.length; (te -= 1) >= 0; )
              if (oe = pe[te], fe = G[oe], !!fe)
                if (Array.isArray(fe)) {
                  for (Ae = fe.length; (Ae -= 1) >= 0; )
                    if (fe[Ae]) {
                      if (v(Y, pe[te]))
                        O = new p(fe[Ae], [oe, Ae], "Property", new m(fe, Ae));
                      else if (M(fe[Ae]))
                        O = new p(fe[Ae], [oe, Ae], null, new m(fe, Ae));
                      else
                        continue;
                      V.push(O);
                    }
                } else M(fe) && V.push(new p(fe, oe, null, new m(G, oe)));
          }
        }
        return ke.root;
      };
      function I(x, B) {
        var k = new b();
        return k.traverse(x, B);
      }
      function _(x, B) {
        var k = new b();
        return k.replace(x, B);
      }
      function X(x, B) {
        var k;
        return k = h(B, function(q) {
          return q.range[0] > x.range[0];
        }), x.extendedRange = [x.range[0], x.range[1]], k !== B.length && (x.extendedRange[1] = B[k].range[0]), k -= 1, k >= 0 && (x.extendedRange[0] = B[k].range[1]), x;
      }
      function S(x, B, k) {
        var V = [], q, G, Y, W;
        if (!x.range)
          throw new Error("attachComments needs range information");
        if (!k.length) {
          if (B.length) {
            for (Y = 0, G = B.length; Y < G; Y += 1)
              q = f(B[Y]), q.extendedRange = [0, x.range[0]], V.push(q);
            x.leadingComments = V;
          }
          return x;
        }
        for (Y = 0, G = B.length; Y < G; Y += 1)
          V.push(X(f(B[Y]), k));
        return W = 0, I(x, {
          enter: function(O) {
            for (var te; W < V.length && (te = V[W], !(te.extendedRange[1] > O.range[0])); )
              te.extendedRange[1] === O.range[0] ? (O.leadingComments || (O.leadingComments = []), O.leadingComments.push(te), V.splice(W, 1)) : W += 1;
            if (W === V.length)
              return i.Break;
            if (V[W].extendedRange[0] > O.range[1])
              return i.Skip;
          }
        }), W = 0, I(x, {
          leave: function(O) {
            for (var te; W < V.length && (te = V[W], !(O.range[1] < te.extendedRange[0])); )
              O.range[1] === te.extendedRange[0] ? (O.trailingComments || (O.trailingComments = []), O.trailingComments.push(te), V.splice(W, 1)) : W += 1;
            if (W === V.length)
              return i.Break;
            if (V[W].extendedRange[0] > O.range[1])
              return i.Skip;
          }
        }), x;
      }
      return n.Syntax = r, n.traverse = I, n.replace = _, n.attachComments = S, n.VisitorKeys = s, n.VisitorOption = i, n.Controller = b, n.cloneEnvironment = function() {
        return t({});
      }, n;
    })(e);
  }(_s)), _s;
}
var Rr = {}, ks = { exports: {} }, bo;
function Rv() {
  return bo || (bo = 1, function() {
    function e(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return !0;
      }
      return !1;
    }
    function t(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return !0;
      }
      return !1;
    }
    function n(u) {
      if (u == null)
        return !1;
      switch (u.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return !0;
      }
      return !1;
    }
    function r(u) {
      return n(u) || u != null && u.type === "FunctionDeclaration";
    }
    function i(u) {
      switch (u.type) {
        case "IfStatement":
          return u.alternate != null ? u.alternate : u.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return u.body;
      }
      return null;
    }
    function s(u) {
      var a;
      if (u.type !== "IfStatement" || u.alternate == null)
        return !1;
      a = u.consequent;
      do {
        if (a.type === "IfStatement" && a.alternate == null)
          return !0;
        a = i(a);
      } while (a);
      return !1;
    }
    ks.exports = {
      isExpression: e,
      isStatement: n,
      isIterationStatement: t,
      isSourceElement: r,
      isProblematicIfStatement: s,
      trailingStatement: i
    };
  }()), ks.exports;
}
var Is = { exports: {} }, Mo;
function hm() {
  return Mo || (Mo = 1, function() {
    var e, t, n, r, i, s;
    t = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, e = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function u(E) {
      return 48 <= E && E <= 57;
    }
    function a(E) {
      return 48 <= E && E <= 57 || // 0..9
      97 <= E && E <= 102 || // a..f
      65 <= E && E <= 70;
    }
    function o(E) {
      return E >= 48 && E <= 55;
    }
    n = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function f(E) {
      return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && n.indexOf(E) >= 0;
    }
    function h(E) {
      return E === 10 || E === 13 || E === 8232 || E === 8233;
    }
    function m(E) {
      if (E <= 65535)
        return String.fromCharCode(E);
      var I = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), _ = String.fromCharCode((E - 65536) % 1024 + 56320);
      return I + _;
    }
    for (r = new Array(128), s = 0; s < 128; ++s)
      r[s] = s >= 97 && s <= 122 || // a..z
      s >= 65 && s <= 90 || // A..Z
      s === 36 || s === 95;
    for (i = new Array(128), s = 0; s < 128; ++s)
      i[s] = s >= 97 && s <= 122 || // a..z
      s >= 65 && s <= 90 || // A..Z
      s >= 48 && s <= 57 || // 0..9
      s === 36 || s === 95;
    function p(E) {
      return E < 128 ? r[E] : t.NonAsciiIdentifierStart.test(m(E));
    }
    function b(E) {
      return E < 128 ? i[E] : t.NonAsciiIdentifierPart.test(m(E));
    }
    function M(E) {
      return E < 128 ? r[E] : e.NonAsciiIdentifierStart.test(m(E));
    }
    function v(E) {
      return E < 128 ? i[E] : e.NonAsciiIdentifierPart.test(m(E));
    }
    Is.exports = {
      isDecimalDigit: u,
      isHexDigit: a,
      isOctalDigit: o,
      isWhiteSpace: f,
      isLineTerminator: h,
      isIdentifierStartES5: p,
      isIdentifierPartES5: b,
      isIdentifierStartES6: M,
      isIdentifierPartES6: v
    };
  }()), Is.exports;
}
var Vs = { exports: {} }, Co;
function Lv() {
  return Co || (Co = 1, function() {
    var e = hm();
    function t(p) {
      switch (p) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return !0;
        default:
          return !1;
      }
    }
    function n(p, b) {
      return !b && p === "yield" ? !1 : r(p, b);
    }
    function r(p, b) {
      if (b && t(p))
        return !0;
      switch (p.length) {
        case 2:
          return p === "if" || p === "in" || p === "do";
        case 3:
          return p === "var" || p === "for" || p === "new" || p === "try";
        case 4:
          return p === "this" || p === "else" || p === "case" || p === "void" || p === "with" || p === "enum";
        case 5:
          return p === "while" || p === "break" || p === "catch" || p === "throw" || p === "const" || p === "yield" || p === "class" || p === "super";
        case 6:
          return p === "return" || p === "typeof" || p === "delete" || p === "switch" || p === "export" || p === "import";
        case 7:
          return p === "default" || p === "finally" || p === "extends";
        case 8:
          return p === "function" || p === "continue" || p === "debugger";
        case 10:
          return p === "instanceof";
        default:
          return !1;
      }
    }
    function i(p, b) {
      return p === "null" || p === "true" || p === "false" || n(p, b);
    }
    function s(p, b) {
      return p === "null" || p === "true" || p === "false" || r(p, b);
    }
    function u(p) {
      return p === "eval" || p === "arguments";
    }
    function a(p) {
      var b, M, v;
      if (p.length === 0 || (v = p.charCodeAt(0), !e.isIdentifierStartES5(v)))
        return !1;
      for (b = 1, M = p.length; b < M; ++b)
        if (v = p.charCodeAt(b), !e.isIdentifierPartES5(v))
          return !1;
      return !0;
    }
    function o(p, b) {
      return (p - 55296) * 1024 + (b - 56320) + 65536;
    }
    function f(p) {
      var b, M, v, E, I;
      if (p.length === 0)
        return !1;
      for (I = e.isIdentifierStartES6, b = 0, M = p.length; b < M; ++b) {
        if (v = p.charCodeAt(b), 55296 <= v && v <= 56319) {
          if (++b, b >= M || (E = p.charCodeAt(b), !(56320 <= E && E <= 57343)))
            return !1;
          v = o(v, E);
        }
        if (!I(v))
          return !1;
        I = e.isIdentifierPartES6;
      }
      return !0;
    }
    function h(p, b) {
      return a(p) && !i(p, b);
    }
    function m(p, b) {
      return f(p) && !s(p, b);
    }
    Vs.exports = {
      isKeywordES5: n,
      isKeywordES6: r,
      isReservedWordES5: i,
      isReservedWordES6: s,
      isRestrictedWord: u,
      isIdentifierNameES5: a,
      isIdentifierNameES6: f,
      isIdentifierES5: h,
      isIdentifierES6: m
    };
  }()), Vs.exports;
}
var vo;
function Gv() {
  return vo || (vo = 1, function() {
    Rr.ast = Rv(), Rr.code = hm(), Rr.keyword = Lv();
  }()), Rr;
}
var Lr = {}, Ns = {}, yi = {}, Ai = {}, Po;
function Xv() {
  if (Po) return Ai;
  Po = 1;
  var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Ai.encode = function(t) {
    if (0 <= t && t < e.length)
      return e[t];
    throw new TypeError("Must be between 0 and 63: " + t);
  }, Ai.decode = function(t) {
    var n = 65, r = 90, i = 97, s = 122, u = 48, a = 57, o = 43, f = 47, h = 26, m = 52;
    return n <= t && t <= r ? t - n : i <= t && t <= s ? t - i + h : u <= t && t <= a ? t - u + m : t == o ? 62 : t == f ? 63 : -1;
  }, Ai;
}
var Do;
function pm() {
  if (Do) return yi;
  Do = 1;
  var e = Xv(), t = 5, n = 1 << t, r = n - 1, i = n;
  function s(a) {
    return a < 0 ? (-a << 1) + 1 : (a << 1) + 0;
  }
  function u(a) {
    var o = (a & 1) === 1, f = a >> 1;
    return o ? -f : f;
  }
  return yi.encode = function(o) {
    var f = "", h, m = s(o);
    do
      h = m & r, m >>>= t, m > 0 && (h |= i), f += e.encode(h);
    while (m > 0);
    return f;
  }, yi.decode = function(o, f, h) {
    var m = o.length, p = 0, b = 0, M, v;
    do {
      if (f >= m)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (v = e.decode(o.charCodeAt(f++)), v === -1)
        throw new Error("Invalid base64 digit: " + o.charAt(f - 1));
      M = !!(v & i), v &= r, p = p + (v << b), b += t;
    } while (M);
    h.value = u(p), h.rest = f;
  }, yi;
}
var Ts = {}, Fo;
function si() {
  return Fo || (Fo = 1, function(e) {
    function t(S, x, B) {
      if (x in S)
        return S[x];
      if (arguments.length === 3)
        return B;
      throw new Error('"' + x + '" is a required argument.');
    }
    e.getArg = t;
    var n = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r = /^data:.+\,.+$/;
    function i(S) {
      var x = S.match(n);
      return x ? {
        scheme: x[1],
        auth: x[2],
        host: x[3],
        port: x[4],
        path: x[5]
      } : null;
    }
    e.urlParse = i;
    function s(S) {
      var x = "";
      return S.scheme && (x += S.scheme + ":"), x += "//", S.auth && (x += S.auth + "@"), S.host && (x += S.host), S.port && (x += ":" + S.port), S.path && (x += S.path), x;
    }
    e.urlGenerate = s;
    function u(S) {
      var x = S, B = i(S);
      if (B) {
        if (!B.path)
          return S;
        x = B.path;
      }
      for (var k = e.isAbsolute(x), V = x.split(/\/+/), q, G = 0, Y = V.length - 1; Y >= 0; Y--)
        q = V[Y], q === "." ? V.splice(Y, 1) : q === ".." ? G++ : G > 0 && (q === "" ? (V.splice(Y + 1, G), G = 0) : (V.splice(Y, 2), G--));
      return x = V.join("/"), x === "" && (x = k ? "/" : "."), B ? (B.path = x, s(B)) : x;
    }
    e.normalize = u;
    function a(S, x) {
      S === "" && (S = "."), x === "" && (x = ".");
      var B = i(x), k = i(S);
      if (k && (S = k.path || "/"), B && !B.scheme)
        return k && (B.scheme = k.scheme), s(B);
      if (B || x.match(r))
        return x;
      if (k && !k.host && !k.path)
        return k.host = x, s(k);
      var V = x.charAt(0) === "/" ? x : u(S.replace(/\/+$/, "") + "/" + x);
      return k ? (k.path = V, s(k)) : V;
    }
    e.join = a, e.isAbsolute = function(S) {
      return S.charAt(0) === "/" || n.test(S);
    };
    function o(S, x) {
      S === "" && (S = "."), S = S.replace(/\/$/, "");
      for (var B = 0; x.indexOf(S + "/") !== 0; ) {
        var k = S.lastIndexOf("/");
        if (k < 0 || (S = S.slice(0, k), S.match(/^([^\/]+:\/)?\/*$/)))
          return x;
        ++B;
      }
      return Array(B + 1).join("../") + x.substr(S.length + 1);
    }
    e.relative = o;
    var f = function() {
      var S = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in S);
    }();
    function h(S) {
      return S;
    }
    function m(S) {
      return b(S) ? "$" + S : S;
    }
    e.toSetString = f ? h : m;
    function p(S) {
      return b(S) ? S.slice(1) : S;
    }
    e.fromSetString = f ? h : p;
    function b(S) {
      if (!S)
        return !1;
      var x = S.length;
      if (x < 9 || S.charCodeAt(x - 1) !== 95 || S.charCodeAt(x - 2) !== 95 || S.charCodeAt(x - 3) !== 111 || S.charCodeAt(x - 4) !== 116 || S.charCodeAt(x - 5) !== 111 || S.charCodeAt(x - 6) !== 114 || S.charCodeAt(x - 7) !== 112 || S.charCodeAt(x - 8) !== 95 || S.charCodeAt(x - 9) !== 95)
        return !1;
      for (var B = x - 10; B >= 0; B--)
        if (S.charCodeAt(B) !== 36)
          return !1;
      return !0;
    }
    function M(S, x, B) {
      var k = E(S.source, x.source);
      return k !== 0 || (k = S.originalLine - x.originalLine, k !== 0) || (k = S.originalColumn - x.originalColumn, k !== 0 || B) || (k = S.generatedColumn - x.generatedColumn, k !== 0) || (k = S.generatedLine - x.generatedLine, k !== 0) ? k : E(S.name, x.name);
    }
    e.compareByOriginalPositions = M;
    function v(S, x, B) {
      var k = S.generatedLine - x.generatedLine;
      return k !== 0 || (k = S.generatedColumn - x.generatedColumn, k !== 0 || B) || (k = E(S.source, x.source), k !== 0) || (k = S.originalLine - x.originalLine, k !== 0) || (k = S.originalColumn - x.originalColumn, k !== 0) ? k : E(S.name, x.name);
    }
    e.compareByGeneratedPositionsDeflated = v;
    function E(S, x) {
      return S === x ? 0 : S === null ? 1 : x === null ? -1 : S > x ? 1 : -1;
    }
    function I(S, x) {
      var B = S.generatedLine - x.generatedLine;
      return B !== 0 || (B = S.generatedColumn - x.generatedColumn, B !== 0) || (B = E(S.source, x.source), B !== 0) || (B = S.originalLine - x.originalLine, B !== 0) || (B = S.originalColumn - x.originalColumn, B !== 0) ? B : E(S.name, x.name);
    }
    e.compareByGeneratedPositionsInflated = I;
    function _(S) {
      return JSON.parse(S.replace(/^\)]}'[^\n]*\n/, ""));
    }
    e.parseSourceMapInput = _;
    function X(S, x, B) {
      if (x = x || "", S && (S[S.length - 1] !== "/" && x[0] !== "/" && (S += "/"), x = S + x), B) {
        var k = i(B);
        if (!k)
          throw new Error("sourceMapURL could not be parsed");
        if (k.path) {
          var V = k.path.lastIndexOf("/");
          V >= 0 && (k.path = k.path.substring(0, V + 1));
        }
        x = a(s(k), x);
      }
      return u(x);
    }
    e.computeSourceURL = X;
  }(Ts)), Ts;
}
var Rs = {}, Eo;
function dm() {
  if (Eo) return Rs;
  Eo = 1;
  var e = si(), t = Object.prototype.hasOwnProperty, n = typeof Map < "u";
  function r() {
    this._array = [], this._set = n ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return r.fromArray = function(s, u) {
    for (var a = new r(), o = 0, f = s.length; o < f; o++)
      a.add(s[o], u);
    return a;
  }, r.prototype.size = function() {
    return n ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, r.prototype.add = function(s, u) {
    var a = n ? s : e.toSetString(s), o = n ? this.has(s) : t.call(this._set, a), f = this._array.length;
    (!o || u) && this._array.push(s), o || (n ? this._set.set(s, f) : this._set[a] = f);
  }, r.prototype.has = function(s) {
    if (n)
      return this._set.has(s);
    var u = e.toSetString(s);
    return t.call(this._set, u);
  }, r.prototype.indexOf = function(s) {
    if (n) {
      var u = this._set.get(s);
      if (u >= 0)
        return u;
    } else {
      var a = e.toSetString(s);
      if (t.call(this._set, a))
        return this._set[a];
    }
    throw new Error('"' + s + '" is not in the set.');
  }, r.prototype.at = function(s) {
    if (s >= 0 && s < this._array.length)
      return this._array[s];
    throw new Error("No element indexed by " + s);
  }, r.prototype.toArray = function() {
    return this._array.slice();
  }, Rs.ArraySet = r, Rs;
}
var Ls = {}, xo;
function Zv() {
  if (xo) return Ls;
  xo = 1;
  var e = si();
  function t(r, i) {
    var s = r.generatedLine, u = i.generatedLine, a = r.generatedColumn, o = i.generatedColumn;
    return u > s || u == s && o >= a || e.compareByGeneratedPositionsInflated(r, i) <= 0;
  }
  function n() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return n.prototype.unsortedForEach = function(i, s) {
    this._array.forEach(i, s);
  }, n.prototype.add = function(i) {
    t(this._last, i) ? (this._last = i, this._array.push(i)) : (this._sorted = !1, this._array.push(i));
  }, n.prototype.toArray = function() {
    return this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, Ls.MappingList = n, Ls;
}
var wo;
function mm() {
  if (wo) return Ns;
  wo = 1;
  var e = pm(), t = si(), n = dm().ArraySet, r = Zv().MappingList;
  function i(s) {
    s || (s = {}), this._file = t.getArg(s, "file", null), this._sourceRoot = t.getArg(s, "sourceRoot", null), this._skipValidation = t.getArg(s, "skipValidation", !1), this._sources = new n(), this._names = new n(), this._mappings = new r(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(u) {
    var a = u.sourceRoot, o = new i({
      file: u.file,
      sourceRoot: a
    });
    return u.eachMapping(function(f) {
      var h = {
        generated: {
          line: f.generatedLine,
          column: f.generatedColumn
        }
      };
      f.source != null && (h.source = f.source, a != null && (h.source = t.relative(a, h.source)), h.original = {
        line: f.originalLine,
        column: f.originalColumn
      }, f.name != null && (h.name = f.name)), o.addMapping(h);
    }), u.sources.forEach(function(f) {
      var h = f;
      a !== null && (h = t.relative(a, f)), o._sources.has(h) || o._sources.add(h);
      var m = u.sourceContentFor(f);
      m != null && o.setSourceContent(f, m);
    }), o;
  }, i.prototype.addMapping = function(u) {
    var a = t.getArg(u, "generated"), o = t.getArg(u, "original", null), f = t.getArg(u, "source", null), h = t.getArg(u, "name", null);
    this._skipValidation || this._validateMapping(a, o, f, h), f != null && (f = String(f), this._sources.has(f) || this._sources.add(f)), h != null && (h = String(h), this._names.has(h) || this._names.add(h)), this._mappings.add({
      generatedLine: a.line,
      generatedColumn: a.column,
      originalLine: o != null && o.line,
      originalColumn: o != null && o.column,
      source: f,
      name: h
    });
  }, i.prototype.setSourceContent = function(u, a) {
    var o = u;
    this._sourceRoot != null && (o = t.relative(this._sourceRoot, o)), a != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[t.toSetString(o)] = a) : this._sourcesContents && (delete this._sourcesContents[t.toSetString(o)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(u, a, o) {
    var f = a;
    if (a == null) {
      if (u.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      f = u.file;
    }
    var h = this._sourceRoot;
    h != null && (f = t.relative(h, f));
    var m = new n(), p = new n();
    this._mappings.unsortedForEach(function(b) {
      if (b.source === f && b.originalLine != null) {
        var M = u.originalPositionFor({
          line: b.originalLine,
          column: b.originalColumn
        });
        M.source != null && (b.source = M.source, o != null && (b.source = t.join(o, b.source)), h != null && (b.source = t.relative(h, b.source)), b.originalLine = M.line, b.originalColumn = M.column, M.name != null && (b.name = M.name));
      }
      var v = b.source;
      v != null && !m.has(v) && m.add(v);
      var E = b.name;
      E != null && !p.has(E) && p.add(E);
    }, this), this._sources = m, this._names = p, u.sources.forEach(function(b) {
      var M = u.sourceContentFor(b);
      M != null && (o != null && (b = t.join(o, b)), h != null && (b = t.relative(h, b)), this.setSourceContent(b, M));
    }, this);
  }, i.prototype._validateMapping = function(u, a, o, f) {
    if (a && typeof a.line != "number" && typeof a.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(u && "line" in u && "column" in u && u.line > 0 && u.column >= 0 && !a && !o && !f)) {
      if (u && "line" in u && "column" in u && a && "line" in a && "column" in a && u.line > 0 && u.column >= 0 && a.line > 0 && a.column >= 0 && o)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: u,
        source: o,
        original: a,
        name: f
      }));
    }
  }, i.prototype._serializeMappings = function() {
    for (var u = 0, a = 1, o = 0, f = 0, h = 0, m = 0, p = "", b, M, v, E, I = this._mappings.toArray(), _ = 0, X = I.length; _ < X; _++) {
      if (M = I[_], b = "", M.generatedLine !== a)
        for (u = 0; M.generatedLine !== a; )
          b += ";", a++;
      else if (_ > 0) {
        if (!t.compareByGeneratedPositionsInflated(M, I[_ - 1]))
          continue;
        b += ",";
      }
      b += e.encode(M.generatedColumn - u), u = M.generatedColumn, M.source != null && (E = this._sources.indexOf(M.source), b += e.encode(E - m), m = E, b += e.encode(M.originalLine - 1 - f), f = M.originalLine - 1, b += e.encode(M.originalColumn - o), o = M.originalColumn, M.name != null && (v = this._names.indexOf(M.name), b += e.encode(v - h), h = v)), p += b;
    }
    return p;
  }, i.prototype._generateSourcesContent = function(u, a) {
    return u.map(function(o) {
      if (!this._sourcesContents)
        return null;
      a != null && (o = t.relative(a, o));
      var f = t.toSetString(o);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, f) ? this._sourcesContents[f] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var u = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (u.file = this._file), this._sourceRoot != null && (u.sourceRoot = this._sourceRoot), this._sourcesContents && (u.sourcesContent = this._generateSourcesContent(u.sources, u.sourceRoot)), u;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Ns.SourceMapGenerator = i, Ns;
}
var Gr = {}, Gs = {}, So;
function Wv() {
  return So || (So = 1, function(e) {
    e.GREATEST_LOWER_BOUND = 1, e.LEAST_UPPER_BOUND = 2;
    function t(n, r, i, s, u, a) {
      var o = Math.floor((r - n) / 2) + n, f = u(i, s[o], !0);
      return f === 0 ? o : f > 0 ? r - o > 1 ? t(o, r, i, s, u, a) : a == e.LEAST_UPPER_BOUND ? r < s.length ? r : -1 : o : o - n > 1 ? t(n, o, i, s, u, a) : a == e.LEAST_UPPER_BOUND ? o : n < 0 ? -1 : n;
    }
    e.search = function(r, i, s, u) {
      if (i.length === 0)
        return -1;
      var a = t(
        -1,
        i.length,
        r,
        i,
        s,
        u || e.GREATEST_LOWER_BOUND
      );
      if (a < 0)
        return -1;
      for (; a - 1 >= 0 && s(i[a], i[a - 1], !0) === 0; )
        --a;
      return a;
    };
  }(Gs)), Gs;
}
var Xs = {}, Bo;
function Ov() {
  if (Bo) return Xs;
  Bo = 1;
  function e(r, i, s) {
    var u = r[i];
    r[i] = r[s], r[s] = u;
  }
  function t(r, i) {
    return Math.round(r + Math.random() * (i - r));
  }
  function n(r, i, s, u) {
    if (s < u) {
      var a = t(s, u), o = s - 1;
      e(r, a, u);
      for (var f = r[u], h = s; h < u; h++)
        i(r[h], f) <= 0 && (o += 1, e(r, o, h));
      e(r, o + 1, h);
      var m = o + 1;
      n(r, i, s, m - 1), n(r, i, m + 1, u);
    }
  }
  return Xs.quickSort = function(r, i) {
    n(r, i, 0, r.length - 1);
  }, Xs;
}
var _o;
function zv() {
  if (_o) return Gr;
  _o = 1;
  var e = si(), t = Wv(), n = dm().ArraySet, r = pm(), i = Ov().quickSort;
  function s(f, h) {
    var m = f;
    return typeof f == "string" && (m = e.parseSourceMapInput(f)), m.sections != null ? new o(m, h) : new u(m, h);
  }
  s.fromSourceMap = function(f, h) {
    return u.fromSourceMap(f, h);
  }, s.prototype._version = 3, s.prototype.__generatedMappings = null, Object.defineProperty(s.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), s.prototype.__originalMappings = null, Object.defineProperty(s.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), s.prototype._charIsMappingSeparator = function(h, m) {
    var p = h.charAt(m);
    return p === ";" || p === ",";
  }, s.prototype._parseMappings = function(h, m) {
    throw new Error("Subclasses must implement _parseMappings");
  }, s.GENERATED_ORDER = 1, s.ORIGINAL_ORDER = 2, s.GREATEST_LOWER_BOUND = 1, s.LEAST_UPPER_BOUND = 2, s.prototype.eachMapping = function(h, m, p) {
    var b = m || null, M = p || s.GENERATED_ORDER, v;
    switch (M) {
      case s.GENERATED_ORDER:
        v = this._generatedMappings;
        break;
      case s.ORIGINAL_ORDER:
        v = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var E = this.sourceRoot;
    v.map(function(I) {
      var _ = I.source === null ? null : this._sources.at(I.source);
      return _ = e.computeSourceURL(E, _, this._sourceMapURL), {
        source: _,
        generatedLine: I.generatedLine,
        generatedColumn: I.generatedColumn,
        originalLine: I.originalLine,
        originalColumn: I.originalColumn,
        name: I.name === null ? null : this._names.at(I.name)
      };
    }, this).forEach(h, b);
  }, s.prototype.allGeneratedPositionsFor = function(h) {
    var m = e.getArg(h, "line"), p = {
      source: e.getArg(h, "source"),
      originalLine: m,
      originalColumn: e.getArg(h, "column", 0)
    };
    if (p.source = this._findSourceIndex(p.source), p.source < 0)
      return [];
    var b = [], M = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      e.compareByOriginalPositions,
      t.LEAST_UPPER_BOUND
    );
    if (M >= 0) {
      var v = this._originalMappings[M];
      if (h.column === void 0)
        for (var E = v.originalLine; v && v.originalLine === E; )
          b.push({
            line: e.getArg(v, "generatedLine", null),
            column: e.getArg(v, "generatedColumn", null),
            lastColumn: e.getArg(v, "lastGeneratedColumn", null)
          }), v = this._originalMappings[++M];
      else
        for (var I = v.originalColumn; v && v.originalLine === m && v.originalColumn == I; )
          b.push({
            line: e.getArg(v, "generatedLine", null),
            column: e.getArg(v, "generatedColumn", null),
            lastColumn: e.getArg(v, "lastGeneratedColumn", null)
          }), v = this._originalMappings[++M];
    }
    return b;
  }, Gr.SourceMapConsumer = s;
  function u(f, h) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var p = e.getArg(m, "version"), b = e.getArg(m, "sources"), M = e.getArg(m, "names", []), v = e.getArg(m, "sourceRoot", null), E = e.getArg(m, "sourcesContent", null), I = e.getArg(m, "mappings"), _ = e.getArg(m, "file", null);
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    v && (v = e.normalize(v)), b = b.map(String).map(e.normalize).map(function(X) {
      return v && e.isAbsolute(v) && e.isAbsolute(X) ? e.relative(v, X) : X;
    }), this._names = n.fromArray(M.map(String), !0), this._sources = n.fromArray(b, !0), this._absoluteSources = this._sources.toArray().map(function(X) {
      return e.computeSourceURL(v, X, h);
    }), this.sourceRoot = v, this.sourcesContent = E, this._mappings = I, this._sourceMapURL = h, this.file = _;
  }
  u.prototype = Object.create(s.prototype), u.prototype.consumer = s, u.prototype._findSourceIndex = function(f) {
    var h = f;
    if (this.sourceRoot != null && (h = e.relative(this.sourceRoot, h)), this._sources.has(h))
      return this._sources.indexOf(h);
    var m;
    for (m = 0; m < this._absoluteSources.length; ++m)
      if (this._absoluteSources[m] == f)
        return m;
    return -1;
  }, u.fromSourceMap = function(h, m) {
    var p = Object.create(u.prototype), b = p._names = n.fromArray(h._names.toArray(), !0), M = p._sources = n.fromArray(h._sources.toArray(), !0);
    p.sourceRoot = h._sourceRoot, p.sourcesContent = h._generateSourcesContent(
      p._sources.toArray(),
      p.sourceRoot
    ), p.file = h._file, p._sourceMapURL = m, p._absoluteSources = p._sources.toArray().map(function(B) {
      return e.computeSourceURL(p.sourceRoot, B, m);
    });
    for (var v = h._mappings.toArray().slice(), E = p.__generatedMappings = [], I = p.__originalMappings = [], _ = 0, X = v.length; _ < X; _++) {
      var S = v[_], x = new a();
      x.generatedLine = S.generatedLine, x.generatedColumn = S.generatedColumn, S.source && (x.source = M.indexOf(S.source), x.originalLine = S.originalLine, x.originalColumn = S.originalColumn, S.name && (x.name = b.indexOf(S.name)), I.push(x)), E.push(x);
    }
    return i(p.__originalMappings, e.compareByOriginalPositions), p;
  }, u.prototype._version = 3, Object.defineProperty(u.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function a() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  u.prototype._parseMappings = function(h, m) {
    for (var p = 1, b = 0, M = 0, v = 0, E = 0, I = 0, _ = h.length, X = 0, S = {}, x = {}, B = [], k = [], V, q, G, Y, W; X < _; )
      if (h.charAt(X) === ";")
        p++, X++, b = 0;
      else if (h.charAt(X) === ",")
        X++;
      else {
        for (V = new a(), V.generatedLine = p, Y = X; Y < _ && !this._charIsMappingSeparator(h, Y); Y++)
          ;
        if (q = h.slice(X, Y), G = S[q], G)
          X += q.length;
        else {
          for (G = []; X < Y; )
            r.decode(h, X, x), W = x.value, X = x.rest, G.push(W);
          if (G.length === 2)
            throw new Error("Found a source, but no line and column");
          if (G.length === 3)
            throw new Error("Found a source and line, but no column");
          S[q] = G;
        }
        V.generatedColumn = b + G[0], b = V.generatedColumn, G.length > 1 && (V.source = E + G[1], E += G[1], V.originalLine = M + G[2], M = V.originalLine, V.originalLine += 1, V.originalColumn = v + G[3], v = V.originalColumn, G.length > 4 && (V.name = I + G[4], I += G[4])), k.push(V), typeof V.originalLine == "number" && B.push(V);
      }
    i(k, e.compareByGeneratedPositionsDeflated), this.__generatedMappings = k, i(B, e.compareByOriginalPositions), this.__originalMappings = B;
  }, u.prototype._findMapping = function(h, m, p, b, M, v) {
    if (h[p] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + h[p]);
    if (h[b] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + h[b]);
    return t.search(h, m, M, v);
  }, u.prototype.computeColumnSpans = function() {
    for (var h = 0; h < this._generatedMappings.length; ++h) {
      var m = this._generatedMappings[h];
      if (h + 1 < this._generatedMappings.length) {
        var p = this._generatedMappings[h + 1];
        if (m.generatedLine === p.generatedLine) {
          m.lastGeneratedColumn = p.generatedColumn - 1;
          continue;
        }
      }
      m.lastGeneratedColumn = 1 / 0;
    }
  }, u.prototype.originalPositionFor = function(h) {
    var m = {
      generatedLine: e.getArg(h, "line"),
      generatedColumn: e.getArg(h, "column")
    }, p = this._findMapping(
      m,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      e.compareByGeneratedPositionsDeflated,
      e.getArg(h, "bias", s.GREATEST_LOWER_BOUND)
    );
    if (p >= 0) {
      var b = this._generatedMappings[p];
      if (b.generatedLine === m.generatedLine) {
        var M = e.getArg(b, "source", null);
        M !== null && (M = this._sources.at(M), M = e.computeSourceURL(this.sourceRoot, M, this._sourceMapURL));
        var v = e.getArg(b, "name", null);
        return v !== null && (v = this._names.at(v)), {
          source: M,
          line: e.getArg(b, "originalLine", null),
          column: e.getArg(b, "originalColumn", null),
          name: v
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, u.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(h) {
      return h == null;
    }) : !1;
  }, u.prototype.sourceContentFor = function(h, m) {
    if (!this.sourcesContent)
      return null;
    var p = this._findSourceIndex(h);
    if (p >= 0)
      return this.sourcesContent[p];
    var b = h;
    this.sourceRoot != null && (b = e.relative(this.sourceRoot, b));
    var M;
    if (this.sourceRoot != null && (M = e.urlParse(this.sourceRoot))) {
      var v = b.replace(/^file:\/\//, "");
      if (M.scheme == "file" && this._sources.has(v))
        return this.sourcesContent[this._sources.indexOf(v)];
      if ((!M.path || M.path == "/") && this._sources.has("/" + b))
        return this.sourcesContent[this._sources.indexOf("/" + b)];
    }
    if (m)
      return null;
    throw new Error('"' + b + '" is not in the SourceMap.');
  }, u.prototype.generatedPositionFor = function(h) {
    var m = e.getArg(h, "source");
    if (m = this._findSourceIndex(m), m < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var p = {
      source: m,
      originalLine: e.getArg(h, "line"),
      originalColumn: e.getArg(h, "column")
    }, b = this._findMapping(
      p,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      e.compareByOriginalPositions,
      e.getArg(h, "bias", s.GREATEST_LOWER_BOUND)
    );
    if (b >= 0) {
      var M = this._originalMappings[b];
      if (M.source === p.source)
        return {
          line: e.getArg(M, "generatedLine", null),
          column: e.getArg(M, "generatedColumn", null),
          lastColumn: e.getArg(M, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, Gr.BasicSourceMapConsumer = u;
  function o(f, h) {
    var m = f;
    typeof f == "string" && (m = e.parseSourceMapInput(f));
    var p = e.getArg(m, "version"), b = e.getArg(m, "sections");
    if (p != this._version)
      throw new Error("Unsupported version: " + p);
    this._sources = new n(), this._names = new n();
    var M = {
      line: -1,
      column: 0
    };
    this._sections = b.map(function(v) {
      if (v.url)
        throw new Error("Support for url field in sections not implemented.");
      var E = e.getArg(v, "offset"), I = e.getArg(E, "line"), _ = e.getArg(E, "column");
      if (I < M.line || I === M.line && _ < M.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return M = E, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: I + 1,
          generatedColumn: _ + 1
        },
        consumer: new s(e.getArg(v, "map"), h)
      };
    });
  }
  return o.prototype = Object.create(s.prototype), o.prototype.constructor = s, o.prototype._version = 3, Object.defineProperty(o.prototype, "sources", {
    get: function() {
      for (var f = [], h = 0; h < this._sections.length; h++)
        for (var m = 0; m < this._sections[h].consumer.sources.length; m++)
          f.push(this._sections[h].consumer.sources[m]);
      return f;
    }
  }), o.prototype.originalPositionFor = function(h) {
    var m = {
      generatedLine: e.getArg(h, "line"),
      generatedColumn: e.getArg(h, "column")
    }, p = t.search(
      m,
      this._sections,
      function(M, v) {
        var E = M.generatedLine - v.generatedOffset.generatedLine;
        return E || M.generatedColumn - v.generatedOffset.generatedColumn;
      }
    ), b = this._sections[p];
    return b ? b.consumer.originalPositionFor({
      line: m.generatedLine - (b.generatedOffset.generatedLine - 1),
      column: m.generatedColumn - (b.generatedOffset.generatedLine === m.generatedLine ? b.generatedOffset.generatedColumn - 1 : 0),
      bias: h.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, o.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(h) {
      return h.consumer.hasContentsOfAllSources();
    });
  }, o.prototype.sourceContentFor = function(h, m) {
    for (var p = 0; p < this._sections.length; p++) {
      var b = this._sections[p], M = b.consumer.sourceContentFor(h, !0);
      if (M)
        return M;
    }
    if (m)
      return null;
    throw new Error('"' + h + '" is not in the SourceMap.');
  }, o.prototype.generatedPositionFor = function(h) {
    for (var m = 0; m < this._sections.length; m++) {
      var p = this._sections[m];
      if (p.consumer._findSourceIndex(e.getArg(h, "source")) !== -1) {
        var b = p.consumer.generatedPositionFor(h);
        if (b) {
          var M = {
            line: b.line + (p.generatedOffset.generatedLine - 1),
            column: b.column + (p.generatedOffset.generatedLine === b.line ? p.generatedOffset.generatedColumn - 1 : 0)
          };
          return M;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, o.prototype._parseMappings = function(h, m) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var p = 0; p < this._sections.length; p++)
      for (var b = this._sections[p], M = b.consumer._generatedMappings, v = 0; v < M.length; v++) {
        var E = M[v], I = b.consumer._sources.at(E.source);
        I = e.computeSourceURL(b.consumer.sourceRoot, I, this._sourceMapURL), this._sources.add(I), I = this._sources.indexOf(I);
        var _ = null;
        E.name && (_ = b.consumer._names.at(E.name), this._names.add(_), _ = this._names.indexOf(_));
        var X = {
          source: I,
          generatedLine: E.generatedLine + (b.generatedOffset.generatedLine - 1),
          generatedColumn: E.generatedColumn + (b.generatedOffset.generatedLine === E.generatedLine ? b.generatedOffset.generatedColumn - 1 : 0),
          originalLine: E.originalLine,
          originalColumn: E.originalColumn,
          name: _
        };
        this.__generatedMappings.push(X), typeof X.originalLine == "number" && this.__originalMappings.push(X);
      }
    i(this.__generatedMappings, e.compareByGeneratedPositionsDeflated), i(this.__originalMappings, e.compareByOriginalPositions);
  }, Gr.IndexedSourceMapConsumer = o, Gr;
}
var Zs = {}, ko;
function jv() {
  if (ko) return Zs;
  ko = 1;
  var e = mm().SourceMapGenerator, t = si(), n = /(\r?\n)/, r = 10, i = "$$$isSourceNode$$$";
  function s(u, a, o, f, h) {
    this.children = [], this.sourceContents = {}, this.line = u ?? null, this.column = a ?? null, this.source = o ?? null, this.name = h ?? null, this[i] = !0, f != null && this.add(f);
  }
  return s.fromStringWithSourceMap = function(a, o, f) {
    var h = new s(), m = a.split(n), p = 0, b = function() {
      var _ = S(), X = S() || "";
      return _ + X;
      function S() {
        return p < m.length ? m[p++] : void 0;
      }
    }, M = 1, v = 0, E = null;
    return o.eachMapping(function(_) {
      if (E !== null)
        if (M < _.generatedLine)
          I(E, b()), M++, v = 0;
        else {
          var X = m[p] || "", S = X.substr(0, _.generatedColumn - v);
          m[p] = X.substr(_.generatedColumn - v), v = _.generatedColumn, I(E, S), E = _;
          return;
        }
      for (; M < _.generatedLine; )
        h.add(b()), M++;
      if (v < _.generatedColumn) {
        var X = m[p] || "";
        h.add(X.substr(0, _.generatedColumn)), m[p] = X.substr(_.generatedColumn), v = _.generatedColumn;
      }
      E = _;
    }, this), p < m.length && (E && I(E, b()), h.add(m.splice(p).join(""))), o.sources.forEach(function(_) {
      var X = o.sourceContentFor(_);
      X != null && (f != null && (_ = t.join(f, _)), h.setSourceContent(_, X));
    }), h;
    function I(_, X) {
      if (_ === null || _.source === void 0)
        h.add(X);
      else {
        var S = f ? t.join(f, _.source) : _.source;
        h.add(new s(
          _.originalLine,
          _.originalColumn,
          S,
          X,
          _.name
        ));
      }
    }
  }, s.prototype.add = function(a) {
    if (Array.isArray(a))
      a.forEach(function(o) {
        this.add(o);
      }, this);
    else if (a[i] || typeof a == "string")
      a && this.children.push(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, s.prototype.prepend = function(a) {
    if (Array.isArray(a))
      for (var o = a.length - 1; o >= 0; o--)
        this.prepend(a[o]);
    else if (a[i] || typeof a == "string")
      this.children.unshift(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, s.prototype.walk = function(a) {
    for (var o, f = 0, h = this.children.length; f < h; f++)
      o = this.children[f], o[i] ? o.walk(a) : o !== "" && a(o, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, s.prototype.join = function(a) {
    var o, f, h = this.children.length;
    if (h > 0) {
      for (o = [], f = 0; f < h - 1; f++)
        o.push(this.children[f]), o.push(a);
      o.push(this.children[f]), this.children = o;
    }
    return this;
  }, s.prototype.replaceRight = function(a, o) {
    var f = this.children[this.children.length - 1];
    return f[i] ? f.replaceRight(a, o) : typeof f == "string" ? this.children[this.children.length - 1] = f.replace(a, o) : this.children.push("".replace(a, o)), this;
  }, s.prototype.setSourceContent = function(a, o) {
    this.sourceContents[t.toSetString(a)] = o;
  }, s.prototype.walkSourceContents = function(a) {
    for (var o = 0, f = this.children.length; o < f; o++)
      this.children[o][i] && this.children[o].walkSourceContents(a);
    for (var h = Object.keys(this.sourceContents), o = 0, f = h.length; o < f; o++)
      a(t.fromSetString(h[o]), this.sourceContents[h[o]]);
  }, s.prototype.toString = function() {
    var a = "";
    return this.walk(function(o) {
      a += o;
    }), a;
  }, s.prototype.toStringWithSourceMap = function(a) {
    var o = {
      code: "",
      line: 1,
      column: 0
    }, f = new e(a), h = !1, m = null, p = null, b = null, M = null;
    return this.walk(function(v, E) {
      o.code += v, E.source !== null && E.line !== null && E.column !== null ? ((m !== E.source || p !== E.line || b !== E.column || M !== E.name) && f.addMapping({
        source: E.source,
        original: {
          line: E.line,
          column: E.column
        },
        generated: {
          line: o.line,
          column: o.column
        },
        name: E.name
      }), m = E.source, p = E.line, b = E.column, M = E.name, h = !0) : h && (f.addMapping({
        generated: {
          line: o.line,
          column: o.column
        }
      }), m = null, h = !1);
      for (var I = 0, _ = v.length; I < _; I++)
        v.charCodeAt(I) === r ? (o.line++, o.column = 0, I + 1 === _ ? (m = null, h = !1) : h && f.addMapping({
          source: E.source,
          original: {
            line: E.line,
            column: E.column
          },
          generated: {
            line: o.line,
            column: o.column
          },
          name: E.name
        })) : o.column++;
    }), this.walkSourceContents(function(v, E) {
      f.setSourceContent(v, E);
    }), { code: o.code, map: f };
  }, Zs.SourceNode = s, Zs;
}
var Io;
function $v() {
  return Io || (Io = 1, Lr.SourceMapGenerator = mm().SourceMapGenerator, Lr.SourceMapConsumer = zv().SourceMapConsumer, Lr.SourceNode = jv().SourceNode), Lr;
}
const qv = "escodegen", Kv = "ECMAScript code generator", Hv = "http://github.com/estools/escodegen", Uv = "escodegen.js", Jv = { esgenerate: "./bin/esgenerate.js", escodegen: "./bin/escodegen.js" }, Yv = ["LICENSE.BSD", "README.md", "bin", "escodegen.js", "package.json"], Qv = "2.1.0", eP = { node: ">=6.0" }, tP = [{ name: "Yusuke Suzuki", email: "utatane.tea@gmail.com", web: "http://github.com/Constellation" }], nP = { type: "git", url: "http://github.com/estools/escodegen.git" }, rP = { estraverse: "^5.2.0", esutils: "^2.0.2", esprima: "^4.0.1" }, iP = { "source-map": "~0.6.1" }, sP = { acorn: "^8.0.4", bluebird: "^3.4.7", "bower-registry-client": "^1.0.0", chai: "^4.2.0", "chai-exclude": "^2.0.2", "commonjs-everywhere": "^0.9.7", gulp: "^4.0.2", "gulp-eslint": "^6.0.0", "gulp-mocha": "^7.0.2", minimist: "^1.2.5", optionator: "^0.9.1", semver: "^7.3.4" }, uP = "BSD-2-Clause", aP = { test: "gulp travis", "unit-test": "gulp test", lint: "gulp lint", release: "node tools/release.js", "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js", build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js" }, oP = {
  name: qv,
  description: Kv,
  homepage: Hv,
  main: Uv,
  bin: Jv,
  files: Yv,
  version: Qv,
  engines: eP,
  maintainers: tP,
  repository: nP,
  dependencies: rP,
  optionalDependencies: iP,
  devDependencies: sP,
  license: uP,
  scripts: aP
};
var Vo;
function cP() {
  return Vo || (Vo = 1, function(e) {
    (function() {
      var t, n, r, i, s, u, a, o, f, h, m, p, b, M, v, E, I, _, X, S, x, B, k, V, q, G;
      s = Tv(), u = Gv(), t = s.Syntax;
      function Y(c) {
        return Ne.Expression.hasOwnProperty(c.type);
      }
      function W(c) {
        return Ne.Statement.hasOwnProperty(c.type);
      }
      n = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      }, r = {
        "??": n.Coalesce,
        "||": n.LogicalOR,
        "&&": n.LogicalAND,
        "|": n.BitwiseOR,
        "^": n.BitwiseXOR,
        "&": n.BitwiseAND,
        "==": n.Equality,
        "!=": n.Equality,
        "===": n.Equality,
        "!==": n.Equality,
        is: n.Equality,
        isnt: n.Equality,
        "<": n.Relational,
        ">": n.Relational,
        "<=": n.Relational,
        ">=": n.Relational,
        in: n.Relational,
        instanceof: n.Relational,
        "<<": n.BitwiseSHIFT,
        ">>": n.BitwiseSHIFT,
        ">>>": n.BitwiseSHIFT,
        "+": n.Additive,
        "-": n.Additive,
        "*": n.Multiplicative,
        "%": n.Multiplicative,
        "/": n.Multiplicative,
        "**": n.Exponentiation
      };
      var O = 1, te = 2, Ae = 4, pe = 8, fe = 16, Q = 32, ke = 64, oe = te | Ae, ge = O | te, $ = O | te | Ae, ve = O, st = Ae, je = O | Ae, be = O, Ke = O | Q, Fe = 0, $e = O | fe, vt = O | pe;
      function ot() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: !1,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: !1
            },
            newline: `
`,
            space: " ",
            json: !1,
            renumber: !1,
            hexadecimal: !1,
            quotes: "single",
            escapeless: !1,
            compact: !1,
            parentheses: !0,
            semicolons: !0,
            safeConcatenation: !1,
            preserveBlankLines: !1
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: !1,
            starlessGenerator: !1
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: !1,
          directive: !1,
          raw: !0,
          verbatim: null,
          sourceCode: null
        };
      }
      function Ie(c, g) {
        var d = "";
        for (g |= 0; g > 0; g >>>= 1, c += c)
          g & 1 && (d += c);
        return d;
      }
      function sn(c) {
        return /[\r\n]/g.test(c);
      }
      function Le(c) {
        var g = c.length;
        return g && u.code.isLineTerminator(c.charCodeAt(g - 1));
      }
      function $t(c, g) {
        var d;
        for (d in g)
          g.hasOwnProperty(d) && (c[d] = g[d]);
        return c;
      }
      function Vt(c, g) {
        var d, y;
        function P(N) {
          return typeof N == "object" && N instanceof Object && !(N instanceof RegExp);
        }
        for (d in g)
          g.hasOwnProperty(d) && (y = g[d], P(y) ? P(c[d]) ? Vt(c[d], y) : c[d] = Vt({}, y) : c[d] = y);
        return c;
      }
      function Nt(c) {
        var g, d, y, P, N;
        if (c !== c)
          throw new Error("Numeric literal whose value is NaN");
        if (c < 0 || c === 0 && 1 / c < 0)
          throw new Error("Numeric literal whose value is negative");
        if (c === 1 / 0)
          return f ? "null" : h ? "1e400" : "1e+400";
        if (g = "" + c, !h || g.length < 3)
          return g;
        for (d = g.indexOf("."), !f && g.charCodeAt(0) === 48 && d === 1 && (d = 0, g = g.slice(1)), y = g, g = g.replace("e+", "e"), P = 0, (N = y.indexOf("e")) > 0 && (P = +y.slice(N + 1), y = y.slice(0, N)), d >= 0 && (P -= y.length - d - 1, y = +(y.slice(0, d) + y.slice(d + 1)) + ""), N = 0; y.charCodeAt(y.length + N - 1) === 48; )
          --N;
        return N !== 0 && (P -= N, y = y.slice(0, N)), P !== 0 && (y += "e" + P), (y.length < g.length || m && c > 1e12 && Math.floor(c) === c && (y = "0x" + c.toString(16)).length < g.length) && +y === c && (g = y), g;
      }
      function un(c, g) {
        return (c & -2) === 8232 ? (g ? "u" : "\\u") + (c === 8232 ? "2028" : "2029") : c === 10 || c === 13 ? (g ? "" : "\\") + (c === 10 ? "n" : "r") : String.fromCharCode(c);
      }
      function Rn(c) {
        var g, d, y, P, N, L, Z, U;
        if (d = c.toString(), c.source) {
          if (g = d.match(/\/([^/]*)$/), !g)
            return d;
          for (y = g[1], d = "", Z = !1, U = !1, P = 0, N = c.source.length; P < N; ++P)
            L = c.source.charCodeAt(P), U ? (d += un(L, U), U = !1) : (Z ? L === 93 && (Z = !1) : L === 47 ? d += "\\" : L === 91 && (Z = !0), d += un(L, U), U = L === 92);
          return "/" + d + "/" + y;
        }
        return d;
      }
      function qt(c, g) {
        var d;
        return c === 8 ? "\\b" : c === 12 ? "\\f" : c === 9 ? "\\t" : (d = c.toString(16).toUpperCase(), f || c > 255 ? "\\u" + "0000".slice(d.length) + d : c === 0 && !u.code.isDecimalDigit(g) ? "\\0" : c === 11 ? "\\x0B" : "\\x" + "00".slice(d.length) + d);
      }
      function an(c) {
        if (c === 92)
          return "\\\\";
        if (c === 10)
          return "\\n";
        if (c === 13)
          return "\\r";
        if (c === 8232)
          return "\\u2028";
        if (c === 8233)
          return "\\u2029";
        throw new Error("Incorrectly classified character");
      }
      function Kt(c) {
        var g, d, y, P;
        for (P = p === "double" ? '"' : "'", g = 0, d = c.length; g < d; ++g)
          if (y = c.charCodeAt(g), y === 39) {
            P = '"';
            break;
          } else if (y === 34) {
            P = "'";
            break;
          } else y === 92 && ++g;
        return P + c + P;
      }
      function At(c) {
        var g = "", d, y, P, N = 0, L = 0, Z, U;
        for (d = 0, y = c.length; d < y; ++d) {
          if (P = c.charCodeAt(d), P === 39)
            ++N;
          else if (P === 34)
            ++L;
          else if (P === 47 && f)
            g += "\\";
          else if (u.code.isLineTerminator(P) || P === 92) {
            g += an(P);
            continue;
          } else if (!u.code.isIdentifierPartES5(P) && (f && P < 32 || !f && !b && (P < 32 || P > 126))) {
            g += qt(P, c.charCodeAt(d + 1));
            continue;
          }
          g += String.fromCharCode(P);
        }
        if (Z = !(p === "double" || p === "auto" && L < N), U = Z ? "'" : '"', !(Z ? N : L))
          return U + g + U;
        for (c = g, g = U, d = 0, y = c.length; d < y; ++d)
          P = c.charCodeAt(d), (P === 39 && Z || P === 34 && !Z) && (g += "\\"), g += String.fromCharCode(P);
        return g + U;
      }
      function Pn(c) {
        var g, d, y, P = "";
        for (g = 0, d = c.length; g < d; ++g)
          y = c[g], P += Array.isArray(y) ? Pn(y) : y;
        return P;
      }
      function ye(c, g) {
        if (!B)
          return Array.isArray(c) ? Pn(c) : c;
        if (g == null) {
          if (c instanceof i)
            return c;
          g = {};
        }
        return g.loc == null ? new i(null, null, B, c, g.name || null) : new i(g.loc.start.line, g.loc.start.column, B === !0 ? g.loc.source || null : B, c, g.name || null);
      }
      function We() {
        return v || " ";
      }
      function ue(c, g) {
        var d, y, P, N;
        return d = ye(c).toString(), d.length === 0 ? [g] : (y = ye(g).toString(), y.length === 0 ? [c] : (P = d.charCodeAt(d.length - 1), N = y.charCodeAt(0), (P === 43 || P === 45) && P === N || u.code.isIdentifierPartES5(P) && u.code.isIdentifierPartES5(N) || P === 47 && N === 105 ? [c, We(), g] : u.code.isWhiteSpace(P) || u.code.isLineTerminator(P) || u.code.isWhiteSpace(N) || u.code.isLineTerminator(N) ? [c, g] : [c, v, g]));
      }
      function Oe(c) {
        return [a, c];
      }
      function Be(c) {
        var g;
        g = a, a += o, c(a), a = g;
      }
      function Ln(c) {
        var g;
        for (g = c.length - 1; g >= 0 && !u.code.isLineTerminator(c.charCodeAt(g)); --g)
          ;
        return c.length - 1 - g;
      }
      function Ht(c, g) {
        var d, y, P, N, L, Z, U, Me;
        for (d = c.split(/\r\n|[\r\n]/), Z = Number.MAX_VALUE, y = 1, P = d.length; y < P; ++y) {
          for (N = d[y], L = 0; L < N.length && u.code.isWhiteSpace(N.charCodeAt(L)); )
            ++L;
          Z > L && (Z = L);
        }
        for (typeof g < "u" ? (U = a, d[1][Z] === "*" && (g += " "), a = g) : (Z & 1 && --Z, U = a), y = 1, P = d.length; y < P; ++y)
          Me = ye(Oe(d[y].slice(Z))), d[y] = B ? Me.join("") : Me;
        return a = U, d.join(`
`);
      }
      function ut(c, g) {
        if (c.type === "Line") {
          if (Le(c.value))
            return "//" + c.value;
          var d = "//" + c.value;
          return V || (d += `
`), d;
        }
        return S.format.indent.adjustMultilineComment && /[\n\r]/.test(c.value) ? Ht("/*" + c.value + "*/", g) : "/*" + c.value + "*/";
      }
      function Ve(c, g) {
        var d, y, P, N, L, Z, U, Me, ze, on, Dn, oi, ci, Pt;
        if (c.leadingComments && c.leadingComments.length > 0) {
          if (N = g, V) {
            for (P = c.leadingComments[0], g = [], Me = P.extendedRange, ze = P.range, Dn = k.substring(Me[0], ze[0]), Pt = (Dn.match(/\n/g) || []).length, Pt > 0 ? (g.push(Ie(`
`, Pt)), g.push(Oe(ut(P)))) : (g.push(Dn), g.push(ut(P))), on = ze, d = 1, y = c.leadingComments.length; d < y; d++)
              P = c.leadingComments[d], ze = P.range, oi = k.substring(on[1], ze[0]), Pt = (oi.match(/\n/g) || []).length, g.push(Ie(`
`, Pt)), g.push(Oe(ut(P))), on = ze;
            ci = k.substring(ze[1], Me[1]), Pt = (ci.match(/\n/g) || []).length, g.push(Ie(`
`, Pt));
          } else
            for (P = c.leadingComments[0], g = [], _ && c.type === t.Program && c.body.length === 0 && g.push(`
`), g.push(ut(P)), Le(ye(g).toString()) || g.push(`
`), d = 1, y = c.leadingComments.length; d < y; ++d)
              P = c.leadingComments[d], U = [ut(P)], Le(ye(U).toString()) || U.push(`
`), g.push(Oe(U));
          g.push(Oe(N));
        }
        if (c.trailingComments)
          if (V)
            P = c.trailingComments[0], Me = P.extendedRange, ze = P.range, Dn = k.substring(Me[0], ze[0]), Pt = (Dn.match(/\n/g) || []).length, Pt > 0 ? (g.push(Ie(`
`, Pt)), g.push(Oe(ut(P)))) : (g.push(Dn), g.push(ut(P)));
          else
            for (L = !Le(ye(g).toString()), Z = Ie(" ", Ln(ye([a, g, o]).toString())), d = 0, y = c.trailingComments.length; d < y; ++d)
              P = c.trailingComments[d], L ? (d === 0 ? g = [g, o] : g = [g, Z], g.push(ut(P, Z))) : g = [g, Oe(ut(P))], d !== y - 1 && !Le(ye(g).toString()) && (g = [g, `
`]);
        return g;
      }
      function bt(c, g, d) {
        var y, P = 0;
        for (y = c; y < g; y++)
          k[y] === `
` && P++;
        for (y = 1; y < P; y++)
          d.push(M);
      }
      function _e(c, g, d) {
        return g < d ? ["(", c, ")"] : c;
      }
      function Gn(c) {
        var g, d, y;
        for (y = c.split(/\r\n|\n/), g = 1, d = y.length; g < d; g++)
          y[g] = M + a + y[g];
        return y;
      }
      function Qn(c, g) {
        var d, y, P;
        return d = c[S.verbatim], typeof d == "string" ? y = _e(Gn(d), n.Sequence, g) : (y = Gn(d.content), P = d.precedence != null ? d.precedence : n.Sequence, y = _e(y, P, g)), ye(y, c);
      }
      function Ne() {
      }
      Ne.prototype.maybeBlock = function(c, g) {
        var d, y, P = this;
        return y = !S.comment || !c.leadingComments, c.type === t.BlockStatement && y ? [v, this.generateStatement(c, g)] : c.type === t.EmptyStatement && y ? ";" : (Be(function() {
          d = [
            M,
            Oe(P.generateStatement(c, g))
          ];
        }), d);
      }, Ne.prototype.maybeBlockSuffix = function(c, g) {
        var d = Le(ye(g).toString());
        return c.type === t.BlockStatement && (!S.comment || !c.leadingComments) && !d ? [g, v] : d ? [g, a] : [g, M, a];
      };
      function ce(c) {
        return ye(c.name, c);
      }
      function ct(c, g) {
        return c.async ? "async" + (g ? We() : v) : "";
      }
      function tt(c) {
        var g = c.generator && !S.moz.starlessGenerator;
        return g ? "*" + v : "";
      }
      function lt(c) {
        var g = c.value, d = "";
        return g.async && (d += ct(g, !c.computed)), g.generator && (d += tt(g) ? "*" : ""), d;
      }
      Ne.prototype.generatePattern = function(c, g, d) {
        return c.type === t.Identifier ? ce(c) : this.generateExpression(c, g, d);
      }, Ne.prototype.generateFunctionParams = function(c) {
        var g, d, y, P;
        if (P = !1, c.type === t.ArrowFunctionExpression && !c.rest && (!c.defaults || c.defaults.length === 0) && c.params.length === 1 && c.params[0].type === t.Identifier)
          y = [ct(c, !0), ce(c.params[0])];
        else {
          for (y = c.type === t.ArrowFunctionExpression ? [ct(c, !1)] : [], y.push("("), c.defaults && (P = !0), g = 0, d = c.params.length; g < d; ++g)
            P && c.defaults[g] ? y.push(this.generateAssignment(c.params[g], c.defaults[g], "=", n.Assignment, $)) : y.push(this.generatePattern(c.params[g], n.Assignment, $)), g + 1 < d && y.push("," + v);
          c.rest && (c.params.length && y.push("," + v), y.push("..."), y.push(ce(c.rest))), y.push(")");
        }
        return y;
      }, Ne.prototype.generateFunctionBody = function(c) {
        var g, d;
        return g = this.generateFunctionParams(c), c.type === t.ArrowFunctionExpression && (g.push(v), g.push("=>")), c.expression ? (g.push(v), d = this.generateExpression(c.body, n.Assignment, $), d.toString().charAt(0) === "{" && (d = ["(", d, ")"]), g.push(d)) : g.push(this.maybeBlock(c.body, vt)), g;
      }, Ne.prototype.generateIterationForStatement = function(c, g, d) {
        var y = ["for" + (g.await ? We() + "await" : "") + v + "("], P = this;
        return Be(function() {
          g.left.type === t.VariableDeclaration ? Be(function() {
            y.push(g.left.kind + We()), y.push(P.generateStatement(g.left.declarations[0], Fe));
          }) : y.push(P.generateExpression(g.left, n.Call, $)), y = ue(y, c), y = [ue(
            y,
            P.generateExpression(g.right, n.Assignment, $)
          ), ")"];
        }), y.push(this.maybeBlock(g.body, d)), y;
      }, Ne.prototype.generatePropertyKey = function(c, g) {
        var d = [];
        return g && d.push("["), d.push(this.generateExpression(c, n.Assignment, $)), g && d.push("]"), d;
      }, Ne.prototype.generateAssignment = function(c, g, d, y, P) {
        return n.Assignment < y && (P |= O), _e(
          [
            this.generateExpression(c, n.Call, P),
            v + d + v,
            this.generateExpression(g, n.Assignment, P)
          ],
          n.Assignment,
          y
        );
      }, Ne.prototype.semicolon = function(c) {
        return !I && c & Q ? "" : ";";
      }, Ne.Statement = {
        BlockStatement: function(c, g) {
          var d, y, P = ["{", M], N = this;
          return Be(function() {
            c.body.length === 0 && V && (d = c.range, d[1] - d[0] > 2 && (y = k.substring(d[0] + 1, d[1] - 1), y[0] === `
` && (P = ["{"]), P.push(y)));
            var L, Z, U, Me;
            for (Me = be, g & pe && (Me |= fe), L = 0, Z = c.body.length; L < Z; ++L)
              V && (L === 0 && (c.body[0].leadingComments && (d = c.body[0].leadingComments[0].extendedRange, y = k.substring(d[0], d[1]), y[0] === `
` && (P = ["{"])), c.body[0].leadingComments || bt(c.range[0], c.body[0].range[0], P)), L > 0 && !c.body[L - 1].trailingComments && !c.body[L].leadingComments && bt(c.body[L - 1].range[1], c.body[L].range[0], P)), L === Z - 1 && (Me |= Q), c.body[L].leadingComments && V ? U = N.generateStatement(c.body[L], Me) : U = Oe(N.generateStatement(c.body[L], Me)), P.push(U), Le(ye(U).toString()) || V && L < Z - 1 && c.body[L + 1].leadingComments || P.push(M), V && L === Z - 1 && (c.body[L].trailingComments || bt(c.body[L].range[1], c.range[1], P));
          }), P.push(Oe("}")), P;
        },
        BreakStatement: function(c, g) {
          return c.label ? "break " + c.label.name + this.semicolon(g) : "break" + this.semicolon(g);
        },
        ContinueStatement: function(c, g) {
          return c.label ? "continue " + c.label.name + this.semicolon(g) : "continue" + this.semicolon(g);
        },
        ClassBody: function(c, g) {
          var d = ["{", M], y = this;
          return Be(function(P) {
            var N, L;
            for (N = 0, L = c.body.length; N < L; ++N)
              d.push(P), d.push(y.generateExpression(c.body[N], n.Sequence, $)), N + 1 < L && d.push(M);
          }), Le(ye(d).toString()) || d.push(M), d.push(a), d.push("}"), d;
        },
        ClassDeclaration: function(c, g) {
          var d, y;
          return d = ["class"], c.id && (d = ue(d, this.generateExpression(c.id, n.Sequence, $))), c.superClass && (y = ue("extends", this.generateExpression(c.superClass, n.Unary, $)), d = ue(d, y)), d.push(v), d.push(this.generateStatement(c.body, Ke)), d;
        },
        DirectiveStatement: function(c, g) {
          return S.raw && c.raw ? c.raw + this.semicolon(g) : Kt(c.directive) + this.semicolon(g);
        },
        DoWhileStatement: function(c, g) {
          var d = ue("do", this.maybeBlock(c.body, be));
          return d = this.maybeBlockSuffix(c.body, d), ue(d, [
            "while" + v + "(",
            this.generateExpression(c.test, n.Sequence, $),
            ")" + this.semicolon(g)
          ]);
        },
        CatchClause: function(c, g) {
          var d, y = this;
          return Be(function() {
            var P;
            c.param ? (d = [
              "catch" + v + "(",
              y.generateExpression(c.param, n.Sequence, $),
              ")"
            ], c.guard && (P = y.generateExpression(c.guard, n.Sequence, $), d.splice(2, 0, " if ", P))) : d = ["catch"];
          }), d.push(this.maybeBlock(c.body, be)), d;
        },
        DebuggerStatement: function(c, g) {
          return "debugger" + this.semicolon(g);
        },
        EmptyStatement: function(c, g) {
          return ";";
        },
        ExportDefaultDeclaration: function(c, g) {
          var d = ["export"], y;
          return y = g & Q ? Ke : be, d = ue(d, "default"), W(c.declaration) ? d = ue(d, this.generateStatement(c.declaration, y)) : d = ue(d, this.generateExpression(c.declaration, n.Assignment, $) + this.semicolon(g)), d;
        },
        ExportNamedDeclaration: function(c, g) {
          var d = ["export"], y, P = this;
          return y = g & Q ? Ke : be, c.declaration ? ue(d, this.generateStatement(c.declaration, y)) : (c.specifiers && (c.specifiers.length === 0 ? d = ue(d, "{" + v + "}") : c.specifiers[0].type === t.ExportBatchSpecifier ? d = ue(d, this.generateExpression(c.specifiers[0], n.Sequence, $)) : (d = ue(d, "{"), Be(function(N) {
            var L, Z;
            for (d.push(M), L = 0, Z = c.specifiers.length; L < Z; ++L)
              d.push(N), d.push(P.generateExpression(c.specifiers[L], n.Sequence, $)), L + 1 < Z && d.push("," + M);
          }), Le(ye(d).toString()) || d.push(M), d.push(a + "}")), c.source ? d = ue(d, [
            "from" + v,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, $),
            this.semicolon(g)
          ]) : d.push(this.semicolon(g))), d);
        },
        ExportAllDeclaration: function(c, g) {
          return [
            "export" + v,
            "*" + v,
            "from" + v,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, $),
            this.semicolon(g)
          ];
        },
        ExpressionStatement: function(c, g) {
          var d, y;
          function P(Z) {
            var U;
            return Z.slice(0, 5) !== "class" ? !1 : (U = Z.charCodeAt(5), U === 123 || u.code.isWhiteSpace(U) || u.code.isLineTerminator(U));
          }
          function N(Z) {
            var U;
            return Z.slice(0, 8) !== "function" ? !1 : (U = Z.charCodeAt(8), U === 40 || u.code.isWhiteSpace(U) || U === 42 || u.code.isLineTerminator(U));
          }
          function L(Z) {
            var U, Me, ze;
            if (Z.slice(0, 5) !== "async" || !u.code.isWhiteSpace(Z.charCodeAt(5)))
              return !1;
            for (Me = 6, ze = Z.length; Me < ze && u.code.isWhiteSpace(Z.charCodeAt(Me)); ++Me)
              ;
            return Me === ze || Z.slice(Me, Me + 8) !== "function" ? !1 : (U = Z.charCodeAt(Me + 8), U === 40 || u.code.isWhiteSpace(U) || U === 42 || u.code.isLineTerminator(U));
          }
          return d = [this.generateExpression(c.expression, n.Sequence, $)], y = ye(d).toString(), y.charCodeAt(0) === 123 || // ObjectExpression
          P(y) || N(y) || L(y) || X && g & fe && c.expression.type === t.Literal && typeof c.expression.value == "string" ? d = ["(", d, ")" + this.semicolon(g)] : d.push(this.semicolon(g)), d;
        },
        ImportDeclaration: function(c, g) {
          var d, y, P = this;
          return c.specifiers.length === 0 ? [
            "import",
            v,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, $),
            this.semicolon(g)
          ] : (d = [
            "import"
          ], y = 0, c.specifiers[y].type === t.ImportDefaultSpecifier && (d = ue(d, [
            this.generateExpression(c.specifiers[y], n.Sequence, $)
          ]), ++y), c.specifiers[y] && (y !== 0 && d.push(","), c.specifiers[y].type === t.ImportNamespaceSpecifier ? d = ue(d, [
            v,
            this.generateExpression(c.specifiers[y], n.Sequence, $)
          ]) : (d.push(v + "{"), c.specifiers.length - y === 1 ? (d.push(v), d.push(this.generateExpression(c.specifiers[y], n.Sequence, $)), d.push(v + "}" + v)) : (Be(function(N) {
            var L, Z;
            for (d.push(M), L = y, Z = c.specifiers.length; L < Z; ++L)
              d.push(N), d.push(P.generateExpression(c.specifiers[L], n.Sequence, $)), L + 1 < Z && d.push("," + M);
          }), Le(ye(d).toString()) || d.push(M), d.push(a + "}" + v)))), d = ue(d, [
            "from" + v,
            // ModuleSpecifier
            this.generateExpression(c.source, n.Sequence, $),
            this.semicolon(g)
          ]), d);
        },
        VariableDeclarator: function(c, g) {
          var d = g & O ? $ : oe;
          return c.init ? [
            this.generateExpression(c.id, n.Assignment, d),
            v,
            "=",
            v,
            this.generateExpression(c.init, n.Assignment, d)
          ] : this.generatePattern(c.id, n.Assignment, d);
        },
        VariableDeclaration: function(c, g) {
          var d, y, P, N, L, Z = this;
          d = [c.kind], L = g & O ? be : Fe;
          function U() {
            for (N = c.declarations[0], S.comment && N.leadingComments ? (d.push(`
`), d.push(Oe(Z.generateStatement(N, L)))) : (d.push(We()), d.push(Z.generateStatement(N, L))), y = 1, P = c.declarations.length; y < P; ++y)
              N = c.declarations[y], S.comment && N.leadingComments ? (d.push("," + M), d.push(Oe(Z.generateStatement(N, L)))) : (d.push("," + v), d.push(Z.generateStatement(N, L)));
          }
          return c.declarations.length > 1 ? Be(U) : U(), d.push(this.semicolon(g)), d;
        },
        ThrowStatement: function(c, g) {
          return [ue(
            "throw",
            this.generateExpression(c.argument, n.Sequence, $)
          ), this.semicolon(g)];
        },
        TryStatement: function(c, g) {
          var d, y, P, N;
          if (d = ["try", this.maybeBlock(c.block, be)], d = this.maybeBlockSuffix(c.block, d), c.handlers)
            for (y = 0, P = c.handlers.length; y < P; ++y)
              d = ue(d, this.generateStatement(c.handlers[y], be)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(c.handlers[y].body, d));
          else {
            for (N = c.guardedHandlers || [], y = 0, P = N.length; y < P; ++y)
              d = ue(d, this.generateStatement(N[y], be)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(N[y].body, d));
            if (c.handler)
              if (Array.isArray(c.handler))
                for (y = 0, P = c.handler.length; y < P; ++y)
                  d = ue(d, this.generateStatement(c.handler[y], be)), (c.finalizer || y + 1 !== P) && (d = this.maybeBlockSuffix(c.handler[y].body, d));
              else
                d = ue(d, this.generateStatement(c.handler, be)), c.finalizer && (d = this.maybeBlockSuffix(c.handler.body, d));
          }
          return c.finalizer && (d = ue(d, ["finally", this.maybeBlock(c.finalizer, be)])), d;
        },
        SwitchStatement: function(c, g) {
          var d, y, P, N, L, Z = this;
          if (Be(function() {
            d = [
              "switch" + v + "(",
              Z.generateExpression(c.discriminant, n.Sequence, $),
              ")" + v + "{" + M
            ];
          }), c.cases)
            for (L = be, P = 0, N = c.cases.length; P < N; ++P)
              P === N - 1 && (L |= Q), y = Oe(this.generateStatement(c.cases[P], L)), d.push(y), Le(ye(y).toString()) || d.push(M);
          return d.push(Oe("}")), d;
        },
        SwitchCase: function(c, g) {
          var d, y, P, N, L, Z = this;
          return Be(function() {
            for (c.test ? d = [
              ue("case", Z.generateExpression(c.test, n.Sequence, $)),
              ":"
            ] : d = ["default:"], P = 0, N = c.consequent.length, N && c.consequent[0].type === t.BlockStatement && (y = Z.maybeBlock(c.consequent[0], be), d.push(y), P = 1), P !== N && !Le(ye(d).toString()) && d.push(M), L = be; P < N; ++P)
              P === N - 1 && g & Q && (L |= Q), y = Oe(Z.generateStatement(c.consequent[P], L)), d.push(y), P + 1 !== N && !Le(ye(y).toString()) && d.push(M);
          }), d;
        },
        IfStatement: function(c, g) {
          var d, y, P, N = this;
          return Be(function() {
            d = [
              "if" + v + "(",
              N.generateExpression(c.test, n.Sequence, $),
              ")"
            ];
          }), P = g & Q, y = be, P && (y |= Q), c.alternate ? (d.push(this.maybeBlock(c.consequent, be)), d = this.maybeBlockSuffix(c.consequent, d), c.alternate.type === t.IfStatement ? d = ue(d, ["else ", this.generateStatement(c.alternate, y)]) : d = ue(d, ue("else", this.maybeBlock(c.alternate, y)))) : d.push(this.maybeBlock(c.consequent, y)), d;
        },
        ForStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = ["for" + v + "("], c.init ? c.init.type === t.VariableDeclaration ? d.push(y.generateStatement(c.init, Fe)) : (d.push(y.generateExpression(c.init, n.Sequence, oe)), d.push(";")) : d.push(";"), c.test && (d.push(v), d.push(y.generateExpression(c.test, n.Sequence, $))), d.push(";"), c.update && (d.push(v), d.push(y.generateExpression(c.update, n.Sequence, $))), d.push(")");
          }), d.push(this.maybeBlock(c.body, g & Q ? Ke : be)), d;
        },
        ForInStatement: function(c, g) {
          return this.generateIterationForStatement("in", c, g & Q ? Ke : be);
        },
        ForOfStatement: function(c, g) {
          return this.generateIterationForStatement("of", c, g & Q ? Ke : be);
        },
        LabeledStatement: function(c, g) {
          return [c.label.name + ":", this.maybeBlock(c.body, g & Q ? Ke : be)];
        },
        Program: function(c, g) {
          var d, y, P, N, L;
          for (N = c.body.length, d = [_ && N > 0 ? `
` : ""], L = $e, P = 0; P < N; ++P)
            !_ && P === N - 1 && (L |= Q), V && (P === 0 && (c.body[0].leadingComments || bt(c.range[0], c.body[P].range[0], d)), P > 0 && !c.body[P - 1].trailingComments && !c.body[P].leadingComments && bt(c.body[P - 1].range[1], c.body[P].range[0], d)), y = Oe(this.generateStatement(c.body[P], L)), d.push(y), P + 1 < N && !Le(ye(y).toString()) && (V && c.body[P + 1].leadingComments || d.push(M)), V && P === N - 1 && (c.body[P].trailingComments || bt(c.body[P].range[1], c.range[1], d));
          return d;
        },
        FunctionDeclaration: function(c, g) {
          return [
            ct(c, !0),
            "function",
            tt(c) || We(),
            c.id ? ce(c.id) : "",
            this.generateFunctionBody(c)
          ];
        },
        ReturnStatement: function(c, g) {
          return c.argument ? [ue(
            "return",
            this.generateExpression(c.argument, n.Sequence, $)
          ), this.semicolon(g)] : ["return" + this.semicolon(g)];
        },
        WhileStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = [
              "while" + v + "(",
              y.generateExpression(c.test, n.Sequence, $),
              ")"
            ];
          }), d.push(this.maybeBlock(c.body, g & Q ? Ke : be)), d;
        },
        WithStatement: function(c, g) {
          var d, y = this;
          return Be(function() {
            d = [
              "with" + v + "(",
              y.generateExpression(c.object, n.Sequence, $),
              ")"
            ];
          }), d.push(this.maybeBlock(c.body, g & Q ? Ke : be)), d;
        }
      }, $t(Ne.prototype, Ne.Statement), Ne.Expression = {
        SequenceExpression: function(c, g, d) {
          var y, P, N;
          for (n.Sequence < g && (d |= O), y = [], P = 0, N = c.expressions.length; P < N; ++P)
            y.push(this.generateExpression(c.expressions[P], n.Assignment, d)), P + 1 < N && y.push("," + v);
          return _e(y, n.Sequence, g);
        },
        AssignmentExpression: function(c, g, d) {
          return this.generateAssignment(c.left, c.right, c.operator, g, d);
        },
        ArrowFunctionExpression: function(c, g, d) {
          return _e(this.generateFunctionBody(c), n.ArrowFunction, g);
        },
        ConditionalExpression: function(c, g, d) {
          return n.Conditional < g && (d |= O), _e(
            [
              this.generateExpression(c.test, n.Coalesce, d),
              v + "?" + v,
              this.generateExpression(c.consequent, n.Assignment, d),
              v + ":" + v,
              this.generateExpression(c.alternate, n.Assignment, d)
            ],
            n.Conditional,
            g
          );
        },
        LogicalExpression: function(c, g, d) {
          return c.operator === "??" && (d |= ke), this.BinaryExpression(c, g, d);
        },
        BinaryExpression: function(c, g, d) {
          var y, P, N, L, Z, U;
          return L = r[c.operator], P = c.operator === "**" ? n.Postfix : L, N = c.operator === "**" ? L : L + 1, L < g && (d |= O), Z = this.generateExpression(c.left, P, d), U = Z.toString(), U.charCodeAt(U.length - 1) === 47 && u.code.isIdentifierPartES5(c.operator.charCodeAt(0)) ? y = [Z, We(), c.operator] : y = ue(Z, c.operator), Z = this.generateExpression(c.right, N, d), c.operator === "/" && Z.toString().charAt(0) === "/" || c.operator.slice(-1) === "<" && Z.toString().slice(0, 3) === "!--" ? (y.push(We()), y.push(Z)) : y = ue(y, Z), c.operator === "in" && !(d & O) ? ["(", y, ")"] : (c.operator === "||" || c.operator === "&&") && d & ke ? ["(", y, ")"] : _e(y, L, g);
        },
        CallExpression: function(c, g, d) {
          var y, P, N;
          for (y = [this.generateExpression(c.callee, n.Call, ge)], c.optional && y.push("?."), y.push("("), P = 0, N = c.arguments.length; P < N; ++P)
            y.push(this.generateExpression(c.arguments[P], n.Assignment, $)), P + 1 < N && y.push("," + v);
          return y.push(")"), d & te ? _e(y, n.Call, g) : ["(", y, ")"];
        },
        ChainExpression: function(c, g, d) {
          n.OptionalChaining < g && (d |= te);
          var y = this.generateExpression(c.expression, n.OptionalChaining, d);
          return _e(y, n.OptionalChaining, g);
        },
        NewExpression: function(c, g, d) {
          var y, P, N, L, Z;
          if (P = c.arguments.length, Z = d & Ae && !E && P === 0 ? je : ve, y = ue(
            "new",
            this.generateExpression(c.callee, n.New, Z)
          ), !(d & Ae) || E || P > 0) {
            for (y.push("("), N = 0, L = P; N < L; ++N)
              y.push(this.generateExpression(c.arguments[N], n.Assignment, $)), N + 1 < L && y.push("," + v);
            y.push(")");
          }
          return _e(y, n.New, g);
        },
        MemberExpression: function(c, g, d) {
          var y, P;
          return y = [this.generateExpression(c.object, n.Call, d & te ? ge : ve)], c.computed ? (c.optional && y.push("?."), y.push("["), y.push(this.generateExpression(c.property, n.Sequence, d & te ? $ : je)), y.push("]")) : (!c.optional && c.object.type === t.Literal && typeof c.object.value == "number" && (P = ye(y).toString(), P.indexOf(".") < 0 && !/[eExX]/.test(P) && u.code.isDecimalDigit(P.charCodeAt(P.length - 1)) && !(P.length >= 2 && P.charCodeAt(0) === 48) && y.push(" ")), y.push(c.optional ? "?." : "."), y.push(ce(c.property))), _e(y, n.Member, g);
        },
        MetaProperty: function(c, g, d) {
          var y;
          return y = [], y.push(typeof c.meta == "string" ? c.meta : ce(c.meta)), y.push("."), y.push(typeof c.property == "string" ? c.property : ce(c.property)), _e(y, n.Member, g);
        },
        UnaryExpression: function(c, g, d) {
          var y, P, N, L, Z;
          return P = this.generateExpression(c.argument, n.Unary, $), v === "" ? y = ue(c.operator, P) : (y = [c.operator], c.operator.length > 2 ? y = ue(y, P) : (L = ye(y).toString(), Z = L.charCodeAt(L.length - 1), N = P.toString().charCodeAt(0), ((Z === 43 || Z === 45) && Z === N || u.code.isIdentifierPartES5(Z) && u.code.isIdentifierPartES5(N)) && y.push(We()), y.push(P))), _e(y, n.Unary, g);
        },
        YieldExpression: function(c, g, d) {
          var y;
          return c.delegate ? y = "yield*" : y = "yield", c.argument && (y = ue(
            y,
            this.generateExpression(c.argument, n.Yield, $)
          )), _e(y, n.Yield, g);
        },
        AwaitExpression: function(c, g, d) {
          var y = ue(
            c.all ? "await*" : "await",
            this.generateExpression(c.argument, n.Await, $)
          );
          return _e(y, n.Await, g);
        },
        UpdateExpression: function(c, g, d) {
          return c.prefix ? _e(
            [
              c.operator,
              this.generateExpression(c.argument, n.Unary, $)
            ],
            n.Unary,
            g
          ) : _e(
            [
              this.generateExpression(c.argument, n.Postfix, $),
              c.operator
            ],
            n.Postfix,
            g
          );
        },
        FunctionExpression: function(c, g, d) {
          var y = [
            ct(c, !0),
            "function"
          ];
          return c.id ? (y.push(tt(c) || We()), y.push(ce(c.id))) : y.push(tt(c) || v), y.push(this.generateFunctionBody(c)), y;
        },
        ArrayPattern: function(c, g, d) {
          return this.ArrayExpression(c, g, d, !0);
        },
        ArrayExpression: function(c, g, d, y) {
          var P, N, L = this;
          return c.elements.length ? (N = y ? !1 : c.elements.length > 1, P = ["[", N ? M : ""], Be(function(Z) {
            var U, Me;
            for (U = 0, Me = c.elements.length; U < Me; ++U)
              c.elements[U] ? (P.push(N ? Z : ""), P.push(L.generateExpression(c.elements[U], n.Assignment, $))) : (N && P.push(Z), U + 1 === Me && P.push(",")), U + 1 < Me && P.push("," + (N ? M : v));
          }), N && !Le(ye(P).toString()) && P.push(M), P.push(N ? a : ""), P.push("]"), P) : "[]";
        },
        RestElement: function(c, g, d) {
          return "..." + this.generatePattern(c.argument);
        },
        ClassExpression: function(c, g, d) {
          var y, P;
          return y = ["class"], c.id && (y = ue(y, this.generateExpression(c.id, n.Sequence, $))), c.superClass && (P = ue("extends", this.generateExpression(c.superClass, n.Unary, $)), y = ue(y, P)), y.push(v), y.push(this.generateStatement(c.body, Ke)), y;
        },
        MethodDefinition: function(c, g, d) {
          var y, P;
          return c.static ? y = ["static" + v] : y = [], c.kind === "get" || c.kind === "set" ? P = [
            ue(c.kind, this.generatePropertyKey(c.key, c.computed)),
            this.generateFunctionBody(c.value)
          ] : P = [
            lt(c),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ], ue(y, P);
        },
        Property: function(c, g, d) {
          return c.kind === "get" || c.kind === "set" ? [
            c.kind,
            We(),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ] : c.shorthand ? c.value.type === "AssignmentPattern" ? this.AssignmentPattern(c.value, n.Sequence, $) : this.generatePropertyKey(c.key, c.computed) : c.method ? [
            lt(c),
            this.generatePropertyKey(c.key, c.computed),
            this.generateFunctionBody(c.value)
          ] : [
            this.generatePropertyKey(c.key, c.computed),
            ":" + v,
            this.generateExpression(c.value, n.Assignment, $)
          ];
        },
        ObjectExpression: function(c, g, d) {
          var y, P, N, L = this;
          return c.properties.length ? (y = c.properties.length > 1, Be(function() {
            N = L.generateExpression(c.properties[0], n.Sequence, $);
          }), !y && !sn(ye(N).toString()) ? ["{", v, N, v, "}"] : (Be(function(Z) {
            var U, Me;
            if (P = ["{", M, Z, N], y)
              for (P.push("," + M), U = 1, Me = c.properties.length; U < Me; ++U)
                P.push(Z), P.push(L.generateExpression(c.properties[U], n.Sequence, $)), U + 1 < Me && P.push("," + M);
          }), Le(ye(P).toString()) || P.push(M), P.push(a), P.push("}"), P)) : "{}";
        },
        AssignmentPattern: function(c, g, d) {
          return this.generateAssignment(c.left, c.right, "=", g, d);
        },
        ObjectPattern: function(c, g, d) {
          var y, P, N, L, Z, U = this;
          if (!c.properties.length)
            return "{}";
          if (L = !1, c.properties.length === 1)
            Z = c.properties[0], Z.type === t.Property && Z.value.type !== t.Identifier && (L = !0);
          else
            for (P = 0, N = c.properties.length; P < N; ++P)
              if (Z = c.properties[P], Z.type === t.Property && !Z.shorthand) {
                L = !0;
                break;
              }
          return y = ["{", L ? M : ""], Be(function(Me) {
            var ze, on;
            for (ze = 0, on = c.properties.length; ze < on; ++ze)
              y.push(L ? Me : ""), y.push(U.generateExpression(c.properties[ze], n.Sequence, $)), ze + 1 < on && y.push("," + (L ? M : v));
          }), L && !Le(ye(y).toString()) && y.push(M), y.push(L ? a : ""), y.push("}"), y;
        },
        ThisExpression: function(c, g, d) {
          return "this";
        },
        Super: function(c, g, d) {
          return "super";
        },
        Identifier: function(c, g, d) {
          return ce(c);
        },
        ImportDefaultSpecifier: function(c, g, d) {
          return ce(c.id || c.local);
        },
        ImportNamespaceSpecifier: function(c, g, d) {
          var y = ["*"], P = c.id || c.local;
          return P && y.push(v + "as" + We() + ce(P)), y;
        },
        ImportSpecifier: function(c, g, d) {
          var y = c.imported, P = [y.name], N = c.local;
          return N && N.name !== y.name && P.push(We() + "as" + We() + ce(N)), P;
        },
        ExportSpecifier: function(c, g, d) {
          var y = c.local, P = [y.name], N = c.exported;
          return N && N.name !== y.name && P.push(We() + "as" + We() + ce(N)), P;
        },
        Literal: function(c, g, d) {
          var y;
          if (c.hasOwnProperty("raw") && x && S.raw)
            try {
              if (y = x(c.raw).body[0].expression, y.type === t.Literal && y.value === c.value)
                return c.raw;
            } catch {
            }
          return c.regex ? "/" + c.regex.pattern + "/" + c.regex.flags : typeof c.value == "bigint" ? c.value.toString() + "n" : c.bigint ? c.bigint + "n" : c.value === null ? "null" : typeof c.value == "string" ? At(c.value) : typeof c.value == "number" ? Nt(c.value) : typeof c.value == "boolean" ? c.value ? "true" : "false" : Rn(c.value);
        },
        GeneratorExpression: function(c, g, d) {
          return this.ComprehensionExpression(c, g, d);
        },
        ComprehensionExpression: function(c, g, d) {
          var y, P, N, L, Z = this;
          return y = c.type === t.GeneratorExpression ? ["("] : ["["], S.moz.comprehensionExpressionStartsWithAssignment && (L = this.generateExpression(c.body, n.Assignment, $), y.push(L)), c.blocks && Be(function() {
            for (P = 0, N = c.blocks.length; P < N; ++P)
              L = Z.generateExpression(c.blocks[P], n.Sequence, $), P > 0 || S.moz.comprehensionExpressionStartsWithAssignment ? y = ue(y, L) : y.push(L);
          }), c.filter && (y = ue(y, "if" + v), L = this.generateExpression(c.filter, n.Sequence, $), y = ue(y, ["(", L, ")"])), S.moz.comprehensionExpressionStartsWithAssignment || (L = this.generateExpression(c.body, n.Assignment, $), y = ue(y, L)), y.push(c.type === t.GeneratorExpression ? ")" : "]"), y;
        },
        ComprehensionBlock: function(c, g, d) {
          var y;
          return c.left.type === t.VariableDeclaration ? y = [
            c.left.kind,
            We(),
            this.generateStatement(c.left.declarations[0], Fe)
          ] : y = this.generateExpression(c.left, n.Call, $), y = ue(y, c.of ? "of" : "in"), y = ue(y, this.generateExpression(c.right, n.Sequence, $)), ["for" + v + "(", y, ")"];
        },
        SpreadElement: function(c, g, d) {
          return [
            "...",
            this.generateExpression(c.argument, n.Assignment, $)
          ];
        },
        TaggedTemplateExpression: function(c, g, d) {
          var y = ge;
          d & te || (y = ve);
          var P = [
            this.generateExpression(c.tag, n.Call, y),
            this.generateExpression(c.quasi, n.Primary, st)
          ];
          return _e(P, n.TaggedTemplate, g);
        },
        TemplateElement: function(c, g, d) {
          return c.value.raw;
        },
        TemplateLiteral: function(c, g, d) {
          var y, P, N;
          for (y = ["`"], P = 0, N = c.quasis.length; P < N; ++P)
            y.push(this.generateExpression(c.quasis[P], n.Primary, $)), P + 1 < N && (y.push("${" + v), y.push(this.generateExpression(c.expressions[P], n.Sequence, $)), y.push(v + "}"));
          return y.push("`"), y;
        },
        ModuleSpecifier: function(c, g, d) {
          return this.Literal(c, g, d);
        },
        ImportExpression: function(c, g, d) {
          return _e([
            "import(",
            this.generateExpression(c.source, n.Assignment, $),
            ")"
          ], n.Call, g);
        }
      }, $t(Ne.prototype, Ne.Expression), Ne.prototype.generateExpression = function(c, g, d) {
        var y, P;
        return P = c.type || t.Property, S.verbatim && c.hasOwnProperty(S.verbatim) ? Qn(c, g) : (y = this[P](c, g, d), S.comment && (y = Ve(c, y)), ye(y, c));
      }, Ne.prototype.generateStatement = function(c, g) {
        var d, y;
        return d = this[c.type](c, g), S.comment && (d = Ve(c, d)), y = ye(d).toString(), c.type === t.Program && !_ && M === "" && y.charAt(y.length - 1) === `
` && (d = B ? ye(d).replaceRight(/\s+$/, "") : y.replace(/\s+$/, "")), ye(d, c);
      };
      function er(c) {
        var g;
        if (g = new Ne(), W(c))
          return g.generateStatement(c, be);
        if (Y(c))
          return g.generateExpression(c, n.Sequence, $);
        throw new Error("Unknown node type: " + c.type);
      }
      function ds(c, g) {
        var d = ot(), y, P;
        return g != null ? (typeof g.indent == "string" && (d.format.indent.style = g.indent), typeof g.base == "number" && (d.format.indent.base = g.base), g = Vt(d, g), o = g.format.indent.style, typeof g.base == "string" ? a = g.base : a = Ie(o, g.format.indent.base)) : (g = d, o = g.format.indent.style, a = Ie(o, g.format.indent.base)), f = g.format.json, h = g.format.renumber, m = f ? !1 : g.format.hexadecimal, p = f ? "double" : g.format.quotes, b = g.format.escapeless, M = g.format.newline, v = g.format.space, g.format.compact && (M = v = o = a = ""), E = g.format.parentheses, I = g.format.semicolons, _ = g.format.safeConcatenation, X = g.directive, x = f ? null : g.parse, B = g.sourceMap, k = g.sourceCode, V = g.format.preserveBlankLines && k !== null, S = g, B && (e.browser ? i = Vv.sourceMap.SourceNode : i = $v().SourceNode), y = er(c), B ? (P = y.toStringWithSourceMap({
          file: g.file,
          sourceRoot: g.sourceMapRoot
        }), g.sourceContent && P.map.setSourceContent(
          g.sourceMap,
          g.sourceContent
        ), g.sourceMapWithCode ? P : P.map.toString()) : (P = { code: y.toString(), map: null }, g.sourceMapWithCode ? P : P.code);
      }
      q = {
        indent: {
          style: "",
          base: 0
        },
        renumber: !0,
        hexadecimal: !0,
        quotes: "auto",
        escapeless: !0,
        compact: !0,
        parentheses: !1,
        semicolons: !1
      }, G = ot().format, e.version = oP.version, e.generate = ds, e.attachComments = s.attachComments, e.Precedence = Vt({}, n), e.browser = !1, e.FORMAT_MINIFY = q, e.FORMAT_DEFAULTS = G;
    })();
  }(Bs)), Bs;
}
var lP = cP();
const fP = /* @__PURE__ */ fm(lP);
class hP {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (t) => this.replacement = t
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(t, n, r, i) {
    t && n && (r != null ? t[n][r] = i : t[n] = i);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(t, n, r) {
    t && n && (r != null ? t[n].splice(r, 1) : delete t[n]);
  }
}
class pP extends hP {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(t, n) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (r) => this.replacement = r
    }, this.enter = t, this.leave = n;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(t, n, r, i) {
    if (t) {
      if (this.enter) {
        const u = this.should_skip, a = this.should_remove, o = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const f = this.should_skip, h = this.should_remove;
        if (this.should_skip = u, this.should_remove = a, this.replacement = o, f) return t;
        if (h) return null;
      }
      let s;
      for (s in t) {
        const u = t[s];
        if (u && typeof u == "object")
          if (Array.isArray(u)) {
            const a = (
              /** @type {Array<unknown>} */
              u
            );
            for (let o = 0; o < a.length; o += 1) {
              const f = a[o];
              No(f) && (this.visit(f, t, s, o) || o--);
            }
          } else No(u) && this.visit(u, t, s, null);
      }
      if (this.leave) {
        const u = this.replacement, a = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, t, n, r, i), this.replacement && (t = this.replacement, this.replace(n, r, i, t)), this.should_remove && this.remove(n, r, i);
        const o = this.should_remove;
        if (this.replacement = u, this.should_remove = a, o) return null;
      }
    }
    return t;
  }
}
function No(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function dP(e, { enter: t, leave: n }) {
  return new pP(t, n).visit(e, null);
}
let gm = [];
function vF(e) {
  gm.push(e);
}
function mP(e, t = {}) {
  const { wrapAsync: n = !1, addReturn: r = !0, emitMiniLocations: i = !0, emitWidgets: s = !0 } = t;
  let u = Iv(e, {
    ecmaVersion: 2022,
    allowAwaitOutsideFunction: !0,
    locations: !0
  }), a = [];
  const o = (p, b) => {
    const M = ea(`"${p}"`, b.start, e);
    a = a.concat(M);
  };
  let f = [];
  dP(u, {
    enter(p, b) {
      if (xP(p)) {
        const M = p.quasi.quasis[0].value.raw, v = p.quasi.start + 1;
        if (i) {
          const E = wP(M, v);
          a = a.concat(E);
        }
        return this.skip(), this.replace(SP(M, v));
      }
      if (yP(p, b)) {
        const { quasis: M } = p, { raw: v } = M[0].value;
        return this.skip(), i && o(v, p), this.replace(To(v, p));
      }
      if (gP(p)) {
        const { value: M } = p;
        return this.skip(), i && o(M, p), this.replace(To(M, p));
      }
      if (AP(p))
        return s && f.push({
          from: p.arguments[0].start,
          to: p.arguments[0].end,
          value: p.arguments[0].raw,
          // don't use value!
          min: p.arguments[1]?.value ?? 0,
          max: p.arguments[2]?.value ?? 1,
          step: p.arguments[3]?.value,
          type: "slider"
        }), this.replace(MP(p));
      if (bP(p)) {
        const M = p.callee.property.name, v = f.filter((I) => I.type === M).length, E = {
          to: p.end,
          index: v,
          type: M,
          id: t.id
        };
        return s && f.push(E), this.replace(vP(p, E));
      }
      if (PP(p, b))
        return this.replace(DP(p));
      if (FP(p))
        return this.replace(EP(p));
    },
    leave(p, b, M, v) {
    }
  });
  const { body: h } = u;
  if (!h?.[h.length - 1]?.expression)
    throw new Error("unexpected ast format without body expression");
  if (r) {
    const { expression: p } = h[h.length - 1];
    h[h.length - 1] = {
      type: "ReturnStatement",
      argument: p
    };
  }
  let m = fP.generate(u);
  return n && (m = `(async ()=>{${m}})()`), i ? { output: m, miniLocations: a, widgets: f } : { output: m };
}
function gP(e, t, n) {
  return e.type !== "Literal" ? !1 : e.raw[0] === '"';
}
function yP(e, t) {
  return e.type === "TemplateLiteral" && t.type !== "TaggedTemplateExpression";
}
function To(e, t) {
  const { start: n } = t;
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "m"
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: n }
    ],
    optional: !1
  };
}
function AP(e) {
  return e.type === "CallExpression" && e.callee.name === "slider";
}
function bP(e) {
  return e.type === "CallExpression" && gm.includes(e.callee.property?.name);
}
function MP(e) {
  const t = "slider_" + e.arguments[0].start;
  return e.arguments.unshift({
    type: "Literal",
    value: t,
    raw: t
  }), e.callee.name = "sliderWithID", e;
}
function CP(e) {
  return `${e.id || ""}_widget_${e.type}_${e.index}`;
}
function vP(e, t) {
  const n = CP(t);
  return e.arguments.unshift({
    type: "Literal",
    value: n,
    raw: n
  }), e;
}
function PP(e, t) {
  return e.type === "CallExpression" && e.callee.name === "samples" && t.type !== "AwaitExpression";
}
function DP(e) {
  return {
    type: "AwaitExpression",
    argument: e
  };
}
function FP(e) {
  return e.type === "LabeledStatement";
}
function EP(e) {
  return {
    type: "ExpressionStatement",
    expression: {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: e.body.expression,
        property: {
          type: "Identifier",
          name: "p"
        }
      },
      arguments: [
        {
          type: "Literal",
          value: e.label.name,
          raw: `'${e.label.name}'`
        }
      ]
    }
  };
}
function xP(e) {
  return e.type === "TaggedTemplateExpression" && e.tag.name === "tidal";
}
function wP(e, t) {
  return e.split("").reduce((n, r, i) => (r !== '"' || (!n.length || n[n.length - 1].length > 1 ? n.push([i + 1]) : n[n.length - 1].push(i)), n), []).map(([n, r]) => {
    const i = e.slice(n, r);
    return ea(`"${i}"`, t + n - 1);
  }).flat();
}
function SP(e, t) {
  return {
    type: "CallExpression",
    callee: {
      type: "Identifier",
      name: "tidal"
    },
    arguments: [
      { type: "Literal", value: e },
      { type: "Literal", value: t }
    ],
    optional: !1
  };
}
function la(e) {
  return e !== null && typeof e == "object" && "name" in e && typeof e.name == "string";
}
function fa(e) {
  return e !== null && typeof e == "object" && "step" in e && typeof e.step == "number" && "alt" in e && typeof e.alt == "number" && !isNaN(e.step) && !isNaN(e.alt);
}
var ym = [0, 2, 4, -1, 1, 3, 5], Am = ym.map(
  (e) => Math.floor(e * 7 / 12)
);
function bm(e) {
  const { step: t, alt: n, oct: r, dir: i = 1 } = e, s = ym[t] + 7 * n;
  if (r === void 0)
    return [i * s];
  const u = r - Am[t] - 4 * n;
  return [i * s, i * u];
}
var BP = [3, 0, 4, 1, 5, 2, 6];
function Mm(e) {
  const [t, n, r] = e, i = BP[_P(t)], s = Math.floor((t + 1) / 7);
  if (n === void 0)
    return { step: i, alt: s, dir: r };
  const u = n + 4 * s + Am[i];
  return { step: i, alt: s, oct: u, dir: r };
}
function _P(e) {
  const t = (e + 1) % 7;
  return t < 0 ? 7 + t : t;
}
var Ro = (e, t) => Array(Math.abs(t) + 1).join(e), hu = Object.freeze({
  empty: !0,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
}), kP = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})", IP = "(AA|A|P|M|m|d|dd)([-+]?\\d+)", VP = new RegExp(
  "^" + kP + "|" + IP + "$"
);
function NP(e) {
  const t = VP.exec(`${e}`);
  return t === null ? ["", ""] : t[1] ? [t[1], t[2]] : [t[4], t[3]];
}
var Lo = {};
function Yt(e) {
  return typeof e == "string" ? Lo[e] || (Lo[e] = TP(e)) : fa(e) ? Yt(LP(e)) : la(e) ? Yt(e.name) : hu;
}
var Go = [0, 2, 4, 5, 7, 9, 11], Cm = "PMMPPMM";
function TP(e) {
  const t = NP(e);
  if (t[0] === "")
    return hu;
  const n = +t[0], r = t[1], i = (Math.abs(n) - 1) % 7, s = Cm[i];
  if (s === "M" && r === "P")
    return hu;
  const u = s === "M" ? "majorable" : "perfectable", a = "" + n + r, o = n < 0 ? -1 : 1, f = n === 8 || n === -8 ? n : o * (i + 1), h = RP(u, r), m = Math.floor((Math.abs(n) - 1) / 7), p = o * (Go[i] + h + 12 * m), b = (o * (Go[i] + h) % 12 + 12) % 12, M = bm({ step: i, alt: h, oct: m, dir: o });
  return {
    empty: !1,
    name: a,
    num: n,
    q: r,
    step: i,
    alt: h,
    dir: o,
    type: u,
    simple: f,
    semitones: p,
    chroma: b,
    coord: M,
    oct: m
  };
}
function vm(e, t) {
  const [n, r = 0] = e, i = n * 7 + r * 12 < 0, s = t || i ? [-n, -r, -1] : [n, r, 1];
  return Yt(Mm(s));
}
function RP(e, t) {
  return t === "M" && e === "majorable" || t === "P" && e === "perfectable" ? 0 : t === "m" && e === "majorable" ? -1 : /^A+$/.test(t) ? t.length : /^d+$/.test(t) ? -1 * (e === "perfectable" ? t.length : t.length + 1) : 0;
}
function LP(e) {
  const { step: t, alt: n, oct: r = 0, dir: i } = e;
  if (!i)
    return "";
  const s = t + 1 + 7 * r, u = s === 0 ? t + 1 : s, a = i < 0 ? "-" : "", o = Cm[t] === "M" ? "majorable" : "perfectable";
  return a + u + GP(o, n);
}
function GP(e, t) {
  return t === 0 ? e === "majorable" ? "M" : "P" : t === -1 && e === "majorable" ? "m" : t > 0 ? Ro("A", t) : Ro("d", e === "perfectable" ? t : t + 1);
}
var Xo = (e, t) => Array(Math.abs(t) + 1).join(e), Pm = Object.freeze({
  empty: !0,
  name: "",
  letter: "",
  acc: "",
  pc: "",
  step: NaN,
  alt: NaN,
  chroma: NaN,
  height: NaN,
  coord: [],
  midi: null,
  freq: null
}), Zo = /* @__PURE__ */ new Map(), XP = (e) => "CDEFGAB".charAt(e), Ui = (e) => e < 0 ? Xo("b", -e) : Xo("#", e), ha = (e) => e[0] === "b" ? -e.length : e.length;
function we(e) {
  const t = JSON.stringify(e), n = Zo.get(t);
  if (n)
    return n;
  const r = typeof e == "string" ? zP(e) : fa(e) ? we(jP(e)) : la(e) ? we(e.name) : Pm;
  return Zo.set(t, r), r;
}
var ZP = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function pa(e) {
  const t = ZP.exec(e);
  return t ? [t[1].toUpperCase(), t[2].replace(/x/g, "##"), t[3], t[4]] : ["", "", "", ""];
}
function WP(e) {
  return we(Mm(e));
}
var OP = (e, t) => (e % t + t) % t, Ws = [0, 2, 4, 5, 7, 9, 11];
function zP(e) {
  const t = pa(e);
  if (t[0] === "" || t[3] !== "")
    return Pm;
  const n = t[0], r = t[1], i = t[2], s = (n.charCodeAt(0) + 3) % 7, u = ha(r), a = i.length ? +i : void 0, o = bm({ step: s, alt: u, oct: a }), f = n + r + i, h = n + r, m = (Ws[s] + u + 120) % 12, p = a === void 0 ? OP(Ws[s] + u, 12) - 12 * 99 : Ws[s] + u + 12 * (a + 1), b = p >= 0 && p <= 127 ? p : null, M = a === void 0 ? null : Math.pow(2, (p - 69) / 12) * 440;
  return {
    empty: !1,
    acc: r,
    alt: u,
    chroma: m,
    coord: o,
    freq: M,
    height: p,
    letter: n,
    midi: b,
    name: f,
    oct: a,
    pc: h,
    step: s
  };
}
function jP(e) {
  const { step: t, alt: n, oct: r } = e, i = XP(t);
  if (!i)
    return "";
  const s = i + Ui(n);
  return r || r === 0 ? s + r : s;
}
function zt(e, t) {
  const n = we(e), r = Array.isArray(t) ? t : Yt(t).coord;
  if (n.empty || !r || r.length < 2)
    return "";
  const i = n.coord, s = i.length === 1 ? [i[0] + r[0]] : [i[0] + r[0], i[1] + r[1]];
  return WP(s).name;
}
function Dm(e, t) {
  const n = e.length;
  return (r) => {
    if (!t) return "";
    const i = r < 0 ? (n - -r % n) % n : r % n, s = Math.floor(r / n), u = zt(t, [0, s]);
    return zt(u, e[i]);
  };
}
function Ji(e, t) {
  const n = we(e), r = we(t);
  if (n.empty || r.empty)
    return "";
  const i = n.coord, s = r.coord, u = s[0] - i[0], a = i.length === 2 && s.length === 2 ? s[1] - i[1] : -Math.floor(u * 7 / 12), o = r.height === n.height && r.midi !== null && n.oct === r.oct && n.step > r.step;
  return vm([u, a], o).name;
}
var Wo = (e, t) => Array(t + 1).join(e), $P = /^(_{1,}|=|\^{1,}|)([abcdefgABCDEFG])([,']*)$/;
function Fm(e) {
  const t = $P.exec(e);
  return t ? [t[1], t[2], t[3]] : ["", "", ""];
}
function Ni(e) {
  const [t, n, r] = Fm(e);
  if (n === "")
    return "";
  let i = 4;
  for (let u = 0; u < r.length; u++)
    i += r.charAt(u) === "," ? -1 : 1;
  const s = t[0] === "_" ? t.replace(/_/g, "b") : t[0] === "^" ? t.replace(/\^/g, "#") : "";
  return n.charCodeAt(0) > 96 ? n.toUpperCase() + s + (i + 1) : n + s + i;
}
function Em(e) {
  const t = we(e);
  if (t.empty || !t.oct && t.oct !== 0)
    return "";
  const { letter: n, acc: r, oct: i } = t, s = r[0] === "b" ? r.replace(/b/g, "_") : r.replace(/#/g, "^"), u = i > 4 ? n.toLowerCase() : n, a = i === 5 ? "" : i > 4 ? Wo("'", i - 5) : Wo(",", 4 - i);
  return s + u + a;
}
function qP(e, t) {
  return Em(zt(Ni(e), t));
}
function KP(e, t) {
  return Ji(Ni(e), Ni(t));
}
var HP = {
  abcToScientificNotation: Ni,
  scientificToAbcNotation: Em,
  tokenize: Fm,
  transpose: qP,
  distance: KP
};
function UP(e, t) {
  const n = [];
  for (; t--; n[t] = t + e) ;
  return n;
}
function JP(e, t) {
  const n = [];
  for (; t--; n[t] = e - t) ;
  return n;
}
function YP(e, t) {
  return e < t ? UP(e, t - e + 1) : JP(e, e - t + 1);
}
function QP(e, t) {
  const n = t.length, r = (e % n + n) % n;
  return t.slice(r, n).concat(t.slice(0, r));
}
function eD(e) {
  return e.filter((t) => t === 0 || t);
}
function xm(e) {
  return e.map((n) => we(n)).filter((n) => !n.empty).sort((n, r) => n.height - r.height).map((n) => n.name);
}
function tD(e) {
  return xm(e).filter((t, n, r) => n === 0 || t !== r[n - 1]);
}
function nD(e, t = Math.random) {
  let n, r, i = e.length;
  for (; i; )
    n = Math.floor(t() * i--), r = e[i], e[i] = e[n], e[n] = r;
  return e;
}
function wm(e) {
  return e.length === 0 ? [[]] : wm(e.slice(1)).reduce((t, n) => t.concat(
    e.map((r, i) => {
      const s = n.slice();
      return s.splice(i, 0, e[0]), s;
    })
  ), []);
}
const rD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compact: eD,
  permutations: wm,
  range: YP,
  rotate: QP,
  shuffle: nD,
  sortedNoteNames: xm,
  sortedUniqNoteNames: tD
}, Symbol.toStringTag, { value: "Module" }));
function iD(e, t) {
  const n = [];
  for (; t--; n[t] = t + e) ;
  return n;
}
function sD(e, t) {
  const n = [];
  for (; t--; n[t] = e - t) ;
  return n;
}
function Yi(e, t) {
  return e < t ? iD(e, t - e + 1) : sD(e, e - t + 1);
}
function xr(e, t) {
  const n = t.length, r = (e % n + n) % n;
  return t.slice(r, n).concat(t.slice(0, r));
}
function da(e) {
  return e.filter((t) => t === 0 || t);
}
function uD(e, t = Math.random) {
  let n, r, i = e.length;
  for (; i; )
    n = Math.floor(t() * i--), r = e[i], e[i] = e[n], e[n] = r;
  return e;
}
function Sm(e) {
  return e.length === 0 ? [[]] : Sm(e.slice(1)).reduce((t, n) => t.concat(
    e.map((r, i) => {
      const s = n.slice();
      return s.splice(i, 0, e[0]), s;
    })
  ), []);
}
var aD = {
  compact: da,
  permutations: Sm,
  range: Yi,
  rotate: xr,
  shuffle: uD
}, Bn = {
  empty: !0,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
}, ma = (e) => Number(e).toString(2).padStart(12, "0"), Oo = (e) => parseInt(e, 2), oD = /^[01]{12}$/;
function ga(e) {
  return oD.test(e);
}
var cD = (e) => typeof e == "number" && e >= 0 && e <= 4095, lD = (e) => e && ga(e.chroma), zo = { [Bn.chroma]: Bn };
function it(e) {
  const t = ga(e) ? e : cD(e) ? ma(e) : Array.isArray(e) ? vD(e) : lD(e) ? e.chroma : Bn.chroma;
  return zo[t] = zo[t] || CD(t);
}
var fD = it, Bm = (e) => it(e).chroma, hD = (e) => it(e).intervals, pD = (e) => it(e).setNum, dD = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function mD(e) {
  const t = [];
  for (let n = 0; n < 12; n++)
    e.charAt(n) === "1" && t.push(dD[n]);
  return t;
}
function gD(e) {
  return it(e).intervals.map((t) => zt("C", t));
}
function yD() {
  return Yi(2048, 4095).map(ma);
}
function ya(e, t = !0) {
  const r = it(e).chroma.split("");
  return da(
    r.map((i, s) => {
      const u = xr(s, r);
      return t && u[0] === "0" ? null : u.join("");
    })
  );
}
function AD(e, t) {
  return it(e).setNum === it(t).setNum;
}
function Qi(e) {
  const t = it(e).setNum;
  return (n) => {
    const r = it(n).setNum;
    return t && t !== r && (r & t) === r;
  };
}
function es(e) {
  const t = it(e).setNum;
  return (n) => {
    const r = it(n).setNum;
    return t && t !== r && (r | t) === r;
  };
}
function _m(e) {
  const t = it(e);
  return (n) => {
    const r = we(n);
    return t && !r.empty && t.chroma.charAt(r.chroma) === "1";
  };
}
function bD(e) {
  const t = _m(e);
  return (n) => n.filter(t);
}
var km = {
  get: it,
  chroma: Bm,
  num: pD,
  intervals: hD,
  chromas: yD,
  isSupersetOf: es,
  isSubsetOf: Qi,
  isNoteIncludedIn: _m,
  isEqual: AD,
  filter: bD,
  modes: ya,
  notes: gD,
  // deprecated
  pcset: fD
};
function MD(e) {
  const t = e.split("");
  return t.map((n, r) => xr(r, t).join(""));
}
function CD(e) {
  const t = Oo(e), n = MD(e).map(Oo).filter((s) => s >= 2048).sort()[0], r = ma(n), i = mD(e);
  return {
    empty: !1,
    name: "",
    setNum: t,
    chroma: e,
    normalized: r,
    intervals: i
  };
}
function vD(e) {
  if (e.length === 0)
    return Bn.chroma;
  let t;
  const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let r = 0; r < e.length; r++)
    t = we(e[r]), t.empty && (t = Yt(e[r])), t.empty || (n[t.chroma] = 1);
  return n.join("");
}
var PD = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
], DD = PD;
({
  ...Bn
});
var Aa = [], Ci = {};
function Im() {
  return Aa.slice();
}
function FD(e, t, n) {
  const r = xD(e), i = {
    ...it(e),
    name: n || "",
    quality: r,
    intervals: e,
    aliases: t
  };
  Aa.push(i), i.name && (Ci[i.name] = i), Ci[i.setNum] = i, Ci[i.chroma] = i, i.aliases.forEach((s) => ED(i, s));
}
function ED(e, t) {
  Ci[t] = e;
}
function xD(e) {
  const t = (n) => e.indexOf(n) !== -1;
  return t("5A") ? "Augmented" : t("3M") ? "Major" : t("5d") ? "Diminished" : t("3m") ? "Minor" : "Unknown";
}
DD.forEach(
  ([e, t, n]) => FD(e.split(" "), n.split(" "), t)
);
Aa.sort((e, t) => e.setNum - t.setNum);
var wD = (e) => {
  const t = e.reduce((n, r) => {
    const i = we(r).chroma;
    return i !== void 0 && (n[i] = n[i] || we(r).name), n;
  }, {});
  return (n) => t[n];
};
function SD(e, t = {}) {
  const n = e.map((i) => we(i).pc).filter((i) => i);
  return we.length === 0 ? [] : TD(n, 1, t).filter((i) => i.weight).sort((i, s) => s.weight - i.weight).map((i) => i.name);
}
var ts = {
  // 3m 000100000000
  // 3M 000010000000
  anyThirds: 384,
  // 5P 000000010000
  perfectFifth: 16,
  // 5d 000000100000
  // 5A 000000001000
  nonPerfectFifths: 40,
  anySeventh: 3
}, ns = (e) => (t) => !!(t & e), BD = ns(ts.anyThirds), _D = ns(ts.perfectFifth), kD = ns(ts.anySeventh), ID = ns(ts.nonPerfectFifths);
function VD(e) {
  const t = parseInt(e.chroma, 2);
  return BD(t) && _D(t) && kD(t);
}
function ND(e) {
  const t = parseInt(e, 2);
  return ID(t) ? e : (t | 16).toString(2);
}
function TD(e, t, n) {
  const r = e[0], i = we(r).chroma, s = wD(e), u = ya(e, !1), a = [];
  return u.forEach((o, f) => {
    const h = n.assumePerfectFifth && ND(o);
    Im().filter((p) => n.assumePerfectFifth && VD(p) ? p.chroma === h : p.chroma === o).forEach((p) => {
      const b = p.aliases[0], M = s(f);
      f !== i ? a.push({
        weight: 0.5 * t,
        name: `${M}${b}/${r}`
      }) : a.push({ weight: 1 * t, name: `${M}${b}` });
    });
  }), a;
}
function ui(e) {
  return e !== null && typeof e == "object" && "name" in e && typeof e.name == "string";
}
var Vm = [0, 2, 4, 5, 7, 9, 11], Nm = ({ step: e, alt: t }) => (Vm[e] + t + 120) % 12, ba = ({ step: e, alt: t, oct: n, dir: r = 1 }) => r * (Vm[e] + t + 12 * (n === void 0 ? -100 : n)), Tm = (e) => {
  const t = ba(e);
  return e.oct !== void 0 && t >= -12 && t <= 115 ? t + 12 : null;
};
function rs(e) {
  return e !== null && typeof e == "object" && "step" in e && typeof e.step == "number" && "alt" in e && typeof e.alt == "number";
}
var Rm = [0, 2, 4, -1, 1, 3, 5], Lm = Rm.map(
  (e) => Math.floor(e * 7 / 12)
);
function is(e) {
  const { step: t, alt: n, oct: r, dir: i = 1 } = e, s = Rm[t] + 7 * n;
  if (r === void 0)
    return [i * s];
  const u = r - Lm[t] - 4 * n;
  return [i * s, i * u];
}
var RD = [3, 0, 4, 1, 5, 2, 6];
function ss(e) {
  const [t, n, r] = e, i = RD[LD(t)], s = Math.floor((t + 1) / 7);
  if (n === void 0)
    return { step: i, alt: s, dir: r };
  const u = n + 4 * s + Lm[i];
  return { step: i, alt: s, oct: u, dir: r };
}
function LD(e) {
  const t = (e + 1) % 7;
  return t < 0 ? 7 + t : t;
}
var jo = (e, t) => Array(Math.abs(t) + 1).join(e), pu = { empty: !0, name: "", acc: "" }, GD = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})", XD = "(AA|A|P|M|m|d|dd)([-+]?\\d+)", ZD = new RegExp(
  "^" + GD + "|" + XD + "$"
);
function Ma(e) {
  const t = ZD.exec(`${e}`);
  return t === null ? ["", ""] : t[1] ? [t[1], t[2]] : [t[4], t[3]];
}
var $o = {};
function at(e) {
  return typeof e == "string" ? $o[e] || ($o[e] = WD(e)) : rs(e) ? at(zD(e)) : ui(e) ? at(e.name) : pu;
}
var qo = [0, 2, 4, 5, 7, 9, 11], Gm = "PMMPPMM";
function WD(e) {
  const t = Ma(e);
  if (t[0] === "")
    return pu;
  const n = +t[0], r = t[1], i = (Math.abs(n) - 1) % 7, s = Gm[i];
  if (s === "M" && r === "P")
    return pu;
  const u = s === "M" ? "majorable" : "perfectable", a = "" + n + r, o = n < 0 ? -1 : 1, f = n === 8 || n === -8 ? n : o * (i + 1), h = OD(u, r), m = Math.floor((Math.abs(n) - 1) / 7), p = o * (qo[i] + h + 12 * m), b = (o * (qo[i] + h) % 12 + 12) % 12, M = is({ step: i, alt: h, oct: m, dir: o });
  return {
    empty: !1,
    name: a,
    num: n,
    q: r,
    step: i,
    alt: h,
    dir: o,
    type: u,
    simple: f,
    semitones: p,
    chroma: b,
    coord: M,
    oct: m
  };
}
function ai(e, t) {
  const [n, r = 0] = e, i = n * 7 + r * 12 < 0, s = t || i ? [-n, -r, -1] : [n, r, 1];
  return at(ss(s));
}
function OD(e, t) {
  return t === "M" && e === "majorable" || t === "P" && e === "perfectable" ? 0 : t === "m" && e === "majorable" ? -1 : /^A+$/.test(t) ? t.length : /^d+$/.test(t) ? -1 * (e === "perfectable" ? t.length : t.length + 1) : 0;
}
function zD(e) {
  const { step: t, alt: n, oct: r = 0, dir: i } = e;
  if (!i)
    return "";
  const s = t + 1 + 7 * r, u = s === 0 ? t + 1 : s, a = i < 0 ? "-" : "", o = Gm[t] === "M" ? "majorable" : "perfectable";
  return a + u + jD(o, n);
}
function jD(e, t) {
  return t === 0 ? e === "majorable" ? "M" : "P" : t === -1 && e === "majorable" ? "m" : t > 0 ? jo("A", t) : jo("d", e === "perfectable" ? t : t + 1);
}
var Ko = (e, t) => Array(Math.abs(t) + 1).join(e), Xm = { empty: !0, name: "", pc: "", acc: "" }, Ho = /* @__PURE__ */ new Map(), Ca = (e) => "CDEFGAB".charAt(e), va = (e) => e < 0 ? Ko("b", -e) : Ko("#", e), Pa = (e) => e[0] === "b" ? -e.length : e.length;
function Qt(e) {
  const t = JSON.stringify(e), n = Ho.get(t);
  if (n)
    return n;
  const r = typeof e == "string" ? KD(e) : rs(e) ? Qt(HD(e)) : ui(e) ? Qt(e.name) : Xm;
  return Ho.set(t, r), r;
}
var $D = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function us(e) {
  const t = $D.exec(e);
  return t ? [t[1].toUpperCase(), t[2].replace(/x/g, "##"), t[3], t[4]] : ["", "", "", ""];
}
function Da(e) {
  return Qt(ss(e));
}
var qD = (e, t) => (e % t + t) % t, Os = [0, 2, 4, 5, 7, 9, 11];
function KD(e) {
  const t = us(e);
  if (t[0] === "" || t[3] !== "")
    return Xm;
  const n = t[0], r = t[1], i = t[2], s = (n.charCodeAt(0) + 3) % 7, u = Pa(r), a = i.length ? +i : void 0, o = is({ step: s, alt: u, oct: a }), f = n + r + i, h = n + r, m = (Os[s] + u + 120) % 12, p = a === void 0 ? qD(Os[s] + u, 12) - 12 * 99 : Os[s] + u + 12 * (a + 1), b = p >= 0 && p <= 127 ? p : null, M = a === void 0 ? null : Math.pow(2, (p - 69) / 12) * 440;
  return {
    empty: !1,
    acc: r,
    alt: u,
    chroma: m,
    coord: o,
    freq: M,
    height: p,
    letter: n,
    midi: b,
    name: f,
    oct: a,
    pc: h,
    step: s
  };
}
function HD(e) {
  const { step: t, alt: n, oct: r } = e, i = Ca(t);
  if (!i)
    return "";
  const s = i + va(n);
  return r || r === 0 ? s + r : s;
}
function yr(e, t) {
  const n = Qt(e), r = Array.isArray(t) ? t : at(t).coord;
  if (n.empty || !r || r.length < 2)
    return "";
  const i = n.coord, s = i.length === 1 ? [i[0] + r[0]] : [i[0] + r[0], i[1] + r[1]];
  return Da(s).name;
}
function as(e, t) {
  const n = e.length;
  return (r) => {
    if (!t)
      return "";
    const i = r < 0 ? (n - -r % n) % n : r % n, s = Math.floor(r / n), u = yr(t, [0, s]);
    return yr(u, e[i]);
  };
}
function Fa(e, t) {
  const n = Qt(e), r = Qt(t);
  if (n.empty || r.empty)
    return "";
  const i = n.coord, s = r.coord, u = s[0] - i[0], a = i.length === 2 && s.length === 2 ? s[1] - i[1] : -Math.floor(u * 7 / 12), o = r.height === n.height && r.midi !== null && n.midi !== null && n.step > r.step;
  return ai([u, a], o).name;
}
var Zm = (e, t) => Array(Math.abs(t) + 1).join(e);
function wr(e, t, n) {
  return function(...r) {
    return console.warn(`${e} is deprecated. Use ${t}.`), n.apply(this, r);
  };
}
var Wm = wr("isNamed", "isNamedPitch", ui);
const Om = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accToAlt: Pa,
  altToAcc: va,
  chroma: Nm,
  coordToInterval: ai,
  coordToNote: Da,
  coordinates: is,
  deprecate: wr,
  distance: Fa,
  fillStr: Zm,
  height: ba,
  interval: at,
  isNamed: Wm,
  isNamedPitch: ui,
  isPitch: rs,
  midi: Tm,
  note: Qt,
  pitch: ss,
  stepToLetter: Ca,
  tokenizeInterval: Ma,
  tokenizeNote: us,
  tonicIntervalsTransposer: as,
  transpose: yr
}, Symbol.toStringTag, { value: "Module" }));
var UD = [
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
], JD = UD, YD = {
  ...Bn,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
}, Sr = [], zn = {};
function Ea(e) {
  return zn[e] || YD;
}
var QD = wr("ChordType.chordType", "ChordType.get", Ea);
function e7() {
  return Sr.map((e) => e.name).filter((e) => e);
}
function t7() {
  return Sr.map((e) => e.aliases[0]).filter((e) => e);
}
function n7() {
  return Object.keys(zn);
}
function os() {
  return Sr.slice();
}
var r7 = wr("ChordType.entries", "ChordType.all", os);
function i7() {
  Sr = [], zn = {};
}
function zm(e, t, n) {
  const r = u7(e), i = {
    ...it(e),
    name: n || "",
    quality: r,
    intervals: e,
    aliases: t
  };
  Sr.push(i), i.name && (zn[i.name] = i), zn[i.setNum] = i, zn[i.chroma] = i, i.aliases.forEach((s) => s7(i, s));
}
function s7(e, t) {
  zn[t] = e;
}
function u7(e) {
  const t = (n) => e.indexOf(n) !== -1;
  return t("5A") ? "Augmented" : t("3M") ? "Major" : t("5d") ? "Diminished" : t("3m") ? "Minor" : "Unknown";
}
JD.forEach(
  ([e, t, n]) => zm(e.split(" "), n.split(" "), t)
);
Sr.sort((e, t) => e.setNum - t.setNum);
var jm = {
  names: e7,
  symbols: t7,
  get: Ea,
  all: os,
  add: zm,
  removeAll: i7,
  keys: n7,
  entries: r7,
  chordType: QD
}, a7 = [
  // Basic scales
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
  // Jazz common scales
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  // Modes
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  // 5-note scales
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  // 6-note scales
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  // 7-note scales
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  // Source https://en.wikipedia.org/wiki/Ukrainian_Dorian_scale
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  // 8-note scales
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  // 9-note scales
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  // 10-note scales
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  // 12-note scales
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
], o7 = a7, c7 = {
  ...Bn,
  intervals: [],
  aliases: []
}, cs = [], jn = {};
function $m() {
  return cs.map((e) => e.name);
}
function ls(e) {
  return jn[e] || c7;
}
var l7 = ls;
function Br() {
  return cs.slice();
}
var f7 = Br;
function h7() {
  return Object.keys(jn);
}
function p7() {
  cs = [], jn = {};
}
function qm(e, t, n = []) {
  const r = { ...it(e), name: t, intervals: e, aliases: n };
  return cs.push(r), jn[r.name] = r, jn[r.setNum] = r, jn[r.chroma] = r, r.aliases.forEach((i) => d7(r, i)), r;
}
function d7(e, t) {
  jn[t] = e;
}
o7.forEach(
  ([e, t, ...n]) => qm(e.split(" "), t, n)
);
var Km = {
  names: $m,
  get: ls,
  all: Br,
  add: qm,
  removeAll: p7,
  keys: h7,
  // deprecated
  entries: f7,
  scaleType: l7
}, du = {
  empty: !0,
  name: "",
  symbol: "",
  root: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function xa(e) {
  const [t, n, r, i] = us(e);
  return t === "" ? ["", e] : t === "A" && i === "ug" ? ["", "aug"] : [t + n, r + i];
}
function Yn(e) {
  if (e === "")
    return du;
  if (Array.isArray(e) && e.length === 2)
    return vi(e[1], e[0]);
  {
    const [t, n] = xa(e), r = vi(n, t);
    return r.empty ? vi(e) : r;
  }
}
function vi(e, t, n) {
  const r = Ea(e), i = Qt(t || ""), s = Qt(n || "");
  if (r.empty || t && i.empty || n && s.empty)
    return du;
  const u = Fa(i.pc, s.pc), a = r.intervals.indexOf(u) + 1;
  if (!s.empty && !a)
    return du;
  const o = Array.from(r.intervals);
  for (let p = 1; p < a; p++) {
    const b = o[0][0], M = o[0][1], v = parseInt(b, 10) + 7;
    o.push(`${v}${M}`), o.shift();
  }
  const f = i.empty ? [] : o.map((p) => yr(i, p));
  e = r.aliases.indexOf(e) !== -1 ? e : r.aliases[0];
  const h = `${i.empty ? "" : i.pc}${e}${s.empty || a <= 1 ? "" : "/" + s.pc}`, m = `${t ? i.pc + " " : ""}${r.name}${a > 1 && n ? " over " + s.pc : ""}`;
  return {
    ...r,
    name: m,
    symbol: h,
    type: r.name,
    root: s.name,
    intervals: o,
    rootDegree: a,
    tonic: i.name,
    notes: f
  };
}
var m7 = wr("Chord.chord", "Chord.get", Yn);
function g7(e, t) {
  const [n, r] = xa(e);
  return n ? yr(n, t) + r : e;
}
function y7(e) {
  const t = Yn(e), n = es(t.chroma);
  return Br().filter((r) => n(r.chroma)).map((r) => r.name);
}
function A7(e) {
  const t = Yn(e), n = es(t.chroma);
  return os().filter((r) => n(r.chroma)).map((r) => t.tonic + r.aliases[0]);
}
function b7(e) {
  const t = Yn(e), n = Qi(t.chroma);
  return os().filter((r) => n(r.chroma)).map((r) => t.tonic + r.aliases[0]);
}
function M7(e) {
  const { intervals: t, tonic: n } = Yn(e), r = as(t, n);
  return (i) => i ? r(i > 0 ? i - 1 : i) : "";
}
function C7(e) {
  const { intervals: t, tonic: n } = Yn(e);
  return as(t, n);
}
var v7 = {
  getChord: vi,
  get: Yn,
  detect: SD,
  chordScales: y7,
  extended: A7,
  reduced: b7,
  tokenize: xa,
  transpose: g7,
  degrees: M7,
  steps: C7,
  chord: m7
}, P7 = [
  [
    0.125,
    "dl",
    ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
  ],
  [0.25, "l", ["long", "longa"]],
  [0.5, "d", ["double whole", "double", "breve"]],
  [1, "w", ["whole", "semibreve"]],
  [2, "h", ["half", "minim"]],
  [4, "q", ["quarter", "crotchet"]],
  [8, "e", ["eighth", "quaver"]],
  [16, "s", ["sixteenth", "semiquaver"]],
  [32, "t", ["thirty-second", "demisemiquaver"]],
  [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
  [128, "h", ["hundred twenty-eighth"]],
  [256, "th", ["two hundred fifty-sixth"]]
], D7 = P7, fs = [];
D7.forEach(
  ([e, t, n]) => k7(e, t, n)
);
var F7 = {
  empty: !0,
  name: "",
  value: 0,
  fraction: [0, 0],
  shorthand: "",
  dots: "",
  names: []
};
function E7() {
  return fs.reduce((e, t) => (t.names.forEach((n) => e.push(n)), e), []);
}
function x7() {
  return fs.map((e) => e.shorthand);
}
var w7 = /^([^.]+)(\.*)$/;
function wa(e) {
  const [t, n, r] = w7.exec(e) || [], i = fs.find(
    (a) => a.shorthand === n || a.names.includes(n)
  );
  if (!i)
    return F7;
  const s = I7(i.fraction, r.length), u = s[0] / s[1];
  return { ...i, name: e, dots: r, value: u, fraction: s };
}
var S7 = (e) => wa(e).value, B7 = (e) => wa(e).fraction, _7 = { names: E7, shorthands: x7, get: wa, value: S7, fraction: B7 };
function k7(e, t, n) {
  fs.push({
    empty: !1,
    dots: "",
    name: "",
    value: 1 / e,
    fraction: e < 1 ? [1 / e, 1] : [1, e],
    shorthand: t,
    names: n
  });
}
function I7(e, t) {
  const n = Math.pow(2, t);
  let r = e[0] * n, i = e[1] * n;
  const s = r;
  for (let u = 0; u < t; u++)
    r += s / Math.pow(2, u + 1);
  for (; r % 2 === 0 && i % 2 === 0; )
    r /= 2, i /= 2;
  return [r, i];
}
function V7() {
  return "1P 2M 3M 4P 5P 6m 7m".split(" ");
}
var Hm = at, N7 = (e) => at(e).name, T7 = (e) => at(e).semitones, R7 = (e) => at(e).q, L7 = (e) => at(e).num;
function G7(e) {
  const t = at(e);
  return t.empty ? "" : t.simple + t.q;
}
function X7(e) {
  const t = at(e);
  if (t.empty)
    return "";
  const n = (7 - t.step) % 7, r = t.type === "perfectable" ? -t.alt : -(t.alt + 1);
  return at({ step: n, alt: r, oct: t.oct, dir: t.dir }).name;
}
var Z7 = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7], W7 = "P m M m M P d P m M m M".split(" ");
function O7(e) {
  const t = e < 0 ? -1 : 1, n = Math.abs(e), r = n % 12, i = Math.floor(n / 12);
  return t * (Z7[r] + 7 * i) + W7[r];
}
var z7 = Ji, Um = Jm((e, t) => [e[0] + t[0], e[1] + t[1]]), j7 = (e) => (t) => Um(e, t), $7 = Jm((e, t) => [e[0] - t[0], e[1] - t[1]]);
function q7(e, t) {
  const n = Hm(e);
  if (n.empty)
    return "";
  const [r, i, s] = n.coord;
  return ai([r + t, i, s]).name;
}
var Ar = {
  names: V7,
  get: Hm,
  name: N7,
  num: L7,
  semitones: T7,
  quality: R7,
  fromSemitones: O7,
  distance: z7,
  invert: X7,
  simplify: G7,
  add: Um,
  addTo: j7,
  substract: $7,
  transposeFifths: q7
};
function Jm(e) {
  return (t, n) => {
    const r = at(t).coord, i = at(n).coord;
    if (r && i) {
      const s = e(r, i);
      return ai(s).name;
    }
  };
}
function Ym(e) {
  return +e >= 0 && +e <= 127;
}
function Qm(e) {
  if (Ym(e))
    return +e;
  const t = we(e);
  return t.empty ? null : t.midi;
}
function K7(e, t = 440) {
  return Math.pow(2, (e - 69) / 12) * t;
}
var H7 = Math.log(2), U7 = Math.log(440);
function Sa(e) {
  const t = 12 * (Math.log(e) - U7) / H7 + 69;
  return Math.round(t * 100) / 100;
}
var J7 = "C C# D D# E F F# G G# A A# B".split(" "), Y7 = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function Tn(e, t = {}) {
  if (isNaN(e) || e === -1 / 0 || e === 1 / 0) return "";
  e = Math.round(e);
  const r = (t.sharps === !0 ? J7 : Y7)[e % 12];
  if (t.pitchClass)
    return r;
  const i = Math.floor(e / 12) - 1;
  return r + i;
}
function Ba(e) {
  return e % 12;
}
function Q7(e) {
  return e.split("").reduce((t, n, r) => (r < 12 && n === "1" && t.push(r), t), []);
}
function e5(e) {
  return e.map(Ba).sort((t, n) => t - n).filter((t, n, r) => n === 0 || t !== r[n - 1]);
}
function _a(e) {
  return Array.isArray(e) ? e5(e) : Q7(e);
}
function t5(e) {
  const t = _a(e);
  return (n) => {
    const r = Ba(n);
    for (let i = 0; i < 12; i++) {
      if (t.includes(r + i)) return n + i;
      if (t.includes(r - i)) return n - i;
    }
  };
}
function eg(e, t) {
  const n = _a(e), r = n.length;
  return (i) => {
    const s = i < 0 ? (r - -i % r) % r : i % r, u = Math.floor(i / r);
    return n[s] + u * 12 + t;
  };
}
function n5(e, t) {
  const n = eg(e, t);
  return (r) => {
    if (r !== 0)
      return n(r > 0 ? r - 1 : r);
  };
}
var r5 = {
  chroma: Ba,
  freqToMidi: Sa,
  isMidi: Ym,
  midiToFreq: K7,
  midiToNoteName: Tn,
  pcsetNearest: t5,
  pcset: _a,
  pcsetDegrees: n5,
  pcsetSteps: eg,
  toMidi: Qm
}, i5 = ["C", "D", "E", "F", "G", "A", "B"], tg = (e) => e.name, ng = (e) => e.map(we).filter((t) => !t.empty);
function s5(e) {
  return e === void 0 ? i5.slice() : Array.isArray(e) ? ng(e).map(tg) : [];
}
var jt = we, u5 = (e) => jt(e).name, a5 = (e) => jt(e).pc, o5 = (e) => jt(e).acc, c5 = (e) => jt(e).oct, l5 = (e) => jt(e).midi, f5 = (e) => jt(e).freq, h5 = (e) => jt(e).chroma;
function rg(e) {
  return Tn(e);
}
function p5(e) {
  return Tn(Sa(e));
}
function d5(e) {
  return Tn(Sa(e), { sharps: !0 });
}
function m5(e) {
  return Tn(e, { sharps: !0 });
}
var g5 = Ji, Wt = zt, y5 = zt, ig = (e) => (t) => Wt(t, e), A5 = ig, sg = (e) => (t) => Wt(e, t), b5 = sg;
function Ti(e, t) {
  return Wt(e, [t, 0]);
}
var M5 = Ti;
function C5(e, t) {
  return Wt(e, [0, t]);
}
var ka = (e, t) => e.height - t.height, v5 = (e, t) => t.height - e.height;
function ug(e, t) {
  return t = t || ka, ng(e).sort(t).map(tg);
}
function ag(e) {
  return ug(e, ka).filter(
    (t, n, r) => n === 0 || t !== r[n - 1]
  );
}
var P5 = (e) => {
  const t = jt(e);
  return t.empty ? "" : Tn(t.midi || t.chroma, {
    sharps: t.alt > 0,
    pitchClass: t.midi === null
  });
};
function og(e, t) {
  const n = jt(e);
  if (n.empty)
    return "";
  const r = jt(
    t || Tn(n.midi || n.chroma, {
      sharps: n.alt < 0,
      pitchClass: !0
    })
  );
  if (r.empty || r.chroma !== n.chroma)
    return "";
  if (n.oct === void 0)
    return r.pc;
  const i = n.chroma - n.alt, s = r.chroma - r.alt, u = i > 11 || s < 0 ? -1 : i < 0 || s > 11 ? 1 : 0, a = n.oct + u;
  return r.pc + a;
}
var _n = {
  names: s5,
  get: jt,
  name: u5,
  pitchClass: a5,
  accidentals: o5,
  octave: c5,
  midi: l5,
  ascending: ka,
  descending: v5,
  distance: g5,
  sortedNames: ug,
  sortedUniqNames: ag,
  fromMidi: rg,
  fromMidiSharps: m5,
  freq: f5,
  fromFreq: p5,
  fromFreqSharps: d5,
  chroma: h5,
  transpose: Wt,
  tr: y5,
  transposeBy: ig,
  trBy: A5,
  transposeFrom: sg,
  trFrom: b5,
  transposeFifths: Ti,
  transposeOctaves: C5,
  trFifths: M5,
  simplify: P5,
  enharmonic: og
}, cg = { empty: !0, name: "", chordType: "" }, Uo = {};
function kn(e) {
  return typeof e == "string" ? Uo[e] || (Uo[e] = B5(e)) : typeof e == "number" ? kn(hs[e] || "") : fa(e) ? E5(e) : la(e) ? kn(e.name) : cg;
}
var D5 = kn;
function F5(e = !0) {
  return (e ? hs : S5).slice();
}
function E5(e) {
  return kn(Ui(e.alt) + hs[e.step]);
}
var x5 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
function w5(e) {
  return x5.exec(e) || ["", "", "", ""];
}
var lg = "I II III IV V VI VII", hs = lg.split(" "), S5 = lg.toLowerCase().split(" ");
function B5(e) {
  const [t, n, r, i] = w5(e);
  if (!r)
    return cg;
  const s = r.toUpperCase(), u = hs.indexOf(s), a = ha(n), o = 1;
  return {
    empty: !1,
    name: t,
    roman: r,
    interval: Yt({ step: u, alt: a, dir: o }).name,
    acc: n,
    chordType: i,
    alt: a,
    step: u,
    major: r === s,
    oct: 0,
    dir: o
  };
}
var _5 = {
  names: F5,
  get: kn,
  // deprecated
  romanNumeral: D5
}, rt = Object.freeze([]), fg = {
  type: "major",
  tonic: "",
  alteration: 0,
  keySignature: ""
}, Pi = {
  tonic: "",
  grades: rt,
  intervals: rt,
  scale: rt,
  triads: rt,
  chords: rt,
  chordsHarmonicFunction: rt,
  chordScales: rt,
  secondaryDominants: rt,
  secondaryDominantSupertonics: rt,
  substituteDominantsMinorRelative: rt,
  substituteDominants: rt,
  substituteDominantSupertonics: rt,
  secondaryDominantsMinorRelative: rt
}, k5 = {
  ...fg,
  ...Pi,
  type: "major",
  minorRelative: "",
  scale: rt,
  substituteDominants: rt,
  secondaryDominantSupertonics: rt,
  substituteDominantsMinorRelative: rt
}, I5 = {
  ...fg,
  type: "minor",
  relativeMajor: "",
  natural: Pi,
  harmonic: Pi,
  melodic: Pi
}, zs = (e, t, n = "") => t.map((r, i) => `${e[i]}${n}${r}`);
function ps(e, t, n, r, i) {
  return (s) => {
    const u = e.map((b) => kn(b).interval || ""), a = u.map((b) => Wt(s, b)), o = zs(a, n), f = a.map((b) => Wt(b, "5P")).map(
      (b) => (
        // A secondary dominant is a V chord which:
        // 1. is not diatonic to the key,
        // 2. it must have a diatonic root.
        a.includes(b) && !o.includes(b + "7") ? b + "7" : ""
      )
    ), h = Jo(
      f,
      t
    ), m = f.map((b) => {
      if (!b) return "";
      const M = b.slice(0, -1);
      return Wt(M, "5d") + "7";
    }), p = Jo(
      m,
      t
    );
    return {
      tonic: s,
      grades: e,
      intervals: u,
      scale: a,
      triads: zs(a, t),
      chords: o,
      chordsHarmonicFunction: r.slice(),
      chordScales: zs(a, i, " "),
      secondaryDominants: f,
      secondaryDominantSupertonics: h,
      substituteDominants: m,
      substituteDominantSupertonics: p,
      // @deprecated use secondaryDominantsSupertonic
      secondaryDominantsMinorRelative: h,
      // @deprecated use secondaryDominantsSupertonic
      substituteDominantsMinorRelative: p
    };
  };
}
var Jo = (e, t) => e.map((n, r) => {
  if (!n) return "";
  const i = n.slice(0, -1), s = Wt(i, "5P");
  return t[r].endsWith("m") ? s + "m7" : s + "m7b5";
}), hg = (e, t) => {
  const n = we(e), r = we(t);
  return n.empty || r.empty ? 0 : r.coord[0] - n.coord[0];
}, V5 = ps(
  "I II III IV V VI VII".split(" "),
  " m m   m dim".split(" "),
  "maj7 m7 m7 maj7 7 m7 m7b5".split(" "),
  "T SD T SD D T D".split(" "),
  "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(",")
), N5 = ps(
  "I II bIII IV V bVI bVII".split(" "),
  "m dim  m m  ".split(" "),
  "m7 m7b5 maj7 m7 m7 maj7 7".split(" "),
  "T SD T SD D SD SD".split(" "),
  "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(",")
), T5 = ps(
  "I II bIII IV V bVI VII".split(" "),
  "m dim aug m   dim".split(" "),
  "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "),
  "T SD T SD D SD D".split(" "),
  "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(
    ","
  )
), R5 = ps(
  "I II bIII IV V VI VII".split(" "),
  "m m aug   dim dim".split(" "),
  "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "),
  "T SD T SD D  ".split(" "),
  "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(
    ","
  )
);
function L5(e) {
  const t = we(e).pc;
  if (!t) return k5;
  const n = V5(t), r = hg("C", t);
  return {
    ...n,
    type: "major",
    minorRelative: Wt(t, "-3m"),
    alteration: r,
    keySignature: Ui(r)
  };
}
function G5(e) {
  const t = we(e).pc;
  if (!t) return I5;
  const n = hg("C", t) - 3;
  return {
    type: "minor",
    tonic: t,
    relativeMajor: Wt(t, "3m"),
    alteration: n,
    keySignature: Ui(n),
    natural: N5(t),
    harmonic: T5(t),
    melodic: R5(t)
  };
}
function X5(e) {
  return typeof e == "number" ? Ti("C", e) : typeof e == "string" && /^b+|#+$/.test(e) ? Ti("C", ha(e)) : null;
}
var Z5 = { majorKey: L5, majorTonicFromKeySignature: X5, minorKey: G5 }, W5 = Yt;
function O5(e) {
  const t = Yt(e);
  return t.empty ? "" : t.simple + t.q;
}
function z5(e, t) {
  const n = W5(e);
  if (n.empty) return "";
  const [r, i, s] = n.coord;
  return vm([r + t, i, s]).name;
}
var Ia = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
], Yo = {
  ...Bn,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
}, Va = Ia.map(K5), mu = {};
Va.forEach((e) => {
  mu[e.name] = e, e.aliases.forEach((t) => {
    mu[t] = e;
  });
});
function Hn(e) {
  return typeof e == "string" ? mu[e.toLowerCase()] || Yo : e && e.name ? Hn(e.name) : Yo;
}
var j5 = Hn;
function pg() {
  return Va.slice();
}
var $5 = pg;
function q5() {
  return Va.map((e) => e.name);
}
function K5(e) {
  const [t, n, r, i, s, u, a] = e, o = a ? [a] : [], f = Number(n).toString(2);
  return {
    empty: !1,
    intervals: ls(i).intervals,
    modeNum: t,
    chroma: f,
    normalized: f,
    name: i,
    setNum: n,
    alt: r,
    triad: s,
    seventh: u,
    aliases: o
  };
}
function H5(e, t) {
  return Hn(e).intervals.map((n) => zt(t, n));
}
function dg(e) {
  return (t, n) => {
    const r = Hn(t);
    if (r.empty) return [];
    const i = xr(r.modeNum, e), s = r.intervals.map((u) => zt(n, u));
    return i.map((u, a) => s[a] + u);
  };
}
var U5 = dg(Ia.map((e) => e[4])), J5 = dg(Ia.map((e) => e[5]));
function mg(e, t) {
  const n = Hn(t), r = Hn(e);
  return n.empty || r.empty ? "" : O5(z5("1P", r.alt - n.alt));
}
function Y5(e, t, n) {
  return zt(n, mg(e, t));
}
var Q5 = {
  get: Hn,
  names: q5,
  all: pg,
  distance: mg,
  relativeTonic: Y5,
  notes: H5,
  triads: U5,
  seventhChords: J5,
  // deprecated
  entries: $5,
  mode: j5
};
function e9(e) {
  const [t, n, r, i] = pa(e);
  return t === "" ? js("", e) : t === "A" && i === "ug" ? js("", "aug") : js(t + n, r + i);
}
function js(e, t) {
  const n = t.split("/");
  if (n.length === 1)
    return [e, n[0], ""];
  const [r, i, s, u] = pa(n[1]);
  return r !== "" && s === "" && u === "" ? [e, n[0], r + i] : [e, t, ""];
}
function t9(e, t) {
  return t.map(kn).map(
    (r) => zt(e, Yt(r)) + r.chordType
  );
}
function n9(e, t) {
  return t.map((n) => {
    const [r, i] = e9(n), s = Ji(e, r);
    return kn(Yt(s)).name + i;
  });
}
var r9 = { fromRomanNumerals: t9, toRomanNumerals: n9 };
function gg(e) {
  const t = da(
    e.map((n) => typeof n == "number" ? n : Qm(n))
  );
  return !e.length || t.length !== e.length ? [] : t.reduce(
    (n, r) => {
      const i = n[n.length - 1];
      return n.concat(Yi(i, r).slice(1));
    },
    [t[0]]
  );
}
function i9(e, t) {
  return gg(e).map((n) => Tn(n, t));
}
var s9 = { numeric: gg, chromatic: i9 }, u9 = {
  empty: !0,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function yg(e) {
  if (typeof e != "string")
    return ["", ""];
  const t = e.indexOf(" "), n = we(e.substring(0, t));
  if (n.empty) {
    const i = we(e);
    return i.empty ? ["", e] : [i.name, ""];
  }
  const r = e.substring(n.name.length + 1).toLowerCase();
  return [n.name, r.length ? r : ""];
}
var a9 = $m;
function en(e) {
  const t = Array.isArray(e) ? e : yg(e), n = we(t[0]).name, r = ls(t[1]);
  if (r.empty)
    return u9;
  const i = r.name, s = n ? r.intervals.map((a) => zt(n, a)) : [], u = n ? n + " " + i : i;
  return { ...r, name: u, type: i, tonic: n, notes: s };
}
var o9 = en;
function c9(e, t = {}) {
  const n = Bm(e), r = we(t.tonic ?? e[0] ?? ""), i = r.chroma;
  if (i === void 0)
    return [];
  const s = n.split("");
  s[i] = "1";
  const u = xr(i, s).join(""), a = Br().find((f) => f.chroma === u), o = [];
  return a && o.push(r.name + " " + a.name), t.match === "exact" || Ag(u).forEach((f) => {
    o.push(r.name + " " + f);
  }), o;
}
function l9(e) {
  const t = en(e), n = Qi(t.chroma);
  return Im().filter((r) => n(r.chroma)).map((r) => r.aliases[0]);
}
function Ag(e) {
  const t = ga(e) ? e : en(e).chroma, n = es(t);
  return Br().filter((r) => n(r.chroma)).map((r) => r.name);
}
function f9(e) {
  const t = Qi(en(e).chroma);
  return Br().filter((n) => t(n.chroma)).map((n) => n.name);
}
function bg(e) {
  const t = e.map((i) => we(i).pc).filter((i) => i), n = t[0], r = ag(t);
  return xr(r.indexOf(n), r);
}
function h9(e) {
  const t = en(e);
  if (t.empty)
    return [];
  const n = t.tonic ? t.notes : t.intervals;
  return ya(t.chroma).map((r, i) => {
    const s = en(r).name;
    return s ? [n[i], s] : ["", ""];
  }).filter((r) => r[0]);
}
function p9(e) {
  const t = Array.isArray(e) ? bg(e) : en(e).notes, n = t.map((r) => we(r).chroma);
  return (r) => {
    const i = we(typeof r == "number" ? rg(r) : r), s = i.height;
    if (s === void 0) return;
    const u = s % 12, a = n.indexOf(u);
    if (a !== -1)
      return og(i.name, t[a]);
  };
}
function d9(e) {
  const t = p9(e);
  return (n, r) => {
    const i = we(n).height, s = we(r).height;
    return i === void 0 || s === void 0 ? [] : Yi(i, s).map(t).filter((u) => u);
  };
}
function m9(e) {
  const { intervals: t, tonic: n } = en(e), r = Dm(t, n);
  return (i) => i ? r(i > 0 ? i - 1 : i) : "";
}
function g9(e) {
  const { intervals: t, tonic: n } = en(e);
  return Dm(t, n);
}
var br = {
  degrees: m9,
  detect: c9,
  extended: Ag,
  get: en,
  modeNames: h9,
  names: a9,
  rangeOf: d9,
  reduced: f9,
  scaleChords: l9,
  scaleNotes: bg,
  steps: g9,
  tokenize: yg,
  // deprecated
  scale: o9
}, y9 = {
  empty: !0,
  name: "",
  upper: void 0,
  lower: void 0,
  type: void 0,
  additive: []
}, A9 = ["4/4", "3/4", "2/4", "2/2", "12/8", "9/8", "6/8", "3/8"];
function b9() {
  return A9.slice();
}
var M9 = /^(\d*\d(?:\+\d)*)\/(\d+)$/, Qo = /* @__PURE__ */ new Map();
function C9(e) {
  const t = JSON.stringify(e), n = Qo.get(t);
  if (n)
    return n;
  const r = D9(Na(e));
  return Qo.set(t, r), r;
}
function Na(e) {
  if (typeof e == "string") {
    const [s, u, a] = M9.exec(e) || [];
    return Na([u, a]);
  }
  const [t, n] = e, r = +n;
  if (typeof t == "number")
    return [t, r];
  const i = t.split("+").map((s) => +s);
  return i.length === 1 ? [i[0], r] : [i, r];
}
var v9 = { names: b9, parse: Na, get: C9 }, P9 = (e) => Math.log(e) / Math.log(2) % 1 === 0;
function D9([e, t]) {
  const n = Array.isArray(e) ? e.reduce((a, o) => a + o, 0) : e, r = t;
  if (n === 0 || r === 0)
    return y9;
  const i = Array.isArray(e) ? `${e.join("+")}/${t}` : `${e}/${t}`, s = Array.isArray(e) ? e : [], u = r === 4 || r === 2 ? "simple" : r === 8 && n % 3 === 0 ? "compound" : P9(r) ? "irregular" : "irrational";
  return {
    empty: !1,
    name: i,
    type: u,
    upper: n,
    lower: r,
    additive: s
  };
}
var F9 = Om, E9 = km, x9 = jm, w9 = Km;
const S9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbcNotation: HP,
  Array: rD,
  Chord: v7,
  ChordDictionary: x9,
  ChordType: jm,
  Collection: aD,
  Core: Om,
  DurationValue: _7,
  Interval: Ar,
  Key: Z5,
  Midi: r5,
  Mode: Q5,
  Note: _n,
  PcSet: E9,
  Pcset: km,
  Progression: r9,
  Range: s9,
  RomanNumeral: _5,
  Scale: br,
  ScaleDictionary: w9,
  ScaleType: Km,
  TimeSignature: v9,
  Tonal: F9,
  accToAlt: Pa,
  altToAcc: va,
  chroma: Nm,
  coordToInterval: ai,
  coordToNote: Da,
  coordinates: is,
  deprecate: wr,
  distance: Fa,
  fillStr: Zm,
  height: ba,
  interval: at,
  isNamed: Wm,
  isNamedPitch: ui,
  isPitch: rs,
  midi: Tm,
  note: Qt,
  pitch: ss,
  stepToLetter: Ca,
  tokenizeInterval: Ma,
  tokenizeNote: us,
  tonicIntervalsTransposer: as,
  transpose: yr
}, Symbol.toStringTag, { value: "Module" })), B9 = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], _9 = ["c", "db", "d", "eb", "e", "f", "gb", "g", "ab", "a", "bb", "b"], k9 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], I9 = { b: -1, "#": 1 }, V9 = (e) => {
  const [t, ...n] = e.split("");
  return _9.indexOf(t.toLowerCase()) + n.reduce((r, i) => r + I9[i], 0);
};
function N9(e) {
  const t = (e || "").match(/^([A-G][b#]*)([^/]*)[/]?([A-G][b#]*)?$/);
  return t ? t.slice(1) : [];
}
const gu = (e) => e % 12, Mg = (e) => {
  let t = Number(e);
  return isNaN(t) ? Ar.semitones(e) : t;
}, yu = (e, t) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string")
    return In(e, t);
}, T9 = (e, t = !1) => {
  const n = Math.floor(e / 12) - 1;
  return (t ? k9 : B9)[e % 12] + n;
};
function R9(e, t, n = 1) {
  e = e.map((i) => typeof i == "string" ? In(i) : i);
  const r = Math.floor(t / e.length) * n * 12;
  return t = St(t, e.length), e[t] + r;
}
function L9(e, t, n) {
  let r = 0, i = 1 / 0;
  return t.forEach((s, u) => {
    const a = Math.abs(s - e);
    (a < i || n) && (r = u, i = a);
  }), r;
}
let $s = {};
function G9(e, t, n, r) {
  let [i, s] = br.tokenize(t);
  const u = yu(i), a = gu(u);
  if (!$s[s]) {
    let { intervals: p } = br.get(`C ${s}`);
    $s[s] = p.map(Mg);
  }
  const o = $s[s];
  if (!o)
    return null;
  let f = u;
  if (n) {
    n = yu(n, 3);
    const p = gu(n), b = St(p - a, 12), M = L9(b, o, r);
    e = e + M, f = n - b;
  }
  const h = Math.floor(e / o.length) * 12;
  return e = St(e, o.length), o[e] + f + h;
}
let ec = {
  below: (e) => e.slice(-1)[0],
  duck: (e) => e.slice(-1)[0],
  above: (e) => e[0],
  root: (e) => e[0]
};
function X9({ chord: e, dictionary: t, offset: n = 0, n: r, mode: i = "below", anchor: s = "c5", octaves: u = 1 }) {
  const [a, o] = N9(e), f = V9(a);
  s = yu(s?.note || s, 4);
  const h = gu(s), m = t[o].map(
    (B) => (typeof B == "string" ? B.split(" ") : B).map(Mg)
  );
  let p, b, M = m.map((B, k) => {
    const V = ec[i](B), q = St(h - V - f, 12);
    return (p === void 0 || q < p) && (p = q, b = k), q;
  });
  i === "root" && (b = 0);
  const v = Math.ceil(n / m.length) * 12, E = St(b + n, m.length), I = m[E], _ = ec[i](I), X = s - M[E] + v, S = I.map((B) => X - _ + B);
  let x = S.map((B) => T9(B));
  return i === "duck" && (x = x.filter((B, k) => S[k] !== s)), r !== void 0 ? [R9(x, r, u)] : x;
}
const Z9 = (e) => (e <= 0 ? -1 : 1) + e * 7 + "P";
function W9(e, t) {
  t = t.replaceAll(":", " "), e = Math.ceil(e);
  let { intervals: n, tonic: r, empty: i } = br.get(t);
  if (i && Un(t) || !i && !r)
    throw new Error('incomplete scale. Make sure to use ":" instead of spaces, example: .scale("C:major")');
  if (i)
    throw new Error(`invalid scale "${t}"`);
  r = r || "C";
  const { pc: s, oct: u = 3 } = _n.get(r), a = Math.floor(e / n.length), o = St(e, n.length), f = Ar.add(n[o], Z9(a));
  return _n.transpose(s + u, f);
}
function tc(e, t, n) {
  let [r, i] = br.tokenize(e), { notes: s } = br.get(`${r} ${i}`);
  if (s = s.map((b) => _n.get(b).pc), t = Number(t), isNaN(t))
    throw new Error(`scale offset "${t}" not a number`);
  const { pc: u, oct: a = 3 } = _n.get(n), o = s.indexOf(u);
  if (o === -1)
    throw new Error(`note "${n}" is not in scale "${e}"`);
  let f = o, h = a, m = u;
  const p = Math.sign(t);
  for (; Math.abs(f - o) < Math.abs(t); ) {
    f += p;
    const b = St(f, s.length);
    p < 0 && m[0] === "C" && (h += p), m = s[b], p > 0 && m[0] === "C" && (h += p);
  }
  return m + h;
}
const O9 = T("transpose", function(e, t) {
  return t.withHap((n) => {
    const r = n.value.note ?? n.value;
    if (typeof r == "number") {
      let u;
      typeof e == "number" ? u = e : typeof e == "string" && (u = Ar.semitones(e) || 0);
      const a = r + u;
      return typeof n.value == "object" ? n.withValue(() => ({ ...n.value, note: a })) : n.withValue(() => a);
    }
    if (typeof r != "string" || !Un(r))
      return Je(`[tonal] transpose: not a note "${r}"`, "warning"), n;
    const i = isNaN(Number(e)) ? String(e) : Ar.fromSemitones(e), s = _n.simplify(_n.transpose(r, i));
    return typeof n.value == "object" ? n.withValue(() => ({ ...n.value, note: s })) : n.withValue(() => s);
  });
}), z9 = T("scaleTranspose", function(e, t) {
  return t.withHap((n) => {
    if (!n.context.scale)
      throw new Error("can only use scaleTranspose after .scale");
    if (typeof n.value == "object")
      return n.withValue(() => ({
        ...n.value,
        note: tc(n.context.scale, Number(e), n.value.note)
      }));
    if (typeof n.value != "string")
      throw new Error("can only use scaleTranspose with notes");
    return n.withValue(() => tc(n.context.scale, Number(e), n.value));
  });
}), j9 = T(
  "scale",
  function(e, t) {
    return Array.isArray(e) && (e = e.flat().join(" ")), t.fmap((n) => {
      const r = typeof n == "object";
      let i = r ? n.n : n;
      if (r && delete n.n, Un(i))
        return Ye(i);
      let s = Number(i), u = 0;
      if (isNaN(s)) {
        if (i = String(i), !/^[-+]?\d+(#*|b*){1}$/.test(i))
          return Je(
            `[tonal] invalid scale step "${i}", expected number or integer with optional # b suffixes`,
            "error"
          ), Se;
        const a = i.indexOf("#");
        if (a >= 0)
          s = Number(i.substring(0, a)), u = i.length - a;
        else {
          const o = i.indexOf("b");
          s = Number(i.substring(0, o)), u = o - i.length;
        }
      }
      try {
        let a;
        r && n.anchor ? a = G9(s, e, n.anchor) : a = W9(s, e), u != 0 && (a = _n.transpose(a, Ar.fromSemitones(u))), n = Ye(r ? { ...n, note: a } : a);
      } catch (a) {
        Je(`[tonal] ${a.message}`, "error"), n = Se;
      }
      return n;
    }).outerJoin().withHap((n) => n.setContext({ ...n.context, scale: e }));
  },
  !0,
  !0
  // preserve step count
);
var qs = {}, Xr = {}, Zr = {}, nc;
function Cg() {
  if (nc) return Zr;
  nc = 1, Zr.__esModule = !0, Zr.getBestVoicing = void 0;
  function e(t) {
    var n = t.chord, r = t.range, i = t.finder, s = t.picker, u = t.lastVoicing, a = i(n, r);
    return a.length ? s(a, u) : [];
  }
  return Zr.getBestVoicing = e, Zr;
}
var Wr = {};
const vg = /* @__PURE__ */ Nv(S9);
var Or = {}, rc;
function Pg() {
  if (rc) return Or;
  rc = 1, Or.__esModule = !0, Or.tokenizeChord = void 0;
  function e(t) {
    var n = (t || "").match(/^([A-G][b#]*)([^\/]*)[\/]?([A-G][b#]*)?$/);
    return n ? n.slice(1) : [];
  }
  return Or.tokenizeChord = e, Or;
}
var ic;
function $9() {
  if (ic) return Wr;
  ic = 1, Wr.__esModule = !0, Wr.voicingsInRange = void 0;
  var e = vg, t = Dg(), n = Pg();
  function r(i, s, u) {
    s === void 0 && (s = t.lefthand), u === void 0 && (u = ["D3", "A4"]);
    var a = (0, n.tokenizeChord)(i), o = a[0], f = a[1];
    if (!s[f])
      return [];
    var h = s[f].map(function(p) {
      return p.split(" ");
    }), m = e.Range.chromatic(u);
    return h.reduce(function(p, b) {
      var M = b.map(function(_) {
        return e.Interval.substract(_, b[0]);
      }), v = e.Note.transpose(o, b[0]), E = m.filter(function(_) {
        return e.Note.chroma(_) === e.Note.chroma(v);
      }).filter(function(_) {
        return e.Note.midi(e.Note.transpose(_, M[M.length - 1])) <= e.Note.midi(u[1]);
      }).map(function(_) {
        return e.Note.enharmonic(_, v);
      }), I = E.map(function(_) {
        return M.map(function(X) {
          return e.Note.transpose(_, X);
        });
      });
      return p.concat(I);
    }, []);
  }
  return Wr.voicingsInRange = r, Wr;
}
var sc;
function Dg() {
  return sc || (sc = 1, function(e) {
    var t = Xr.__assign || function() {
      return t = Object.assign || function(a) {
        for (var o, f = 1, h = arguments.length; f < h; f++) {
          o = arguments[f];
          for (var m in o) Object.prototype.hasOwnProperty.call(o, m) && (a[m] = o[m]);
        }
        return a;
      }, t.apply(this, arguments);
    }, n = Xr.__rest || function(a, o) {
      var f = {};
      for (var h in a) Object.prototype.hasOwnProperty.call(a, h) && o.indexOf(h) < 0 && (f[h] = a[h]);
      if (a != null && typeof Object.getOwnPropertySymbols == "function")
        for (var m = 0, h = Object.getOwnPropertySymbols(a); m < h.length; m++)
          o.indexOf(h[m]) < 0 && Object.prototype.propertyIsEnumerable.call(a, h[m]) && (f[h[m]] = a[h[m]]);
      return f;
    };
    e.__esModule = !0, e.dictionaryVoicing = e.dictionaryVoicingFinder = e.triads = e.guidetones = e.lefthand = void 0;
    var r = Cg(), i = $9();
    e.lefthand = {
      m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
      7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
      "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
      69: ["3M 5P 6A 9M"],
      m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
      "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
      "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
      o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
      "7#11": ["7m 9M 11A 13A"],
      "7#9": ["3M 7m 9A"],
      mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
      m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
    }, e.guidetones = {
      m7: ["3m 7m", "7m 10m"],
      m9: ["3m 7m", "7m 10m"],
      7: ["3M 7m", "7m 10M"],
      "^7": ["3M 7M", "7M 10M"],
      "^9": ["3M 7M", "7M 10M"],
      69: ["3M 6M"],
      6: ["3M 6M", "6M 10M"],
      m7b5: ["3m 7m", "7m 10m"],
      "7b9": ["3M 7m", "7m 10M"],
      "7b13": ["3M 7m", "7m 10M"],
      o7: ["3m 6M", "6M 10m"],
      "7#11": ["3M 7m", "7m 10M"],
      "7#9": ["3M 7m", "7m 10M"],
      mM7: ["3m 7M", "7M 10m"],
      m6: ["3m 6M", "6M 10m"]
    }, e.triads = {
      M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
      m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
      o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
      aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"]
    };
    var s = function(a) {
      return function(o, f) {
        return (0, i.voicingsInRange)(o, a, f);
      };
    };
    e.dictionaryVoicingFinder = s;
    var u = function(a) {
      var o = a.dictionary, f = a.range, h = n(a, ["dictionary", "range"]);
      return (0, r.getBestVoicing)(t(t({}, h), { range: f, finder: (0, e.dictionaryVoicingFinder)(o) }));
    };
    e.dictionaryVoicing = u;
  }(Xr)), Xr;
}
var zr = {}, uc;
function q9() {
  if (uc) return zr;
  uc = 1, zr.__esModule = !0, zr.minTopNoteDiff = void 0;
  var e = vg;
  function t(n, r) {
    if (!r)
      return n[0];
    var i = function(s) {
      return Math.abs(e.Note.midi(r[r.length - 1]) - e.Note.midi(s[s.length - 1]));
    };
    return n.reduce(function(s, u) {
      return i(u) < i(s) ? u : s;
    }, n[0]);
  }
  return zr.minTopNoteDiff = t, zr;
}
var ac;
function K9() {
  return ac || (ac = 1, function(e) {
    e.__esModule = !0;
    var t = Dg(), n = q9(), r = Cg(), i = Pg();
    e.default = {
      tokenizeChord: i.tokenizeChord,
      getBestVoicing: r.getBestVoicing,
      dictionaryVoicing: t.dictionaryVoicing,
      dictionaryVoicingFinder: t.dictionaryVoicingFinder,
      lefthand: t.lefthand,
      guidetones: t.guidetones,
      triads: t.triads,
      minTopNoteDiff: n.minTopNoteDiff
    };
  }(qs)), qs;
}
var H9 = K9();
const oc = /* @__PURE__ */ fm(H9), lr = {
  2: ["1P 5P 8P 9M", "1P 5P 8P 9M 12P", "5P 8P 9M 12P"],
  5: ["1P 5P 8P 12P", "5P 8P 12P 15P"],
  6: ["1P 5P 6M 8P 10M", "1P 5P 8P 10M 13M", "3M 5P 8P 10M 13M", "5P 8P 10M 12P 13M"],
  7: [
    "1P 5P 7m 8P 10M",
    "1P 7m 8P 10M 12P",
    "3M 7m 8P 10M 12P",
    "3M 7m 8P 10M 14m",
    "3M 7m 10M 12P 15P",
    "7m 10M 12P 14m 15P",
    "7m 10M 12P 15P 17M"
  ],
  9: [
    "1P 5P 7m 9M 10M",
    "1P 7m 9M 10M 12P",
    "3M 7m 8P 9M 12P",
    "7m 9M 10M 14m 15P",
    "3M 7m 8P 12P 16M",
    "7m 10M 12P 15P 16M"
  ],
  11: ["1P 5P 7m 9M 11P", "5P 7m 8P 9M 11P", "7m 8P 9M 11P 12P", "7m 8P 11P 12P 16M"],
  13: ["1P 6M 7m 9M 10M", "1P 7m 9M 10M 13M", "3M 7m 8P 9M 13M", "7m 8P 9M 10M 13M", "7m 9M 10M 13M 15P"],
  69: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 8P 9M 13M", "5P 8P 9M 10M 13M"],
  add9: ["1P 5P 8P 9M 10M", "1P 5P 9M 10M 12P", "3M 8P 9M 10M 12P", "3M 8P 9M 12P 15P", "5P 8P 9M 12P 17M"],
  "+": [
    "1P 3M 6m 8P 10M",
    "1P 6m 8P 10M 13m",
    "3M 6m 8P 10M 13m",
    "3M 8P 10M 13m 15P",
    "6m 8P 10M 13m 15P",
    "6m 10M 13m 15P 17M"
  ],
  o: ["1P 5d 8P 10m 12d", "3m 8P 10m 12d 15P", "5d 8P 10m 12d 15P"],
  h: [
    "3m 5d 7m 8P 10m",
    "1P 5d 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  sus: ["1P 4P 5P 8P", "1P 4P 5P 8P 11P", "5P 8P 11P 12P", "5P 8P 11P 12P 15P"],
  "^": ["1P 5P 8P 10M", "1P 5P 8P 10M 12P", "3M 5P 8P 10M 12P", "3M 8P 10M 12P 15P", "5P 8P 10M 12P 15P"],
  "-": ["1P 3m 5P 8P 10m", "1P 5P 8P 10m 12P", "3m 5P 8P 10m 12P", "5P 8P 10m 12P 15P"],
  "^7": ["1P 5P 7M 10M 12P", "1P 10M 12P 14M", "3M 8P 10M 12P 14M", "5P 8P 10M 12P 14M", "5P 8P 10M 14M 17M"],
  "-7": [
    "1P 3m 5P 7m 10m",
    "1P 5P 7m 10m 12P",
    "3m 7m 8P 10m 12P",
    "3m 7m 8P 10m 14m",
    "5P 7m 8P 10m 14m",
    "7m 10m 12P 14m 15P",
    "5P 8P 10m 14m 17m",
    "7m 10m 12P 15P 17m"
  ],
  "7sus": ["1P 5P 7m 8P 11P", "5P 8P 11P 12P 14m", "7m 8P 11P 12P 14m", "7m 11P 12P 14m 18P"],
  h7: [
    "3m 5d 7m 8P 10m",
    "1P 5d 7m 10m 12d",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  o7: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  "^9": [
    "1P 5P 7M 9M 10M",
    "1P 7M 9M 10M 12P",
    "3M 7M 8P 9M 12P",
    "3M 7M 8P 12P 16M",
    "5P 8P 10M 14M 16M",
    "7M 8P 10M 12P 16M"
  ],
  "^13": ["1P 6M 7M 9M 10M", "1P 7M 9M 10M 13M", "3M 7M 8P 9M 13M", "3M 7M 8P 13M 16M", "7M 8P 10M 13M 16M"],
  "^7#11": ["1P 5P 7M 10M 12d", "3M 7M 8P 10M 12d", "1P 7M 10M 12d 14M", "3M 7M 8P 12d 14M", "5P 8P 10M 12d 14M"],
  "^9#11": ["1P 3M 5d 7M 9M", "1P 7M 9M 10M 12d", "3M 7M 8P 9M 12d", "3M 8P 9M 12d 14M"],
  "^7#5": ["1P 6m 7M 10M 13m", "3M 7M 8P 10M 13m", "6m 7M 8P 10M 13m"],
  "-6": [
    "1P 3m 5P 6M 8P",
    "1P 5P 6M 8P 10m",
    "3m 5P 6M 8P 10m",
    "1P 5P 8P 10m 13M",
    "3m 5P 8P 10m 13M",
    "5P 8P 10m 12P 13M",
    "5P 8P 10m 13M 15P"
  ],
  "-69": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "3m 6M 9M 10m 12P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 9M 10m 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-^7": ["1P 3m 5P 7M 10m", "1P 5P 7M 10m 12P", "3m 7M 8P 10m 12P", "5P 7M 8P 10m 14M", "5P 8P 10m 14M 17m"],
  "-^9": ["1P 3m 5P 7M 9M", "1P 7M 9M 10m 12P", "3m 7M 8P 9M 12P", "5P 8P 9M 10m 14M"],
  "-9": [
    "1P 3m 5P 7m 9M",
    "3m 5P 7m 8P 9M",
    "3m 7m 8P 9M 12P",
    "5P 8P 9M 10m 14m",
    "3m 7m 9M 12P 15P",
    "7m 10m 12P 15P 16M"
  ],
  "-add9": ["1P 2M 3m 5P 8P", "1P 3m 5P 9M", "3m 5P 8P 9M 12P", "5P 8P 9M 10m 12P"],
  "-11": [
    "1P 3m 7m 9M 11P",
    "3m 7m 8P 9M 11P",
    "1P 4P 7m 10m 12P",
    "5P 8P 11P 14m",
    "3m 7m 9M 11P 15P",
    "5P 8P 11P 14m 16M",
    "7m 10m 12P 15P 18P"
  ],
  "-7b5": [
    "3m 5d 7m 8P 10m",
    "1P 7m 10m 12d",
    "1P 5d 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 7m 8P 10m 14m",
    "5d 8P 10m 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  h9: ["1P 7m 9M 10m 12d", "3m 7m 8P 9M 12d", "5d 8P 9M 10m 14m", "7m 10m 12d 15P 16M"],
  "-b6": ["1P 5P 6m 8P 10m", "1P 5P 8P 10m 13m", "3m 5P 8P 10m 13m", "5P 8P 10m 13m", "5P 8P 10m 13m 15P"],
  "-#5": ["1P 6m 8P 10m 13m", "3m 6m 8P 10m 13m", "6m 8P 10m 13m 15P"],
  "7b9": ["1P 3M 7m 9m 10M", "3M 7m 8P 9m 10M", "3M 7m 8P 9m 14m", "7m 9m 10M 14m 15P"],
  "7#9": ["1P 3M 7m 10m", "3M 7m 8P 10m 14m", "7m 10m 10M 14m 15P"],
  "7#11": ["1P 3M 7m 10M 12d", "3M 7m 8P 10M 12d", "7m 10M 12d 14m 15P"],
  "7b5": ["1P 3M 7m 10M 12d", "3M 7m 8P 10M 12d", "7m 10M 12d 14m 15P"],
  "7#5": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P"],
  "9#11": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9b5": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9#5": ["1P 7m 9M 10M 13m", "3M 7m 9M 10M 13m", "3M 7m 9M 13m 14m", "7m 10M 13m 14m 16M", "7m 10M 13m 16M 17M"],
  "7b13": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P"],
  "7#9#5": ["1P 3M 7m 10m 13m", "3M 7m 10m 13m 15P", "7m 10M 13m 15P 17m"],
  "7#9b5": ["1P 3M 7m 10m 12d", "3M 7m 10m 12d 15P", "7m 10M 12d 15P 17m"],
  "7#9#11": ["1P 3M 7m 10m 12d", "3M 7m 10m 12d 15P", "7m 10M 12d 15P 17m"],
  "7b9#11": ["1P 7m 9m 10M 12d", "3M 7m 8P 9m 12d", "7m 8P 10M 12d 16m"],
  "7b9b5": ["1P 7m 9m 10M 12d", "3M 7m 8P 9m 12d", "7m 8P 10M 12d 16m"],
  "7b9#5": ["1P 7m 9m 10M 13m", "3M 7m 8P 9m 13m", "7m 9m 10M 13m 15P"],
  "7b9#9": ["1P 3M 7m 9m 10m", "3M 7m 8P 9m 10m", "7m 8P 10M 16m 17m"],
  "7b9b13": ["1P 7m 9m 10M 13m", "3M 7m 8P 9m 13m", "7m 9m 10M 13m 15P"],
  "7alt": [
    "3M 7m 8P 9m 12d",
    "1P 7m 10m 10M 13m",
    "3M 7m 8P 10m 13m",
    "3M 7m 9m 12d 15P",
    "3M 7m 10m 13m 15P",
    "7m 10M 12d 15P 17m",
    "7m 10M 13m 15P 17m"
  ],
  "13#11": ["1P 6M 7m 10M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "13b9": ["1P 3M 6M 7m 9m", "1P 6M 7m 9m 10M", "3M 7m 9m 10M 13M", "3M 7m 10M 13M 16m", "7m 10M 13M 16m 17M"],
  "13#9": ["1P 3M 6M 7m 10m", "3M 7m 8P 10m 13M", "7m 10M 13M 14m 17m"],
  "7b9sus": ["1P 5P 7m 9m 11P", "5P 7m 8P 9m 11P", "7m 8P 11P 14m 16m"],
  "7susadd3": ["1P 4P 5P 7m 10M", "5P 8P 10M 11P 14m", "7m 11P 12P 15P 17M"],
  "9sus": ["1P 5P 7m 9M 11P", "5P 7m 8P 9M 11P", "7m 8P 9M 11P 12P", "7m 8P 11P 12P 16M"],
  "13sus": ["1P 4P 6M 7m 9M", "1P 7m 9M 11P 13M", "5P 7m 9M 11P 13M", "7m 9M 11P 13M 15P"],
  "7b13sus": ["1P 5P 7m 11P 13m", "5P 7m 8P 11P 13m", "7m 11P 13m 14m 15P"]
}, qr = {
  2: ["1P 5P 6M 8P 9M", "1P 5P 8P 9M 12P", "5P 8P 9M 12P 13M", "5P 8P 9M 12P 15P"],
  5: ["1P 5P 8P 12P", "1P 5P 8P 9M 12P", "5P 8P 12P 15P", "5P 8P 12P 15P 16M"],
  6: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 9M 10M 13M", "5P 8P 9M 10M 13M", "3M 6M 9M 12P 15P"],
  7: [
    "1P 5P 7m 8P 10M",
    "1P 7m 8P 10M 12P",
    "3M 7m 8P 10M 12P",
    "3M 7m 8P 10M 14m",
    "3M 7m 10M 12P 15P",
    "7m 10M 12P 14m 15P",
    "7m 10M 12P 15P 17M",
    "7m 10M 14m 17M 19P"
  ],
  9: [
    "1P 6M 7m 9M 10M",
    "3M 7m 9M 10M 12P",
    "1P 7m 9M 10M 13M",
    "3M 7m 9M 10M 13M",
    "3M 7m 9M 12P 15P",
    "7m 10M 12P 13M 16M",
    "7m 10M 13M 16M 17M",
    "7m 10M 13M 16M 19P"
  ],
  11: [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  13: [
    "3M 7m 9M 10M 13M",
    "3M 7m 9M 13M 15P",
    "3M 7m 10M 13M 16M",
    "7m 10M 12P 13M 16M",
    "7m 10M 13M 16M 17M",
    "7m 10M 13M 16M 19P"
  ],
  69: ["1P 5P 6M 9M 10M", "1P 5P 9M 10M 13M", "3M 5P 9M 10M 13M", "5P 8P 9M 10M 13M", "3M 6M 9M 12P 15P"],
  add9: [
    "1P 5P 8P 9M 10M",
    "1P 5P 9M 10M 12P",
    "3M 8P 9M 10M 12P",
    "3M 8P 9M 12P 15P",
    "5P 8P 9M 10M 15P",
    "5P 8P 9M 12P 17M"
  ],
  "+": [
    "1P 6m 8P 9M 10M",
    "1P 6m 8P 10M 13m",
    "3M 8P 9M 10M 13m",
    "3M 8P 10M 13m 15P",
    "6m 10M 13m 15P 16M",
    "6m 10M 13m 15P 17M"
  ],
  o: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  h: [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  sus: [
    "1P 4P 5P 8P 9M",
    "1P 4P 5P 8P 11P",
    "1P 5P 8P 9M 11P",
    "5P 8P 9M 11P 12P",
    "5P 8P 11P 12P 13M",
    "5P 8P 11P 13M 15P"
  ],
  "^": [
    "1P 3M 5P 6M 9M",
    "1P 5P 8P 10M 12P",
    "3M 5P 9M 10M 12P",
    "1P 5P 8P 10M 13M",
    "3M 8P 10M 13M 15P",
    "5P 9M 10M 12P 15P"
  ],
  "-": [
    "1P 3m 5P 8P 10m",
    "1P 3m 5P 9M 11P",
    "3m 5P 8P 9M 11P",
    "5P 8P 9M 10m 11P",
    "1P 5P 9M 10m 12P",
    "3m 5P 8P 10m 12P",
    "5P 8P 10m 12P 15P"
  ],
  "^7": [
    "1P 6M 7M 9M 10M",
    "3M 7M 9M 10M 12P",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "-7": [
    "1P 3m 5P 7m 9M",
    "1P 3m 5P 7m 10m",
    "1P 5P 7m 10m 11P",
    "3m 7m 8P 10m 11P",
    "1P 5P 7m 10m 12P",
    "3m 7m 9M 10m 12P",
    "3m 7m 8P 10m 14m",
    "5P 7m 9M 10m 14m",
    "7m 10m 11P 14m 15P",
    "7m 10m 12P 15P 16M",
    "5P 8P 11P 14m 17m",
    "7m 10m 12P 15P 17m"
  ],
  "7sus": [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  h7: [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  o7: [
    "1P 6M 8P 10m 12d",
    "1P 6M 10m 12d 13M",
    "3m 8P 10m 12d 13M",
    "3m 8P 12d 13M 15P",
    "5d 10m 12d 13M 15P",
    "5d 10m 13M 15P 17m",
    "6M 12d 13M 15P 17m",
    "6M 12d 15P 17m 19d"
  ],
  "^9": [
    "1P 6M 7M 9M 10M",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 8P 9M 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "^13": [
    "1P 6M 7M 9M 10M",
    "1P 7M 9M 10M 13M",
    "3M 7M 9M 12P 13M",
    "3M 7M 9M 10M 13M",
    "3M 7M 8P 9M 13M",
    "3M 7M 9M 13M 14M",
    "3M 7M 10M 13M 16M",
    "7M 10M 13M 14M 16M",
    "7M 10M 13M 16M 17M",
    "7M 10M 13M 16M 19P"
  ],
  "^7#11": [
    "1P 3M 5d 7M 9M",
    "1P 7M 9M 10M 12d",
    "3M 7M 9M 10M 12d",
    "3M 7M 9M 12d 13M",
    "3M 7M 10M 12d 14M",
    "7M 10M 12d 13M 14M",
    "7M 10M 12d 13M 16M",
    "7M 10M 12d 14M 17M"
  ],
  "^9#11": [
    "1P 3M 5d 7M 9M",
    "1P 7M 9M 10M 12d",
    "3M 7M 9M 10M 12d",
    "3M 7M 9M 12d 13M",
    "3M 7M 9M 12d 14M",
    "7M 10M 12d 14M 16M",
    "7M 10M 12d 13M 16M"
  ],
  "^7#5": ["1P 6m 7M 10M 13m", "3M 7M 9M 10M 13m", "3M 7M 10M 13m 14M", "7M 10M 13m 14M 16M", "7M 10M 13m 14M 17M"],
  "-6": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "1P 5P 6M 10m 11P",
    "3m 5P 6M 8P 11P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 10m 11P 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-69": [
    "1P 3m 5P 6M 9M",
    "3m 5P 6M 8P 9M",
    "3m 6M 9M 10m 12P",
    "1P 5P 9M 10m 13M",
    "3m 5P 8P 9M 13M",
    "5P 8P 9M 10m 13M",
    "5P 8P 10m 13M 16M"
  ],
  "-^7": [
    "1P 3m 5P 7M 9M",
    "1P 5P 7M 10m 11P",
    "3m 7M 9M 10m 11P",
    "3m 7M 9M 10m 12P",
    "3m 7M 9M 12P 14M",
    "7M 10m 11P 12P 14M",
    "7M 10m 12P 14M 16M"
  ],
  "-^9": [
    "1P 3m 5P 7M 9M",
    "1P 5P 7M 10m 11P",
    "3m 7M 9M 10m 11P",
    "3m 7M 9M 10m 12P",
    "3m 7M 9M 12P 14M",
    "7M 10m 11P 12P 14M",
    "7M 10m 12P 14M 16M"
  ],
  "-9": [
    "1P 3m 5P 7m 9M",
    "1P 3m 7m 9M 11P",
    "3m 7m 9M 10m 11P",
    "3m 7m 9M 10m 12P",
    "3m 7m 9M 10m 14m",
    "3m 7m 9M 12P 15P",
    "7m 10m 11P 14m 16M",
    "7m 10m 12P 16M 18P"
  ],
  "-add9": ["1P 2M 3m 5P 8P", "1P 3m 5P 9M", "3m 5P 8P 9M 12P", "5P 8P 9M 10m 12P"],
  "-11": [
    "3m 5P 7m 9M 11P",
    "7m 9M 10m 11P",
    "1P 4P 7m 10m 12P",
    "3m 7m 9M 11P 12P",
    "7m 9M 10m 11P 12P",
    "3m 7m 9M 11P 14m",
    "4P 10m 12P 14m",
    "5P 8P 11P 14m",
    "5P 8P 11P 14m 16M",
    "7m 10m 12P 16M 18P",
    "7m 10m 11P 16M 21m"
  ],
  "-7b5": [
    "1P 5d 7m 10m 11P",
    "3m 5d 7m 8P 11P",
    "5d 7m 8P 10m 11P",
    "1P 7m 10m 12d",
    "3m 7m 8P 10m 12d",
    "3m 7m 8P 12d 14m",
    "5d 8P 10m 11P 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 15P",
    "5d 8P 10m 14m 17m"
  ],
  h9: [
    "3m 5d 7m 9M 11P",
    "1P 7m 9M 10m 12d",
    "3m 7m 9M 12d 14m",
    "5d 8P 9M 10m 14m",
    "7m 10m 11P 12d 14m",
    "7m 10m 12d 14m 16M"
  ],
  "-b6": ["1P 3m 5P 6m 8P", "3m 5P 8P 11P 13m", "5P 8P 10m 11P 13m"],
  "-#5": ["1P 6m 8P 10m 13m", "3m 6m 8P 11P 13m", "6m 8P 10m 13m 15P"],
  "7b9": ["1P 3M 7m 9m 10M", "3M 7m 8P 9m 10M", "3M 7m 8P 9m 14m", "7m 9m 10M 14m 15P"],
  "7#9": ["1P 3M 7m 10m", "3M 7m 10m 10M 12P", "3M 7m 10m 12P 14m", "7m 10M 12P 14m 17m"],
  "7#11": ["1P 3M 7m 9M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "7b5": ["1P 3M 7m 9M 12d", "3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "7#5": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P", "7m 10M 13m 14m 17M"],
  "9#11": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9b5": ["1P 7m 9M 10M 12d", "3M 7m 8P 9M 12d", "7m 10M 12d 15P 16M"],
  "9#5": ["1P 7m 9M 10M 13m", "3M 7m 9M 10M 13m", "3M 7m 9M 13m 14m", "7m 10M 13m 14m 16M", "7m 10M 13m 16M 17M"],
  "7b13": ["1P 3M 7m 10M 13m", "3M 7m 8P 10M 13m", "3M 7m 8P 13m 14m", "7m 10M 13m 14m 15P", "7m 10M 13m 14m 17M"],
  "7#9#5": ["3M 7m 10m 10M 13m", "3M 7m 10m 13m 14m", "7m 10M 13m 14m 17m"],
  "7#9b5": ["3M 7m 10m 10M 12d", "3M 7m 10m 12d 14m", "7m 10M 12d 14m 17m"],
  "7#9#11": ["3M 7m 10m 10M 12d", "3M 7m 10m 12d 14m", "7m 10M 12d 14m 17m"],
  "7b9#11": ["3M 7m 9m 10M 12d", "3M 7m 9m 12d 14m", "7m 8P 10M 12d 16m", "7m 10M 12d 14m 16m"],
  "7b9b5": ["3M 7m 9m 10M 12d", "3M 7m 9m 12d 14m", "7m 8P 10M 12d 16m", "7m 10M 12d 14m 16m"],
  "7b9#5": ["1P 7m 9m 10M 13m", "3M 7m 9m 10M 13m", "3M 7m 10M 13m 16m", "7m 10M 13m 14m 16m", "7m 10M 13m 16m 17M"],
  "7b9#9": ["1P 3M 7m 9m 10m", "3M 7m 10m 13m 16m", "7m 10M 13m 16m 17m"],
  "7b9b13": ["1P 7m 9m 10M 13m", "3M 7m 9m 10M 13m", "3M 7m 10M 13m 16m", "7m 10M 13m 14m 16m", "7m 10M 13m 16m 17M"],
  "7alt": [
    "3M 7m 8P 10m 13m",
    "3M 7m 9m 12d 13m",
    "3M 7m 9m 10m 13m",
    "3M 7m 10m 13m 14m",
    "3M 7m 9m 12d 14m",
    "3M 7m 10m 13m 15P",
    "3M 7m 10m 13m 16m",
    "7m 10M 12d 14m 16m",
    "7m 10M 12d 13m 16m",
    "7m 10M 13m 15P 17m",
    "7m 10M 13m 16m 17m",
    "7m 10M 13m 16m 19d"
  ],
  "13#11": ["3M 7m 9M 12d 13M", "7m 10M 12d 13M 16M"],
  "13b9": ["3M 7m 9m 10M 13M", "3M 7m 10M 13M 16m", "7m 10M 13M 16m 17M"],
  "13#9": ["3M 7m 10m 10M 13M", "7m 10M 13M 14m 17m"],
  "7b9sus": ["1P 5P 7m 9m 11P", "5P 7m 8P 9m 11P", "7m 8P 11P 14m 16m"],
  "7susadd3": ["1P 4P 5P 7m 10M", "5P 8P 10M 11P 14m", "7m 11P 12P 15P 17M"],
  "9sus": [
    "1P 4P 6M 7m 9M",
    "1P 5P 7m 9M 11P",
    "4P 6M 7m 9M 11P",
    "5P 8P 9M 11P 14m",
    "7m 9M 11P 13M 15P",
    "7m 11P 12P 14m 18P"
  ],
  "13sus": [
    "1P 4P 6M 7m 9M",
    "1P 7m 9M 11P 13M",
    "4P 7m 9M 11P 13M",
    "7m 9M 11P 13M 15P",
    "7m 11P 13M 14m 16M",
    "7m 11P 13M 16M 18P"
  ],
  "7b13sus": ["1P 5P 7m 11P 13m", "5P 7m 8P 11P 13m", "7m 11P 13m 14m 15P"]
}, { dictionaryVoicing: U9, minTopNoteDiff: J9 } = oc.default || oc, Y9 = {
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  69: ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
}, Q9 = {
  m7: ["3m 7m", "7m 10m"],
  m9: ["3m 7m", "7m 10m"],
  7: ["3M 7m", "7m 10M"],
  "^7": ["3M 7M", "7M 10M"],
  "^9": ["3M 7M", "7M 10M"],
  69: ["3M 6M"],
  6: ["3M 6M", "6M 10M"],
  m7b5: ["3m 7m", "7m 10m"],
  "7b9": ["3M 7m", "7m 10M"],
  "7b13": ["3M 7m", "7m 10M"],
  o7: ["3m 6M", "6M 10m"],
  "7#11": ["3M 7m", "7m 10M"],
  "7#9": ["3M 7m", "7m 10M"],
  mM7: ["3m 7M", "7M 10m"],
  m6: ["3m 6M", "6M 10m"]
}, eF = {
  "": ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"]
}, tF = {
  // triads
  "": ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"],
  // sevenths chords
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  7: ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  69: ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
}, _r = {
  lefthand: { dictionary: Y9, range: ["F3", "A4"], mode: "below", anchor: "a4" },
  triads: { dictionary: eF, mode: "below", anchor: "a4" },
  guidetones: { dictionary: Q9, mode: "above", anchor: "a4" },
  legacy: { dictionary: tF, mode: "below", anchor: "a4" }
};
let Fg = "ireal";
const Eg = (e) => Fg = e, nF = (e, t) => xg(e, _r[e].dictionary, t), xg = (e, t, n = ["F3", "A4"]) => {
  Object.assign(_r, { [e]: { dictionary: t, range: n } });
}, Ta = (e, t, n = {}) => {
  Object.assign(_r, { [e]: { dictionary: t, ...n } });
}, rF = (e, t, n) => {
  const { dictionary: r, range: i } = _r[t];
  return U9({
    chord: e,
    dictionary: r,
    range: i,
    picker: J9,
    lastVoicing: n
  });
};
let Di;
const iF = T("voicings", function(e, t) {
  return t.fmap((n) => (Di = rF(n, e, Di), Te(...Di))).outerJoin();
}), sF = T("rootNotes", function(e, t) {
  return t.fmap((n) => {
    const s = (n.chord || n).match(/^([a-gA-G][b#]?).*$/)[1] + e;
    return n.chord ? { note: s } : s;
  });
}), uF = T("voicing", function(e) {
  return e.fmap((t) => {
    t = typeof t == "string" ? { chord: t } : t;
    let { dictionary: n = Fg, chord: r, anchor: i, offset: s, mode: u, n: a, octaves: o, ...f } = t;
    n = typeof n == "string" ? _r[n] : { dictionary: n, mode: "below", anchor: "c5" };
    try {
      let h = X9({ ...n, chord: r, anchor: i, offset: s, mode: u, n: a, octaves: o });
      return Te(...h).note().set(f);
    } catch {
      return Je(`[voicing]: unknown chord "${r}"`), Se;
    }
  }).outerJoin();
});
function Kr(e, t, n) {
  n = Array.isArray(n) ? n : [n], n.forEach((r) => {
    r[t] = r[e];
  });
}
Kr("^", "", [lr, qr]);
Object.keys(lr).forEach((e) => {
  if (e.includes("-")) {
    let t = e.replace("-", "m");
    Kr(e, t, [qr, lr]);
  }
  if (e.includes("^")) {
    let t = e.replace("^", "M");
    Kr(e, t, [qr, lr]);
  }
  if (e.includes("+")) {
    let t = e.replace("+", "aug");
    Kr(e, t, [qr, lr]);
  }
});
Ta("ireal", lr);
Ta("ireal-ext", qr);
function aF() {
  Di = void 0, Eg("ireal");
}
const oF = "@strudel/tonal", cF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addVoicings: xg,
  packageName: oF,
  registerVoicings: Ta,
  resetVoicings: aF,
  rootNotes: sF,
  scale: j9,
  scaleTranspose: z9,
  setDefaultVoicings: Eg,
  setVoicingRange: nF,
  transpose: O9,
  voicing: uF,
  voicingAlias: Kr,
  voicingRegistry: _r,
  voicings: iF
}, Symbol.toStringTag, { value: "Module" }));
async function lF() {
  const e = Ei(
    Ei,
    Promise.resolve().then(() => Ip),
    Promise.resolve().then(() => qC),
    Promise.resolve().then(() => cF),
    Promise.resolve().then(() => XC),
    { hush: hF, evaluate: pF }
  );
  await Promise.all([
    e,
    od()
    /* , registerSoundfonts() */
  ]);
}
let Au, $n;
function fF(e = {}) {
  id(), e.miniAllStrings !== !1 && wd();
  const { prebake: t, ...n } = e;
  return $n = bd({ ...n, transpiler: mP }), Au = (async () => (await lF(), await t?.(), $n))(), xi(() => $n.scheduler.now()), Au;
}
window.initStrudel = fF;
z.prototype.play = function() {
  if (!$n)
    throw new Error(".play: no repl found. Have you called initStrudel?");
  return Au.then(() => {
    $n.setPattern(this, !0);
  }), this;
};
function hF() {
  $n.stop();
}
async function pF(e, t = !0) {
  return $n.evaluate(e, t);
}
export {
  vc as ClockCollator,
  _p as Cyclist,
  Uu as DEFAULT_MAX_POLYPHONY,
  j as Fraction,
  qe as Hap,
  z as Pattern,
  WC as StartRules,
  pr as State,
  Kn as SyntaxError,
  Ue as TimeSpan,
  zu as __chooseWith,
  Wu as _brandBy,
  Nc as _fitslice,
  Ou as _irand,
  $u as _keyDown,
  Tc as _match,
  St as _mod,
  Lc as _polymeterListSteps,
  Ys as _retime,
  Qs as _slices,
  il as accelerate,
  Nf as activeLabel,
  W1 as ad,
  u3 as add,
  xg as addVoicings,
  Z1 as adsr,
  cC as aliasBank,
  gM as almostAlways,
  mM as almostNever,
  AM as always,
  ol as amp,
  ft as analysers,
  On as analysersData,
  Cl as analyze,
  uh as anchor,
  F3 as and,
  tA as apply,
  wi as applyFM,
  Xn as applyGainCurve,
  z1 as ar,
  jy as arrange,
  op as as,
  ll as att,
  cl as attack,
  fc as averageArray,
  XM as backgroundImage,
  h3 as band,
  Bl as bandf,
  Il as bandq,
  Ml as bank,
  Mc as base64ToUnicode,
  Mb as beat,
  Nl as begin,
  jb as binary,
  Cp as binaryN,
  Jy as bind,
  l1 as binshift,
  aA as bite,
  fp as bjork,
  m3 as blshift,
  p3 as bor,
  kl as bp,
  M0 as bpa,
  b0 as bpattack,
  E0 as bpd,
  F0 as bpdecay,
  d0 as bpe,
  p0 as bpenv,
  _l as bpf,
  Vl as bpq,
  L0 as bpr,
  R0 as bprelease,
  k0 as bps,
  _0 as bpsustain,
  yA as brak,
  Ub as brand,
  Hb as brandBy,
  g3 as brshift,
  d3 as bxor,
  ZA as bypass,
  Ry as calculateSteps,
  _c as cat,
  U1 as ccn,
  J1 as ccv,
  B3 as ceil,
  $l as ch,
  r0 as channel,
  jl as channels,
  Yb as choose,
  Dp as chooseCycles,
  ju as chooseInWith,
  Zi as chooseWith,
  lb as chop,
  rh as chord,
  VA as chunk,
  RA as chunkBack,
  LA as chunkback,
  Ri as clamp,
  ZM as cleanupUi,
  v1 as clip,
  Ol as coarse,
  _y as code2hash,
  G1 as color,
  X1 as colour,
  a1 as comb,
  by as compose,
  R3 as compress,
  L3 as compressSpan,
  Eh as compressor,
  Sh as compressorAttack,
  xh as compressorKnee,
  wh as compressorRatio,
  Bh as compressorRelease,
  G3 as compressspan,
  Oi as connectToDestination,
  My as constant,
  zc as contract,
  H1 as control,
  vb as controls,
  _b as cosine,
  kb as cosine2,
  nA as cpm,
  C1 as cps,
  pp as createClock,
  bi as createFilter,
  Gi as createParam,
  Vu as createParams,
  Wl as crush,
  u0 as ctf,
  Y1 as ctlNum,
  Gf as ctranspose,
  me as curry,
  x1 as curve,
  i0 as cut,
  s0 as cutoff,
  Hs as cycleToSeconds,
  Dl as dec,
  Pl as decay,
  lF as defaultPrebake,
  uM as degrade,
  sM as degradeBy,
  iM as degradeByWith,
  Rf as degree,
  tf as delay,
  rf as delayfb,
  nf as delayfeedback,
  af as delayt,
  uf as delaytime,
  w1 as deltaSlide,
  ff as det,
  lf as detune,
  sf as dfb,
  sh as dict,
  ih as dictionary,
  Fh as dist,
  Dh as distort,
  c3 as div,
  ef as djf,
  wC as dough,
  dd as doughTrigger,
  Pd as drawFrequencyScope,
  Fc as drawLine,
  vd as drawTimeScope,
  zl as drive,
  Zc as drop,
  df as dry,
  Gp as drywet,
  O1 as ds,
  hd as dspWorklet,
  of as dt,
  F1 as dur,
  D1 as duration,
  rA as early,
  wA as echo,
  DA as echoWith,
  FA as echowith,
  Tl as end,
  s1 as enhance,
  C3 as eq,
  v3 as eqt,
  Fb as euclid,
  wb as euclidLegato,
  Sb as euclidLegatoRot,
  xb as euclidRot,
  Eb as euclidrot,
  Ei as evalScope,
  pF as evaluate,
  eA as every,
  Oc as expand,
  Th as expression,
  Wc as extend,
  yf as fadeInTime,
  gf as fadeOutTime,
  mf as fadeTime,
  X0 as fanchor,
  $3 as fast,
  XA as fastChunk,
  X3 as fastGap,
  yt as fastcat,
  GA as fastchunk,
  Z3 as fastgap,
  vl as fft,
  $A as filter,
  qA as filterWhen,
  Q3 as firstOf,
  mb as fit,
  dn as flatten,
  S3 as floor,
  pl as fm,
  ml as fmattack,
  gl as fmdecay,
  dl as fmenv,
  fl as fmh,
  hl as fmi,
  Al as fmrelease,
  yl as fmsustain,
  bl as fmvelocity,
  W3 as focus,
  O3 as focusSpan,
  z3 as focusspan,
  Cy as fractionalArgs,
  p1 as frameRate,
  d1 as frames,
  e1 as freeze,
  Af as freq,
  Cu as freqToMidi,
  k3 as fromBipolar,
  Wh as fshift,
  Oh as fshiftnote,
  zh as fshiftphase,
  G0 as ftype,
  x3 as func,
  ul as gain,
  pn as gainNode,
  Cr as gap,
  _f as gat,
  Bf as gate,
  yn as getADSRValues,
  ud as getAnalyserById,
  zi as getAnalyzerData,
  xe as getAudioContext,
  pC as getAudioContextCurrentTime,
  Qp as getAudioDevices,
  nC as getCachedBuffer,
  Lp as getCompressor,
  Nu as getControlName,
  Dc as getCurrentKeyboardState,
  He as getDefaultValue,
  dy as getEventOffsetMs,
  lc as getFreq,
  pc as getFrequency,
  Qu as getLeafLocation,
  ea as getLeafLocations,
  xd as getLeaves,
  iC as getLoadedBuffer,
  ld as getOscillator,
  gn as getParamADSR,
  Iy as getPerformanceTimeSeconds,
  Ur as getPitchEnvelope,
  Ay as getPlayableNoteValue,
  Zp as getSampleBuffer,
  Wp as getSampleBufferSource,
  Xp as getSampleInfo,
  Mi as getSound,
  yy as getSoundIndex,
  ru as getTime,
  kp as getTrigger,
  Jr as getVibratoOscillator,
  CP as getWidgetID,
  Jt as getWorklet,
  fd as getZZFX,
  HA as grow,
  A3 as gt,
  M3 as gte,
  jC as h,
  Xf as harmonic,
  ky as hash2code,
  f1 as hbrick,
  q0 as hcutoff,
  Sl as hold,
  m1 as hours,
  H0 as hp,
  A0 as hpa,
  y0 as hpattack,
  D0 as hpd,
  P0 as hpdecay,
  h0 as hpe,
  f0 as hpenv,
  K0 as hpf,
  J0 as hpq,
  T0 as hpr,
  N0 as hprelease,
  B0 as hps,
  S0 as hpsustain,
  U0 as hresonance,
  jA as hsl,
  zA as hsla,
  q3 as hurry,
  hF as hush,
  cr as id,
  i1 as imag,
  BM as inhabit,
  kM as inhabitmod,
  rd as initAudio,
  id as initAudioOnFirstClick,
  fF as initStrudel,
  sd as initializeAudioOutput,
  Yy as innerBind,
  U3 as inside,
  dA as inv,
  pA as invert,
  yh as ir,
  Jb as irand,
  Ah as iresponse,
  Un as isNote,
  ly as isNoteWithOctave,
  xu as isPattern,
  Xi as isaw,
  Lu as isaw2,
  BA as iter,
  _A as iterBack,
  kA as iterback,
  Tb as itri,
  Rb as itri2,
  PA as jux,
  CA as juxBy,
  vA as juxby,
  qh as kcutoff,
  i3 as keep,
  s3 as keepif,
  Pc as keyAlias,
  MM as keyDown,
  $h as krush,
  Tf as label,
  Y3 as lastOf,
  Ic as late,
  h1 as lbrick,
  P1 as legato,
  kf as leslie,
  _1 as lfo,
  oA as linger,
  vu as listRange,
  Hu as loadBuffer,
  cf as lock,
  Mu as logKey,
  Rl as loop,
  pb as loopAt,
  gb as loopAtCps,
  Ll as loopBegin,
  Xl as loopEnd,
  db as loopat,
  yb as loopatcps,
  Gl as loopb,
  Zl as loope,
  o0 as lp,
  g0 as lpa,
  m0 as lpattack,
  v0 as lpd,
  C0 as lpdecay,
  l0 as lpe,
  c0 as lpenv,
  a0 as lpf,
  Q0 as lpq,
  V0 as lpr,
  I0 as lprelease,
  w0 as lps,
  x0 as lpsustain,
  If as lrate,
  Vf as lsize,
  y3 as lt,
  b3 as lte,
  zC as m,
  Du as mapArgs,
  qy as mask,
  gy as midi2note,
  qn as midiToFreq,
  sp as midibend,
  j1 as midichan,
  K1 as midicmd,
  $1 as midimap,
  q1 as midiport,
  up as miditouch,
  ta as mini,
  ni as mini2ast,
  wd as miniAllStrings,
  $C as minify,
  g1 as minutes,
  l3 as mod,
  ch as mode,
  Zb as mouseX,
  Gb as mouseY,
  Xb as mousex,
  Lb as mousey,
  Lf as mtranspose,
  o3 as mul,
  nl as n,
  hc as nanFallback,
  P3 as ne,
  D3 as net,
  yM as never,
  z0 as noise,
  rl as note,
  In as noteToMidi,
  Ct as nothing,
  Q1 as nrpnn,
  ep as nrpv,
  Of as nudge,
  Mt as numeralArgs,
  Cc as objectMap,
  zf as octave,
  Wf as octaveR,
  oh as octaves,
  Kh as octer,
  Hh as octersub,
  Uh as octersubsub,
  gA as off,
  ah as offset,
  pM as often,
  Hp as onTriggerSample,
  E3 as or,
  jf as orbit,
  Qy as outerBind,
  J3 as outside,
  $f as overgain,
  qf as overshape,
  Rc as pace,
  oF as packageName,
  yc as pairs,
  MA as palindrome,
  Kf as pan,
  Sf as panchor,
  mC as panic,
  Yf as panorient,
  Hf as panspan,
  Uf as pansplay,
  Jf as panwidth,
  Fd as parse,
  gc as parseFractional,
  Pu as parseNumeral,
  u1 as partials,
  Mf as patt,
  bf as pattack,
  vr as patternifyAST,
  wf as pcurve,
  vf as pdec,
  Cf as pdecay,
  xf as penv,
  rM as perlin,
  xp as perlinWith,
  Kl as ph,
  n0 as phasdp,
  Hl as phaser,
  Yl as phasercenter,
  e0 as phaserdepth,
  ql as phaserrate,
  Ul as phasersweep,
  Ql as phc,
  t0 as phd,
  Jl as phs,
  wp as pick,
  vM as pickF,
  DM as pickOut,
  wM as pickReset,
  EM as pickRestart,
  _M as pickSqueeze,
  Sp as pickmod,
  PM as pickmodF,
  FM as pickmodOut,
  SM as pickmodReset,
  xM as pickmodRestart,
  IM as pickmodSqueeze,
  mc as pipe,
  S1 as pitchJump,
  B1 as pitchJumpTime,
  j3 as ply,
  Oy as pm,
  n3 as polyBind,
  ap as polyTouch,
  Li as polymeter,
  Zy as polyrhythm,
  al as postgain,
  f3 as pow,
  Wy as pr,
  Ef as prel,
  Ff as prelease,
  bA as press,
  AA as pressBy,
  $p as processSampleMap,
  tp as progNum,
  Df as psus,
  Pf as psustain,
  Ye as pure,
  gt as rand,
  Kb as rand2,
  Qb as randcat,
  vp as randrun,
  I3 as range,
  N3 as range2,
  V3 as rangex,
  dM as rarely,
  Qf as rate,
  T3 as ratio,
  dh as rdim,
  r1 as real,
  Ab as ref,
  T as register,
  w as registerControl,
  sC as registerSamplesPrefix,
  Wn as registerSound,
  od as registerSynthSounds,
  Ta as registerVoicings,
  vF as registerWidgetType,
  xC as registerZZFXSounds,
  K as reify,
  wl as rel,
  xl as release,
  Mr as removeUndefineds,
  IA as repeatCycles,
  k1 as repeatTime,
  GM as repl,
  td as resetDefaultValues,
  MC as resetGlobalEffects,
  hC as resetLoadedSounds,
  aF as resetVoicings,
  Y0 as resonance,
  Vc as rev,
  Op as reverseBuffer,
  gh as rfade,
  OA as rib,
  WA as ribbon,
  Jh as ring,
  Qh as ringdf,
  Yh as ringf,
  hh as rlp,
  lh as room,
  ph as roomdim,
  mh as roomfade,
  fh as roomlp,
  bh as roomsize,
  sF as rootNotes,
  dc as rotate,
  w3 as round,
  vh as rsize,
  Mp as run,
  Yc as s,
  nb as s_add,
  YA as s_alt,
  JA as s_cat,
  ub as s_contract,
  ib as s_expand,
  sb as s_extend,
  QA as s_polymeter,
  rb as s_sub,
  eb as s_taper,
  tb as s_taperlist,
  ab as s_tour,
  ob as s_zip,
  Kp as samples,
  ti as saw,
  Ru as saw2,
  j9 as scale,
  z9 as scaleTranspose,
  c1 as scram,
  qb as scramble,
  cp as scrub,
  y1 as seconds,
  lA as seg,
  cA as segment,
  th as semitone,
  kc as seq,
  $y as seqPLoop,
  Bt as sequence,
  xc as sequenceP,
  r3 as set,
  nd as setDefaultAudioContext,
  Yu as setDefaultValue,
  lC as setDefaultValues,
  Eg as setDefaultVoicings,
  aC as setGainCurve,
  Np as setLogger,
  Jp as setMaxPolyphony,
  Ec as setStringParser,
  xi as setTime,
  fC as setVersionDefaults,
  nF as setVoicingRange,
  Ph as shape,
  $c as shrink,
  jc as shrinklist,
  $b as shuffle,
  _t as signal,
  Se as silence,
  dp as sine,
  Gu as sine2,
  Mh as size,
  Uc as slice,
  eh as slide,
  K3 as slow,
  TA as slowChunk,
  Vn as slowcat,
  Su as slowcatPrime,
  NA as slowchunk,
  o1 as smear,
  wy as sol2note,
  hM as someCycles,
  fM as someCyclesBy,
  lM as sometimes,
  cM as sometimesBy,
  A1 as songPtr,
  Qc as sound,
  mr as soundMap,
  el as source,
  H3 as sparsity,
  TM as speak,
  Iu as speed,
  hb as splice,
  Fu as splitAt,
  pf as spread,
  mp as square,
  Ib as square2,
  VM as squeeze,
  e3 as squeezeBind,
  Ih as squiz,
  tl as src,
  Te as stack,
  zy as stackBy,
  Bc as stackCentre,
  wc as stackLeft,
  Sc as stackRight,
  Bb as steady,
  t3 as stepBind,
  Gc as stepalt,
  mt as stepcat,
  cb as steps,
  Zf as stepsPerOctave,
  _h as stretch,
  fb as striate,
  Ky as struct,
  SA as stut,
  EA as stutWith,
  xA as stutwith,
  a3 as sub,
  ji as superdough,
  CC as superdoughTrigger,
  Hy as superimpose,
  El as sus,
  Fl as sustain,
  Rh as sustainpedal,
  hA as swing,
  fA as swingBy,
  np as sysex,
  ip as sysexdata,
  rp as sysexid,
  Ch as sz,
  Xc as take,
  gp as time,
  ku as timeCat,
  UA as timecat,
  _3 as toBipolar,
  cc as tokenizeNote,
  qc as tour,
  mP as transpiler,
  O9 as transpose,
  Gh as tremdp,
  R1 as tremolo,
  Lh as tremolodepth,
  Xh as tremolorate,
  Zh as tremr,
  Vb as tri,
  Nb as tri2,
  jh as triode,
  n1 as tsdelay,
  b1 as uid,
  oM as undegrade,
  aM as undegradeBy,
  bc as unicodeToBase64,
  Sy as uniq,
  By as uniqsort,
  Ac as uniqsortr,
  hf as unison,
  kh as unit,
  O0 as v,
  M1 as val,
  py as valueToMidi,
  sl as velocity,
  Z0 as vib,
  j0 as vibmod,
  W0 as vibrato,
  $0 as vmod,
  nh as voice,
  uF as voicing,
  Kr as voicingAlias,
  _r as voicingRegistry,
  iF as voicings,
  Vh as vowel,
  cd as waveformN,
  Nh as waveloss,
  tM as wchoose,
  Ep as wchooseCycles,
  iu as webAudioTimeout,
  Ad as webaudioOutput,
  yd as webaudioOutputTrigger,
  bd as webaudioRepl,
  mA as when,
  bM as whenKey,
  Uy as withValue,
  KA as within,
  nM as wrandcat,
  Jc as xfade,
  t1 as xsdelay,
  N1 as zcrush,
  T1 as zdelay,
  Kc as zip,
  Eu as zipWith,
  V1 as zmod,
  I1 as znoise,
  iA as zoom,
  sA as zoomArc,
  uA as zoomarc,
  E1 as zrand,
  L1 as zzfx
};
