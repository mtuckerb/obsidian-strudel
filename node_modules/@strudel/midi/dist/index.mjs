import * as Y from "webmidi";
import { Note as F } from "webmidi";
import { Pattern as G, isPattern as _, logger as m, getEventOffsetMs as H, getControlName as q, noteToMidi as J, ref as K } from "@strudel/core";
const { WebMidi: s } = Y;
function Q() {
  return typeof navigator.requestMIDIAccess == "function";
}
function h(e) {
  return e.map((n) => `'${n.name}'`).join(" | ");
}
function R(e = {}) {
  const { onReady: n, onConnected: t, onDisconnected: r, onEnabled: i } = e;
  if (!s.enabled) {
    if (!Q())
      throw new Error("Your Browser does not support WebMIDI.");
    return s.addListener("connected", () => {
      t?.(s);
    }), s.addListener("enabled", () => {
      i?.(s);
    }), s.addListener("disconnected", (o) => {
      r?.(s, o);
    }), new Promise((o, c) => {
      if (s.enabled) {
        o(s);
        return;
      }
      s.enable(
        (l) => {
          l && c(l), n?.(s), o(s);
        },
        { sysex: !0 }
      );
    });
  }
}
function $(e, n) {
  if (!n.length)
    throw new Error("ðŸ”Œ No MIDI devices found. Connect a device or enable IAC Driver.");
  if (typeof e == "number")
    return n[e];
  const t = (o) => n.find((c) => c.name.includes(o));
  if (typeof e == "string")
    return t(e);
  const r = t("IAC"), i = r ?? n[0];
  if (!i)
    throw new Error(
      `ðŸ”Œ MIDI device '${i || ""}' not found. Use one of ${h(n)}`
    );
  return r ?? n[0];
}
typeof window < "u" && window.addEventListener("message", (e) => {
  s?.enabled && e.data === "strudel-stop" && s.outputs.forEach((n) => n.sendStop());
});
const w = /* @__PURE__ */ new Map();
function T(e) {
  return Object.fromEntries(
    Object.entries(e).map(([n, t]) => (typeof t == "number" && (t = { ccn: t }), [q(n), t]))
  );
}
function X(e, n = "") {
  if (!e.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [t, r] = e.split("github:");
  return r = r.endsWith("/") ? r.slice(0, -1) : r, r.split("/").length === 2 && (r += "/main"), `https://raw.githubusercontent.com/${r}/${n}`;
}
function de(e) {
  w.set("default", T(e));
}
let C = {};
async function fe(e) {
  typeof e == "string" && (e.startsWith("github:") && (e = X(e, "midimap.json")), C[e] || (C[e] = fetch(e).then((n) => n.json())), e = await C[e]), typeof e == "object" && Object.entries(e).forEach(([n, t]) => w.set(n, T(t)));
}
const ce = /* @__PURE__ */ new Map();
function Z(e = 0, n = 0, t = 1, r = 1) {
  if (n === t)
    throw new Error("min and max cannot be the same value");
  let i = (e - n) / (t - n);
  return i = Math.min(1, Math.max(0, i)), Math.pow(i, r);
}
function ee(e, n) {
  return Object.keys(n).filter((t) => !!e[q(t)]).map((t) => {
    const { ccn: r, min: i = 0, max: o = 1, exp: c = 1 } = e[t], l = Z(n[t], i, o, c);
    return { ccn: r, ccv: l };
  });
}
function A(e, n, t, r, i) {
  if (typeof n != "number" || n < 0 || n > 1)
    throw new Error("expected ccv to be a number between 0 and 1");
  if (!["string", "number"].includes(typeof e))
    throw new Error("expected ccn to be a number or a string");
  const o = Math.round(n * 127);
  t.sendControlChange(e, o, r, { time: i });
}
function L(e, n, t, r) {
  if (typeof e != "number" || e < 0 || e > 127)
    throw new Error("expected progNum (program change) to be a number between 0 and 127");
  n.sendProgramChange(e, t, { time: r });
}
function U(e, n, t, r) {
  if (Array.isArray(e)) {
    if (!e.every((i) => Number.isInteger(i) && i >= 0 && i <= 255))
      throw new Error("all sysexid bytes must be integers between 0 and 255");
  } else if (!Number.isInteger(e) || e < 0 || e > 255)
    throw new Error("A:sysexid must be an number between 0 and 255 or an array of such integers");
  if (!Array.isArray(n))
    throw new Error("expected sysex to be an array of numbers (0-255)");
  if (!n.every((i) => Number.isInteger(i) && i >= 0 && i <= 255))
    throw new Error("all sysex bytes must be integers between 0 and 255");
  t.sendSysex(e, n, { time: r });
}
function ne(e, n, t, r, i) {
  if (Array.isArray(e)) {
    if (!e.every((o) => Number.isInteger(o) && o >= 0 && o <= 255))
      throw new Error("all nrpnn bytes must be integers between 0 and 255");
  } else if (!Number.isInteger(n) || n < 0 || n > 255)
    throw new Error("A:sysexid must be an number between 0 and 255 or an array of such integers");
  t.sendNRPN(e, n, r, { time: i });
}
function te(e, n, t, r) {
  if (typeof e != "number" || e < -1 || e > 1)
    throw new Error("expected midibend to be a number between -1 and 1");
  n.sendPitchBend(e, t, { time: r });
}
function ie(e, n, t, r) {
  if (typeof e != "number" || e < 0 || e > 1)
    throw new Error("expected miditouch to be a number between 0 and 1");
  n.sendChannelAftertouch(e, t, { time: r });
}
function re(e, n, t, r, i, o) {
  if (e == null || e === "")
    throw new Error("note cannot be null or empty");
  if (n != null && (typeof n != "number" || n < 0 || n > 1))
    throw new Error("velocity must be a number between 0 and 1");
  if (t != null && (typeof t != "number" || t < 0))
    throw new Error("duration must be a positive number");
  const c = typeof e == "number" ? e : J(e), l = new F(c, { attack: n, duration: t });
  r.playNote(l, i, {
    time: o
  });
}
G.prototype.midi = function(e, n = {}) {
  if (_(e))
    throw new Error(
      `.midi does not accept Pattern input for midiport. Make sure to pass device name with single quotes. Example: .midi('${s.outputs?.[0]?.name || "IAC Driver Bus 1"}')`
    );
  if (typeof e == "object") {
    const { port: r, isController: i = !1, ...o } = e;
    n = {
      isController: i,
      ...o,
      ...n
      // Keep any options passed separately
    }, e = r;
  }
  let t = {
    // Default configuration values
    isController: !1,
    // Disable sending notes for midi controllers
    latencyMs: 34,
    // Default latency to get audio engine to line up in ms
    noteOffsetMs: 10,
    // Default note-off offset to prevent glitching in ms
    midichannel: 1,
    // Default MIDI channel
    velocity: 0.9,
    // Default velocity
    gain: 1,
    // Default gain
    midimap: "default",
    // Default MIDI map
    midiport: e,
    // Store the port in the config
    ...n
    // Override defaults with provided options
  };
  return R({
    onEnabled: ({ outputs: r }) => {
      const i = $(t.midiport, r), o = r.filter((c) => c.name !== i.name);
      m(
        `Midi enabled! Using "${i.name}". ${o?.length ? `Also available: ${h(o)}` : ""}`
      );
    },
    onDisconnected: ({ outputs: r }) => m(`Midi device disconnected! Available: ${h(r)}`)
  }), this.onTrigger((r, i, o, c, l) => {
    if (!s.enabled) {
      m("Midi not enabled");
      return;
    }
    i.ensureObjectValue();
    const z = t.latencyMs, d = `+${H(l, o) + z}`;
    let {
      note: I,
      nrpnn: N,
      nrpv: x,
      ccn: j,
      ccv: P,
      midichan: u = t.midichannel,
      midicmd: f,
      midibend: D,
      miditouch: O,
      polyTouch: oe,
      gain: V = t.gain,
      velocity: E = t.velocity,
      progNum: S,
      sysexid: k,
      sysexdata: B,
      midimap: g = t.midimap,
      midiport: W = t.midiport
    } = i.value;
    const a = $(W, s.outputs);
    if (!a) {
      m(
        `[midi] midiport "${W}" not found! available: ${s.outputs.map((b) => `'${b.name}'`).join(", ")}`
      );
      return;
    }
    if (E = V * E, w.has(g) ? ee(w.get(g), i.value).forEach(({ ccn: M, ccv: v }) => A(M, v, a, u, d)) : g !== "default" && m(`[midi] midimap "${g}" not found! Available maps: ${[...w.keys()].join(", ")}`), I !== void 0 && !t.isController) {
      const b = i.duration.valueOf() / c * 1e3 - t.noteOffsetMs;
      re(I, E, b, a, u, d);
    }
    if (S !== void 0 && L(S, a, u, d), k !== void 0 && B !== void 0 && U(k, B, a, d), P !== void 0 && j !== void 0 && A(j, P, a, u, d), N !== void 0 && x !== void 0 && ne(N, x, a, u, d), D !== void 0 && te(D, a, u, d), O !== void 0 && ie(O, a, u, d), i.whole.begin + 0 === 0 && a.sendStart({ time: d }), ["clock", "midiClock"].includes(f))
      a.sendClock({ time: d });
    else if (["start"].includes(f))
      a.sendStart({ time: d });
    else if (["stop"].includes(f))
      a.sendStop({ time: d });
    else if (["continue"].includes(f))
      a.sendContinue({ time: d });
    else if (Array.isArray(f)) {
      if (f[0] === "progNum")
        L(f[1], a, u, d);
      else if (f[0] === "cc")
        f.length === 2 && A(f[0], f[1] / 127, a, u, d);
      else if (f[0] === "sysex" && f.length === 3) {
        const [b, M, v] = f;
        U(M, v, a, d);
      }
    }
  });
};
let p = {};
const y = {};
async function ue(e) {
  if (_(e))
    throw new Error(
      `midin: does not accept Pattern as input. Make sure to pass device name with single quotes. Example: midin('${s.outputs?.[0]?.name || "IAC Driver Bus 1"}')`
    );
  const n = await R(), t = $(e, s.inputs);
  if (!t)
    throw new Error(
      `midiin: device "${e}" not found.. connected devices: ${h(s.inputs)}`
    );
  if (n) {
    const i = s.inputs.filter((o) => o.name !== t.name);
    m(
      `Midi enabled! Using "${t.name}". ${i?.length ? `Also available: ${h(i)}` : ""}`
    ), y[e] = {};
  }
  const r = (i) => K(() => y[e][i] || 0);
  return p[e] && t.removeListener("midimessage", p[e]), p[e] = (i) => {
    const o = i.dataBytes[0], c = i.dataBytes[1];
    y[e] && (y[e][o] = c / 127);
  }, t.addListener("midimessage", p[e]), r;
}
export {
  s as WebMidi,
  de as defaultmidimap,
  R as enableWebMidi,
  w as midicontrolMap,
  fe as midimaps,
  ue as midin,
  ce as midisoundMap
};
