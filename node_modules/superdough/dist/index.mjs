import { map as Te } from "nanostores";
if (typeof DelayNode < "u") {
  class t extends DelayNode {
    constructor(n, c, a, o) {
      super(n), c = Math.abs(c), this.delayTime.value = a;
      const s = n.createGain();
      s.gain.value = Math.min(Math.abs(o), 0.995), this.feedback = s.gain;
      const d = n.createGain();
      return d.gain.value = c, this.delayGain = d, this.connect(s), this.connect(d), s.connect(this), this.connect = (l) => d.connect(l), this;
    }
    start(n) {
      this.delayGain.gain.setValueAtTime(this.delayGain.gain.value, n + this.delayTime.value);
    }
  }
  AudioContext.prototype.createFeedbackDelay = function(e, n, c) {
    return new t(this, e, n, c);
  };
}
var wt = {};
wt.generateReverb = function(t, e) {
  for (var n = t.audioContext || new AudioContext(), c = n.sampleRate, a = t.numChannels || 2, o = t.decayTime * 1.5, s = Math.round(t.decayTime * c), d = Math.round(o * c), l = Math.round((t.fadeInTime || 0) * c), r = Math.pow(1 / 1e3, 1 / s), i = n.createBuffer(a, d, c), b = 0; b < a; b++) {
    for (var m = i.getChannelData(b), u = 0; u < d; u++)
      m[u] = Fe() * Math.pow(r, u);
    for (var u = 0; u < l; u++)
      m[u] *= u / l;
  }
  Ne(i, t.lpFreqStart || 0, t.lpFreqEnd || 0, t.decayTime, e);
};
wt.generateGraph = function(t, e, n, c, a) {
  var o = document.createElement("canvas");
  o.width = e, o.height = n;
  var s = o.getContext("2d");
  s.fillStyle = "#000", s.fillRect(0, 0, o.width, o.height), s.fillStyle = "#fff";
  for (var d = e / t.length, l = n / (a - c), r = 0; r < t.length; r++)
    s.fillRect(r * d, n - (t[r] - c) * l, 1, 1);
  return o;
};
var Ne = function(t, e, n, c, a) {
  if (e == 0) {
    a(t);
    return;
  }
  var o = Ye(t), s = new OfflineAudioContext(t.numberOfChannels, o[0].length, t.sampleRate), d = s.createBufferSource();
  d.buffer = t;
  var l = s.createBiquadFilter();
  e = Math.min(e, t.sampleRate / 2), n = Math.min(n, t.sampleRate / 2), l.type = "lowpass", l.Q.value = 1e-4, l.frequency.setValueAtTime(e, 0), l.frequency.linearRampToValueAtTime(n, c), d.connect(l), l.connect(s.destination), d.start(), s.oncomplete = function(r) {
    a(r.renderedBuffer);
  }, s.startRendering(), window.filterNode = l;
}, Ye = function(t) {
  for (var e = [], n = 0; n < t.numberOfChannels; n++)
    e[n] = t.getChannelData(n);
  return e;
}, Fe = function() {
  return Math.random() * 2 - 1;
};
typeof AudioContext < "u" && (AudioContext.prototype.adjustLength = function(t, e) {
  const n = e.sampleRate * t, c = this.createBuffer(e.numberOfChannels, e.length, e.sampleRate);
  for (let a = 0; a < e.numberOfChannels; a++) {
    let o = e.getChannelData(a), s = c.getChannelData(a);
    for (let d = 0; d < n; d++)
      s[d] = o[d] || 0;
  }
  return c;
}, AudioContext.prototype.createReverb = function(t, e, n, c, a) {
  const o = this.createConvolver();
  return o.generate = (s = 2, d = 0.1, l = 15e3, r = 1e3, i) => {
    o.duration = s, o.fade = d, o.lp = l, o.dim = r, o.ir = i, i ? o.buffer = this.adjustLength(s, i) : wt.generateReverb(
      {
        audioContext: this,
        numChannels: 2,
        decayTime: s,
        fadeInTime: d,
        lpFreqStart: l,
        lpFreqEnd: r
      },
      (b) => {
        o.buffer = b;
      }
    );
  }, o.generate(t, e, n, c, a), o;
});
var ee = {
  a: { freqs: [660, 1120, 2750, 3e3, 3350], gains: [1, 0.5012, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  e: { freqs: [440, 1800, 2700, 3e3, 3300], gains: [1, 0.1995, 0.1259, 0.1, 0.1], qs: [70, 80, 100, 120, 120] },
  i: { freqs: [270, 1850, 2900, 3350, 3590], gains: [1, 0.0631, 0.0631, 0.0158, 0.0158], qs: [40, 90, 100, 120, 120] },
  o: { freqs: [430, 820, 2700, 3e3, 3300], gains: [1, 0.3162, 0.0501, 0.0794, 0.01995], qs: [40, 80, 100, 120, 120] },
  u: { freqs: [370, 630, 2750, 3e3, 3400], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ae: { freqs: [650, 1515, 2400, 3e3, 3350], gains: [1, 0.5, 0.1008, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  aa: { freqs: [560, 900, 2570, 3e3, 3300], gains: [1, 0.5, 0.0708, 0.0631, 0.0126], qs: [80, 90, 120, 130, 140] },
  oe: { freqs: [500, 1430, 2300, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  ue: { freqs: [250, 1750, 2150, 3200, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.01995], qs: [40, 60, 100, 120, 120] },
  y: { freqs: [400, 1460, 2400, 3e3, 3300], gains: [1, 0.2, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  uh: { freqs: [600, 1250, 2100, 3100, 3500], gains: [1, 0.3, 0.0608, 0.0316, 0.01995], qs: [40, 70, 100, 120, 130] },
  un: { freqs: [500, 1240, 2280, 3e3, 3500], gains: [1, 0.1, 0.1708, 0.0216, 0.02995], qs: [40, 60, 100, 120, 120] },
  en: { freqs: [600, 1480, 2450, 3200, 3300], gains: [1, 0.15, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  an: { freqs: [700, 1050, 2500, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  on: { freqs: [500, 1080, 2350, 3e3, 3300], gains: [1, 0.1, 0.0708, 0.0316, 0.02995], qs: [40, 60, 100, 120, 120] },
  get æ() {
    return this.ae;
  },
  get ø() {
    return this.oe;
  },
  get ɑ() {
    return this.aa;
  },
  get å() {
    return this.aa;
  },
  get ö() {
    return this.oe;
  },
  get ü() {
    return this.ue;
  },
  get ı() {
    return this.y;
  }
};
if (typeof GainNode < "u") {
  class t extends GainNode {
    constructor(n, c) {
      if (super(n), !ee[c])
        throw new Error("vowel: unknown vowel " + c);
      const { gains: a, qs: o, freqs: s } = ee[c], d = n.createGain();
      for (let l = 0; l < 5; l++) {
        const r = n.createGain();
        r.gain.value = a[l];
        const i = n.createBiquadFilter();
        i.type = "bandpass", i.Q.value = o[l], i.frequency.value = s[l], this.connect(i), i.connect(r), r.connect(d);
      }
      return d.gain.value = 8, this.connect = (l) => d.connect(l), this;
    }
  }
  AudioContext.prototype.createVowelFilter = function(e) {
    return new t(this, e);
  };
}
let le = (t) => console.log(t);
const N = (...t) => le(...t), Ln = (t) => {
  le = t;
}, Pe = (t) => {
  if (typeof t != "string")
    return [];
  const [e, n = "", c] = t.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return e ? [e, n, c ? Number(c) : void 0] : [];
}, Ce = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, ve = { "#": 1, b: -1, s: 1, f: -1 }, Xt = (t, e = 3) => {
  const [n, c, a = e] = Pe(t);
  if (!n)
    throw new Error('not a note: "' + t + '"');
  const o = Ce[n.toLowerCase()], s = c?.split("").reduce((d, l) => d + ve[l], 0) || 0;
  return (Number(a) + 1) * 12 + o + s;
}, re = (t) => Math.pow(2, (t - 69) / 12) * 440, et = (t, e, n) => Math.min(Math.max(t, e), n), Je = (t) => 12 * Math.log(t / 440) / Math.LN2 + 69, Ie = (t, e) => {
  if (typeof t != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: c } = t;
  return typeof n == "number" ? Je(n) : typeof c == "string" ? Xt(c) : typeof c == "number" ? c : e;
};
function k(t, e = 0, n) {
  return isNaN(Number(t)) ? (!n && N(`"${t}" is not a number, falling back to ${e}`, "warning"), e) : t;
}
const ie = (t, e) => (t % e + e) % e, ne = (t, e) => ie(Math.round(k(t, 0)), e), ke = "data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHB0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLm5iSW5wdXRzPXQubnVtYmVyT2ZJbnB1dHMsdGhpcy5uYk91dHB1dHM9dC5udW1iZXJPZk91dHB1dHMsdGhpcy5ibG9ja1NpemU9dC5wcm9jZXNzb3JPcHRpb25zLmJsb2NrU2l6ZSx0aGlzLmhvcFNpemU9MTI4LHRoaXMubmJPdmVybGFwcz10aGlzLmJsb2NrU2l6ZS90aGlzLmhvcFNpemUsdGhpcy5pbnB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpLHRoaXMuaW5wdXRCdWZmZXJzSGVhZD1uZXcgQXJyYXkodGhpcy5uYklucHV0cyksdGhpcy5pbnB1dEJ1ZmZlcnNUb1NlbmQ9bmV3IEFycmF5KHRoaXMubmJJbnB1dHMpO2ZvcihsZXQgZT0wO2U8dGhpcy5uYklucHV0cztlKyspdGhpcy5hbGxvY2F0ZUlucHV0Q2hhbm5lbHMoZSwxKTt0aGlzLm91dHB1dEJ1ZmZlcnM9bmV3IEFycmF5KHRoaXMubmJPdXRwdXRzKSx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlPW5ldyBBcnJheSh0aGlzLm5iT3V0cHV0cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLm5iT3V0cHV0cztlKyspdGhpcy5hbGxvY2F0ZU91dHB1dENoYW5uZWxzKGUsMSl9cmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKXtmb3IobGV0IHM9MDtzPHRoaXMubmJJbnB1dHM7cysrKXtsZXQgcj10W3NdLmxlbmd0aDtyIT10aGlzLmlucHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVJbnB1dENoYW5uZWxzKHMscil9Zm9yKGxldCBzPTA7czx0aGlzLm5iT3V0cHV0cztzKyspe2xldCByPWVbc10ubGVuZ3RoO3IhPXRoaXMub3V0cHV0QnVmZmVyc1tzXS5sZW5ndGgmJnRoaXMuYWxsb2NhdGVPdXRwdXRDaGFubmVscyhzLHIpfX1hbGxvY2F0ZUlucHV0Q2hhbm5lbHModCxlKXt0aGlzLmlucHV0QnVmZmVyc1t0XT1uZXcgQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlO3MrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKzEyOCksdGhpcy5pbnB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLmlucHV0QnVmZmVyc0hlYWRbdF09bmV3IEFycmF5KGUpLHRoaXMuaW5wdXRCdWZmZXJzVG9TZW5kW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuaW5wdXRCdWZmZXJzSGVhZFt0XVtzXT10aGlzLmlucHV0QnVmZmVyc1t0XVtzXS5zdWJhcnJheSgwLHRoaXMuYmxvY2tTaXplKSx0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKX1hbGxvY2F0ZU91dHB1dENoYW5uZWxzKHQsZSl7dGhpcy5vdXRwdXRCdWZmZXJzW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtzXT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmxvY2tTaXplKSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bc10uZmlsbCgwKTt0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdPW5ldyBBcnJheShlKTtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMub3V0cHV0QnVmZmVyc1RvUmV0cmlldmVbdF1bc109bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJsb2NrU2l6ZSksdGhpcy5vdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZVt0XVtzXS5maWxsKDApfXJlYWRJbnB1dHModCl7aWYodFswXS5sZW5ndGgmJnRbMF1bMF0ubGVuZ3RoPT0wKXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5maWxsKDAsdGhpcy5ibG9ja1NpemUpO3JldHVybn1mb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dFtlXVtzXTt0aGlzLmlucHV0QnVmZmVyc1tlXVtzXS5zZXQocix0aGlzLmJsb2NrU2l6ZSl9fXdyaXRlT3V0cHV0cyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubmJJbnB1dHM7ZSsrKWZvcihsZXQgcz0wO3M8dGhpcy5pbnB1dEJ1ZmZlcnNbZV0ubGVuZ3RoO3MrKyl7bGV0IHI9dGhpcy5vdXRwdXRCdWZmZXJzW2VdW3NdLnN1YmFycmF5KDAsMTI4KTt0W2VdW3NdLnNldChyKX19c2hpZnRJbnB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KX1zaGlmdE91dHB1dEJ1ZmZlcnMoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJPdXRwdXRzO3QrKylmb3IobGV0IGU9MDtlPHRoaXMub3V0cHV0QnVmZmVyc1t0XS5sZW5ndGg7ZSsrKXRoaXMub3V0cHV0QnVmZmVyc1t0XVtlXS5jb3B5V2l0aGluKDAsMTI4KSx0aGlzLm91dHB1dEJ1ZmZlcnNbdF1bZV0uc3ViYXJyYXkodGhpcy5ibG9ja1NpemUtMTI4KS5maWxsKDApfXByZXBhcmVJbnB1dEJ1ZmZlcnNUb1NlbmQoKXtmb3IobGV0IHQ9MDt0PHRoaXMubmJJbnB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5pbnB1dEJ1ZmZlcnNbdF0ubGVuZ3RoO2UrKyl0aGlzLmlucHV0QnVmZmVyc1RvU2VuZFt0XVtlXS5zZXQodGhpcy5pbnB1dEJ1ZmZlcnNIZWFkW3RdW2VdKX1oYW5kbGVPdXRwdXRCdWZmZXJzVG9SZXRyaWV2ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5uYk91dHB1dHM7dCsrKWZvcihsZXQgZT0wO2U8dGhpcy5vdXRwdXRCdWZmZXJzW3RdLmxlbmd0aDtlKyspZm9yKGxldCBzPTA7czx0aGlzLmJsb2NrU2l6ZTtzKyspdGhpcy5vdXRwdXRCdWZmZXJzW3RdW2VdW3NdKz10aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlW3RdW2VdW3NdL3RoaXMubmJPdmVybGFwc31wcm9jZXNzKHQsZSxzKXtjb25zdCBuPXRbMF1bMF0hPT12b2lkIDA7cmV0dXJuIHRoaXMuc3RhcnRlZCYmIW4/ITE6KHRoaXMuc3RhcnRlZD1uLHRoaXMucmVhbGxvY2F0ZUNoYW5uZWxzSWZOZWVkZWQodCxlKSx0aGlzLnJlYWRJbnB1dHModCksdGhpcy5zaGlmdElucHV0QnVmZmVycygpLHRoaXMucHJlcGFyZUlucHV0QnVmZmVyc1RvU2VuZCgpLHRoaXMucHJvY2Vzc09MQSh0aGlzLmlucHV0QnVmZmVyc1RvU2VuZCx0aGlzLm91dHB1dEJ1ZmZlcnNUb1JldHJpZXZlLHMpLHRoaXMuaGFuZGxlT3V0cHV0QnVmZmVyc1RvUmV0cmlldmUoKSx0aGlzLndyaXRlT3V0cHV0cyhlKSx0aGlzLnNoaWZ0T3V0cHV0QnVmZmVycygpLCEwKX1wcm9jZXNzT0xBKHQsZSxzKXtjb25zb2xlLmFzc2VydCghMSwiTm90IG92ZXJyaWRlbiIpfX1jbGFzcyBkdHtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNpemU9dHwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPXQ8PDE7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNpemUqMikscz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3Qgbz1NYXRoLlBJKnMvdGhpcy5zaXplO2Vbc109TWF0aC5jb3MobyksZVtzKzFdPS1NYXRoLnNpbihvKX10aGlzLnRhYmxlPWU7Zm9yKHZhciByPTAsbj0xO3RoaXMuc2l6ZT5uO248PD0xKXIrKzt0aGlzLl93aWR0aD1yJTI9PT0wP3ItMTpyLHRoaXMuX2JpdHJldj1uZXcgQXJyYXkoMTw8dGhpcy5fd2lkdGgpO2Zvcih2YXIgaT0wO2k8dGhpcy5fYml0cmV2Lmxlbmd0aDtpKyspe3RoaXMuX2JpdHJldltpXT0wO2Zvcih2YXIgYT0wO2E8dGhpcy5fd2lkdGg7YSs9Mil7dmFyIGw9dGhpcy5fd2lkdGgtYS0yO3RoaXMuX2JpdHJldltpXXw9KGk+Pj5hJjMpPDxsfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9ZnJvbUNvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHxuZXcgQXJyYXkodC5sZW5ndGg+Pj4xKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKXNbcj4+PjFdPXRbcl07cmV0dXJuIHN9Y3JlYXRlQ29tcGxleEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fY3NpemUpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09MDtyZXR1cm4gdH10b0NvbXBsZXhBcnJheSh0LGUpe2Zvcih2YXIgcz1lfHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpLHI9MDtyPHMubGVuZ3RoO3IrPTIpc1tyXT10W3I+Pj4xXSxzW3IrMV09MDtyZXR1cm4gc31jb21wbGV0ZVNwZWN0cnVtKHQpe2Zvcih2YXIgZT10aGlzLl9jc2l6ZSxzPWU+Pj4xLHI9MjtyPHM7cis9Mil0W2Utcl09dFtyXSx0W2UtcisxXT0tdFtyKzFdfXRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9cmVhbFRyYW5zZm9ybSh0LGUpe2lmKHQ9PT1lKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1lLHRoaXMuX2ludj0wLHRoaXMuX3JlYWxUcmFuc2Zvcm00KCksdGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfWludmVyc2VUcmFuc2Zvcm0odCxlKXtpZih0PT09ZSl0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9ZSx0aGlzLl9pbnY9MSx0aGlzLl90cmFuc2Zvcm00KCk7Zm9yKHZhciBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXS89dGhpcy5zaXplO3RoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1fdHJhbnNmb3JtNCgpe3ZhciB0PXRoaXMuX291dCxlPXRoaXMuX2NzaXplLHM9dGhpcy5fd2lkdGgscj0xPDxzLG49ZS9yPDwxLGksYSxsPXRoaXMuX2JpdHJldjtpZihuPT09NClmb3IoaT0wLGE9MDtpPGU7aSs9bixhKyspe2NvbnN0IGQ9bFthXTt0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGksZCxyKX1lbHNlIGZvcihpPTAsYT0wO2k8ZTtpKz1uLGErKyl7Y29uc3QgZD1sW2FdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTQoaSxkLHIpfXZhciBvPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjI7Zm9yKGk9MDtpPGU7aSs9bilmb3IodmFyIHY9aStmLGM9aSxwPTA7Yzx2O2MrPTIscCs9cil7Y29uc3QgZD1jLGc9ZCtmLG09ZytmLEk9bStmLF89dFtkXSx3PXRbZCsxXSxCPXRbZ10sYj10W2crMV0sQT10W21dLFA9dFttKzFdLFQ9dFtJXSx5PXRbSSsxXSx4PV8sRj13LEM9dVtwXSxrPW8qdVtwKzFdLHo9QipDLWIqayxWPUIqaytiKkMsTj11WzIqcF0scT1vKnVbMipwKzFdLFc9QSpOLVAqcSxZPUEqcStQKk4sTD11WzMqcF0sVT1vKnVbMypwKzFdLEg9VCpMLXkqVSxLPVQqVSt5KkwsWj14K1csTT1GK1ksTz14LVcsRz1GLVksSj16K0gsRT1WK0ssUj1vKih6LUgpLFE9byooVi1LKSwkPVorSixldD1NK0Usc3Q9Wi1KLHJ0PU0tRSxpdD1PK1EsbnQ9Ry1SLG90PU8tUSxhdD1HK1I7dFtkXT0kLHRbZCsxXT1ldCx0W2ddPWl0LHRbZysxXT1udCx0W21dPXN0LHRbbSsxXT1ydCx0W0ldPW90LHRbSSsxXT1hdH19fV9zaW5nbGVUcmFuc2Zvcm0yKHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT1uW2VdLGE9bltlKzFdLGw9bltlK3NdLG89bltlK3MrMV0sdT1pK2wsZj1hK28sdj1pLWwsYz1hLW87clt0XT11LHJbdCsxXT1mLHJbdCsyXT12LHJbdCszXT1jfV9zaW5nbGVUcmFuc2Zvcm00KHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT10aGlzLl9pbnY/LTE6MSxhPXMqMixsPXMqMyxvPW5bZV0sdT1uW2UrMV0sZj1uW2Urc10sdj1uW2UrcysxXSxjPW5bZSthXSxwPW5bZSthKzFdLGQ9bltlK2xdLGc9bltlK2wrMV0sbT1vK2MsST11K3AsXz1vLWMsdz11LXAsQj1mK2QsYj12K2csQT1pKihmLWQpLFA9aSoodi1nKSxUPW0rQix5PUkrYix4PV8rUCxGPXctQSxDPW0tQixrPUktYix6PV8tUCxWPXcrQTtyW3RdPVQsclt0KzFdPXksclt0KzJdPXgsclt0KzNdPUYsclt0KzRdPUMsclt0KzVdPWssclt0KzZdPXosclt0KzddPVZ9X3JlYWxUcmFuc2Zvcm00KCl7dmFyIHQ9dGhpcy5fb3V0LGU9dGhpcy5fY3NpemUscz10aGlzLl93aWR0aCxyPTE8PHMsbj1lL3I8PDEsaSxhLGw9dGhpcy5fYml0cmV2O2lmKG49PT00KWZvcihpPTAsYT0wO2k8ZTtpKz1uLGErKyl7Y29uc3QgaHQ9bFthXTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtMihpLGh0Pj4+MSxyPj4+MSl9ZWxzZSBmb3IoaT0wLGE9MDtpPGU7aSs9bixhKyspe2NvbnN0IGh0PWxbYV07dGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTQoaSxodD4+PjEscj4+PjEpfXZhciBvPXRoaXMuX2ludj8tMToxLHU9dGhpcy50YWJsZTtmb3Iocj4+PTI7cj49MjtyPj49Mil7bj1lL3I8PDE7dmFyIGY9bj4+PjEsdj1mPj4+MSxjPXY+Pj4xO2ZvcihpPTA7aTxlO2krPW4pZm9yKHZhciBwPTAsZD0wO3A8PWM7cCs9MixkKz1yKXt2YXIgZz1pK3AsbT1nK3YsST1tK3YsXz1JK3Ysdz10W2ddLEI9dFtnKzFdLGI9dFttXSxBPXRbbSsxXSxQPXRbSV0sVD10W0krMV0seT10W19dLHg9dFtfKzFdLEY9dyxDPUIsaz11W2RdLHo9byp1W2QrMV0sVj1iKmstQSp6LE49Yip6K0EqayxxPXVbMipkXSxXPW8qdVsyKmQrMV0sWT1QKnEtVCpXLEw9UCpXK1QqcSxVPXVbMypkXSxIPW8qdVszKmQrMV0sSz15KlUteCpILFo9eSpIK3gqVSxNPUYrWSxPPUMrTCxHPUYtWSxKPUMtTCxFPVYrSyxSPU4rWixRPW8qKFYtSyksJD1vKihOLVopLGV0PU0rRSxzdD1PK1IscnQ9RyskLGl0PUotUTtpZih0W2ddPWV0LHRbZysxXT1zdCx0W21dPXJ0LHRbbSsxXT1pdCxwPT09MCl7dmFyIG50PU0tRSxvdD1PLVI7dFtJXT1udCx0W0krMV09b3Q7Y29udGludWV9aWYocCE9PWMpe3ZhciBhdD1HLGt0PS1KLHp0PU0sVnQ9LU8sTXQ9LW8qJCxPdD0tbypRLEV0PS1vKlIsUnQ9LW8qRSxEdD1hdCtNdCxOdD1rdCtPdCxxdD16dCtSdCxXdD1WdC1FdCxsdD1pK3YtcCxmdD1pK2YtcDt0W2x0XT1EdCx0W2x0KzFdPU50LHRbZnRdPXF0LHRbZnQrMV09V3R9fX19X3NpbmdsZVJlYWxUcmFuc2Zvcm0yKHQsZSxzKXtjb25zdCByPXRoaXMuX291dCxuPXRoaXMuX2RhdGEsaT1uW2VdLGE9bltlK3NdLGw9aSthLG89aS1hO3JbdF09bCxyW3QrMV09MCxyW3QrMl09byxyW3QrM109MH1fc2luZ2xlUmVhbFRyYW5zZm9ybTQodCxlLHMpe2NvbnN0IHI9dGhpcy5fb3V0LG49dGhpcy5fZGF0YSxpPXRoaXMuX2ludj8tMToxLGE9cyoyLGw9cyozLG89bltlXSx1PW5bZStzXSxmPW5bZSthXSx2PW5bZStsXSxjPW8rZixwPW8tZixkPXUrdixnPWkqKHUtdiksbT1jK2QsST1wLF89LWcsdz1jLWQsQj1wLGI9ZztyW3RdPW0sclt0KzFdPTAsclt0KzJdPUksclt0KzNdPV8sclt0KzRdPXcsclt0KzVdPTAsclt0KzZdPUIsclt0KzddPWJ9fWNvbnN0IFg9KGgsdCxlKT0+TWF0aC5taW4oTWF0aC5tYXgoaCx0KSxlKSx2dD0oaCx0KT0+KGgldCt0KSV0LEQ9MTI4O2Z1bmN0aW9uIG10KGgsdCl7cmV0dXJuIGg8dD8oaC89dCxoK2gtaCpoLTEpOmg+MS10PyhoPShoLTEpL3QsaCpoK2graCsxKTowfWNvbnN0IGo9e3RyaShoLHQ9LjUpe2NvbnN0IGU9MS10O3JldHVybiBoPj10PzEvZS1oL2U6aC90fSxzaW5lKGgpe3JldHVybiBNYXRoLnNpbihNYXRoLlBJKjIqaCkqLjUrLjV9LHJhbXAoaCl7cmV0dXJuIGh9LHNhdyhoKXtyZXR1cm4gMS1ofSxzcXVhcmUoaCx0PS41KXtyZXR1cm4gaD49dD8wOjF9LGN1c3RvbShoLHQ9WzAsMV0pe2NvbnN0IGU9dC5sZW5ndGgtMSxzPU1hdGguZmxvb3IoaCplKSxyPTEvZSxuPVgodFtzXSwwLDEpLGE9WCh0W3MrMV0sMCwxKSxsPW4sbz0wLHU9cjtyZXR1cm4oYS1sKS8odS1vKSooaC1yKnMpK259LHNhd2JsZXAoaCx0KXtyZXR1cm4gMipoLTEtbXQoaCx0KX19O2Z1bmN0aW9uIHR0KGgsdCl7cmV0dXJuIHQubGVuZ3RoPjE/dFtoXTp0WzBdfWNvbnN0IGd0PU9iamVjdC5rZXlzKGopO2NsYXNzIEl0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6InRpbWUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MH0se25hbWU6ImZyZXF1ZW5jeSIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToic2tldyIsZGVmYXVsdFZhbHVlOi41fSx7bmFtZToiZGVwdGgiLGRlZmF1bHRWYWx1ZToxfSx7bmFtZToicGhhc2VvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToiZGNvZmZzZXQiLGRlZmF1bHRWYWx1ZTowfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGhhc2V9aW5jcmVtZW50UGhhc2UodCl7dGhpcy5waGFzZSs9dCx0aGlzLnBoYXNlPjEmJih0aGlzLnBoYXNlPXRoaXMucGhhc2UtMSl9cHJvY2Vzcyh0LGUscyl7aWYoY3VycmVudFRpbWU+PXMuZW5kWzBdKXJldHVybiExO2NvbnN0IHI9ZVswXSxuPXMuZnJlcXVlbmN5WzBdLGk9cy50aW1lWzBdLGE9cy5kZXB0aFswXSxsPXMuc2tld1swXSxvPXMucGhhc2VvZmZzZXRbMF0sdT1zLmRjb2Zmc2V0WzBdLGY9Z3Rbcy5zaGFwZVswXV0sdj1yWzBdLmxlbmd0aD8/MDt0aGlzLnBoYXNlPT1udWxsJiYodGhpcy5waGFzZT12dChpKm4rbywxKSk7Y29uc3QgYz1uL3NhbXBsZVJhdGU7Zm9yKGxldCBwPTA7cDx2O3ArKyl7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspe2NvbnN0IGc9KGpbZl0odGhpcy5waGFzZSxsKSt1KSphO3JbZF1bcF09Z310aGlzLmluY3JlbWVudFBoYXNlKGMpfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGZvLXByb2Nlc3NvciIsSXQpO2NsYXNzIEJ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNvYXJzZSIsZGVmYXVsdFZhbHVlOjF9XX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5zdGFydGVkPSExfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7bGV0IGE9cy5jb2Fyc2VbMF0/PzA7YT1NYXRoLm1heCgxLGEpO2ZvcihsZXQgbD0wO2w8RDtsKyspZm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspbltvXVtsXT1sJWE9PT0wP3Jbb11bbF06bltvXVtsLTFdO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY29hcnNlLXByb2Nlc3NvciIsQnQpO2NsYXNzIGJ0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImNydXNoIixkZWZhdWx0VmFsdWU6MH1dfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnN0YXJ0ZWQ9ITF9cHJvY2Vzcyh0LGUscyl7Y29uc3Qgcj10WzBdLG49ZVswXSxpPXJbMF0hPT12b2lkIDA7aWYodGhpcy5zdGFydGVkJiYhaSlyZXR1cm4hMTt0aGlzLnN0YXJ0ZWQ9aTtsZXQgYT1zLmNydXNoWzBdPz84O2E9TWF0aC5tYXgoMSxhKTtmb3IobGV0IGw9MDtsPEQ7bCsrKWZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCB1PU1hdGgucG93KDIsYS0xKTtuW29dW2xdPU1hdGgucm91bmQocltvXVtsXSp1KS91fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiY3J1c2gtcHJvY2Vzc29yIixidCk7Y2xhc3MgX3QgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToic2hhcGUiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2xldCBhPXMuc2hhcGVbMF07YT1hPDE/YToxLTRlLTEwLGE9MiphLygxLWEpO2NvbnN0IGw9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IG89MDtvPEQ7bysrKWZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKW5bdV1bb109KDErYSkqclt1XVtvXS8oMSthKk1hdGguYWJzKHJbdV1bb10pKSpsO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic2hhcGUtcHJvY2Vzc29yIixfdCk7ZnVuY3Rpb24gUyhoKXtjb25zdCB0PWgqaDtyZXR1cm4gaCooMjcrdCkvKDI3KzkqdCl9Y29uc3QgdXQ9My4xNDE1OTI2NTM1OTtjbGFzcyB3dCBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCl7cmV0dXJuW3tuYW1lOiJmcmVxdWVuY3kiLGRlZmF1bHRWYWx1ZTo1MDB9LHtuYW1lOiJxIixkZWZhdWx0VmFsdWU6MX0se25hbWU6ImRyaXZlIixkZWZhdWx0VmFsdWU6LjY5fV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMSx0aGlzLnAwPVswLDBdLHRoaXMucDE9WzAsMF0sdGhpcy5wMj1bMCwwXSx0aGlzLnAzPVswLDBdLHRoaXMucDMyPVswLDBdLHRoaXMucDMzPVswLDBdLHRoaXMucDM0PVswLDBdfXByb2Nlc3ModCxlLHMpe2NvbnN0IHI9dFswXSxuPWVbMF0saT1yWzBdIT09dm9pZCAwO2lmKHRoaXMuc3RhcnRlZCYmIWkpcmV0dXJuITE7dGhpcy5zdGFydGVkPWk7Y29uc3QgYT1zLnFbMF0sbD1YKE1hdGguZXhwKHMuZHJpdmVbMF0pLC4xLDJlMyk7bGV0IG89cy5mcmVxdWVuY3lbMF07bz1vKjIqdXQvc2FtcGxlUmF0ZSxvPW8+MT8xOm87Y29uc3QgdT1NYXRoLm1pbig4LGEqLjQpO2xldCBmPTEvbCpNYXRoLm1pbigxLjc1LDErdSk7Zm9yKGxldCB2PTA7djxEO3YrKylmb3IobGV0IGM9MDtjPHIubGVuZ3RoO2MrKyl7Y29uc3QgcD10aGlzLnAzW2NdKi4zNjA4OTErdGhpcy5wMzJbY10qLjQxNzI5K3RoaXMucDMzW2NdKi4xNzc4OTYrdGhpcy5wMzRbY10qLjA0Mzk3MjU7dGhpcy5wMzRbY109dGhpcy5wMzNbY10sdGhpcy5wMzNbY109dGhpcy5wMzJbY10sdGhpcy5wMzJbY109dGhpcy5wM1tjXSx0aGlzLnAwW2NdKz0oUyhyW2NdW3ZdKmwtdSpwKS1TKHRoaXMucDBbY10pKSpvLHRoaXMucDFbY10rPShTKHRoaXMucDBbY10pLVModGhpcy5wMVtjXSkpKm8sdGhpcy5wMltjXSs9KFModGhpcy5wMVtjXSktUyh0aGlzLnAyW2NdKSkqbyx0aGlzLnAzW2NdKz0oUyh0aGlzLnAyW2NdKS1TKHRoaXMucDNbY10pKSpvLG5bY11bdl09cCpmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigibGFkZGVyLXByb2Nlc3NvciIsd3QpO2NsYXNzIFN0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3N0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImRpc3RvcnQiLGRlZmF1bHRWYWx1ZTowfSx7bmFtZToicG9zdGdhaW4iLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc3RhcnRlZD0hMX1wcm9jZXNzKHQsZSxzKXtjb25zdCByPXRbMF0sbj1lWzBdLGk9clswXSE9PXZvaWQgMDtpZih0aGlzLnN0YXJ0ZWQmJiFpKXJldHVybiExO3RoaXMuc3RhcnRlZD1pO2NvbnN0IGE9TWF0aC5leHBtMShzLmRpc3RvcnRbMF0pLGw9TWF0aC5tYXgoLjAwMSxNYXRoLm1pbigxLHMucG9zdGdhaW5bMF0pKTtmb3IobGV0IG89MDtvPEQ7bysrKWZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKW5bdV1bb109KDErYSkqclt1XVtvXS8oMSthKk1hdGguYWJzKHJbdV1bb10pKSpsO3JldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigiZGlzdG9ydC1wcm9jZXNzb3IiLFN0KTtmdW5jdGlvbiBBdChoLHQsZSl7cmV0dXJuIGUqKHQtaCkraH1mdW5jdGlvbiBQdChoLHQsZSl7cmV0dXJuIGg8Mj8wOkF0KC10Ki41LHQqLjUsZS8oaC0xKSl9ZnVuY3Rpb24gY3QoaCx0KXtyZXR1cm4gaCpNYXRoLnBvdygyLHQvMTIpfWNsYXNzIFR0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBoYXNlPVtdfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6InBhbnNwcmVhZCIsZGVmYXVsdFZhbHVlOi40LG1pbjowLG1heDoxfSx7bmFtZToiZnJlcXNwcmVhZCIsZGVmYXVsdFZhbHVlOi4yLG1pbjowfSx7bmFtZToiZGV0dW5lIixkZWZhdWx0VmFsdWU6MCxtaW46MH0se25hbWU6InZvaWNlcyIsZGVmYXVsdFZhbHVlOjUsbWluOjF9XX1wcm9jZXNzKHQsZSxzKXtpZihjdXJyZW50VGltZTw9cy5iZWdpblswXSlyZXR1cm4hMDtpZihjdXJyZW50VGltZT49cy5lbmRbMF0pcmV0dXJuITE7bGV0IHI9cy5mcmVxdWVuY3lbMF07cj1yKk1hdGgucG93KDIscy5kZXR1bmVbMF0vMTIwMCk7Y29uc3Qgbj1lWzBdLGk9cy52b2ljZXNbMF0sYT1zLmZyZXFzcHJlYWRbMF0sbD1zLnBhbnNwcmVhZFswXSouNSsuNSxvPU1hdGguc3FydCgxLWwpLHU9TWF0aC5zcXJ0KGwpO2ZvcihsZXQgZj0wO2Y8aTtmKyspe2NvbnN0IHY9KGYmMSk9PTEsYz1jdChyLFB0KGksYSxmKSk7bGV0IHA9byxkPXU7diYmKHA9dSxkPW8pO2NvbnN0IGc9Yy9zYW1wbGVSYXRlO2ZvcihsZXQgbT0wO208blswXS5sZW5ndGg7bSsrKXt0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0/P01hdGgucmFuZG9tKCk7Y29uc3QgST1qLnNhd2JsZXAodGhpcy5waGFzZVtmXSxnKTtuWzBdW21dPW5bMF1bbV0rSSpwLG5bMV1bbV09blsxXVttXStJKmQsdGhpcy5waGFzZVtmXSs9Zyx0aGlzLnBoYXNlW2ZdPjEmJih0aGlzLnBoYXNlW2ZdPXRoaXMucGhhc2VbZl0tMSl9fXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3Nvcigic3VwZXJzYXctb3NjaWxsYXRvciIsVHQpO2NvbnN0IHl0PTIwNDg7ZnVuY3Rpb24geHQoaCl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShoKTtmb3IodmFyIGU9MDtlPGg7ZSsrKXRbZV09LjUqKDEtTWF0aC5jb3MoMipNYXRoLlBJKmUvaCkpO3JldHVybiB0fWNsYXNzIEZ0IGV4dGVuZHMgcHR7c3RhdGljIGdldCBwYXJhbWV0ZXJEZXNjcmlwdG9ycygpe3JldHVyblt7bmFtZToicGl0Y2hGYWN0b3IiLGRlZmF1bHRWYWx1ZToxfV19Y29uc3RydWN0b3IodCl7dC5wcm9jZXNzb3JPcHRpb25zPXtibG9ja1NpemU6eXR9LHN1cGVyKHQpLHRoaXMuZmZ0U2l6ZT10aGlzLmJsb2NrU2l6ZSx0aGlzLnRpbWVDdXJzb3I9MCx0aGlzLmhhbm5XaW5kb3c9eHQodGhpcy5ibG9ja1NpemUpLHRoaXMuZmZ0PW5ldyBkdCh0aGlzLmZmdFNpemUpLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXI9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQ9dGhpcy5mZnQuY3JlYXRlQ29tcGxleEFycmF5KCksdGhpcy50aW1lQ29tcGxleEJ1ZmZlcj10aGlzLmZmdC5jcmVhdGVDb21wbGV4QXJyYXkoKSx0aGlzLm1hZ25pdHVkZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmZmdFNpemUvMisxKSx0aGlzLnBlYWtJbmRleGVzPW5ldyBJbnQzMkFycmF5KHRoaXMubWFnbml0dWRlcy5sZW5ndGgpLHRoaXMubmJQZWFrcz0wfXByb2Nlc3NPTEEodCxlLHMpe2xldCByPXMucGl0Y2hGYWN0b3Jbcy5waXRjaEZhY3Rvci5sZW5ndGgtMV07cjwwJiYocj1yKi4yNSkscj1NYXRoLm1heCgwLHIrMSk7Zm9yKHZhciBuPTA7bjx0aGlzLm5iSW5wdXRzO24rKylmb3IodmFyIGk9MDtpPHRbbl0ubGVuZ3RoO2krKyl7dmFyIGE9dFtuXVtpXSxsPWVbbl1baV07dGhpcy5hcHBseUhhbm5XaW5kb3coYSksdGhpcy5mZnQucmVhbFRyYW5zZm9ybSh0aGlzLmZyZXFDb21wbGV4QnVmZmVyLGEpLHRoaXMuY29tcHV0ZU1hZ25pdHVkZXMoKSx0aGlzLmZpbmRQZWFrcygpLHRoaXMuc2hpZnRQZWFrcyhyKSx0aGlzLmZmdC5jb21wbGV0ZVNwZWN0cnVtKHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkKSx0aGlzLmZmdC5pbnZlcnNlVHJhbnNmb3JtKHRoaXMudGltZUNvbXBsZXhCdWZmZXIsdGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQpLHRoaXMuZmZ0LmZyb21Db21wbGV4QXJyYXkodGhpcy50aW1lQ29tcGxleEJ1ZmZlcixsKSx0aGlzLmFwcGx5SGFubldpbmRvdyhsKX10aGlzLnRpbWVDdXJzb3IrPXRoaXMuaG9wU2l6ZX1hcHBseUhhbm5XaW5kb3codCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmJsb2NrU2l6ZTtlKyspdFtlXT10W2VdKnRoaXMuaGFubldpbmRvd1tlXSoxLjYyfWNvbXB1dGVNYWduaXR1ZGVzKCl7Zm9yKHZhciB0PTAsZT0wO3Q8dGhpcy5tYWduaXR1ZGVzLmxlbmd0aDspe2xldCBzPXRoaXMuZnJlcUNvbXBsZXhCdWZmZXJbZV0scj10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2UrMV07dGhpcy5tYWduaXR1ZGVzW3RdPXMqKjIrcioqMix0Kz0xLGUrPTJ9fWZpbmRQZWFrcygpe3RoaXMubmJQZWFrcz0wO3ZhciB0PTI7bGV0IGU9dGhpcy5tYWduaXR1ZGVzLmxlbmd0aC0yO2Zvcig7dDxlOyl7bGV0IHM9dGhpcy5tYWduaXR1ZGVzW3RdO2lmKHRoaXMubWFnbml0dWRlc1t0LTFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdC0yXT49cyl7dCsrO2NvbnRpbnVlfWlmKHRoaXMubWFnbml0dWRlc1t0KzFdPj1zfHx0aGlzLm1hZ25pdHVkZXNbdCsyXT49cyl7dCsrO2NvbnRpbnVlfXRoaXMucGVha0luZGV4ZXNbdGhpcy5uYlBlYWtzXT10LHRoaXMubmJQZWFrcysrLHQrPTJ9fXNoaWZ0UGVha3ModCl7dGhpcy5mcmVxQ29tcGxleEJ1ZmZlclNoaWZ0ZWQuZmlsbCgwKTtmb3IodmFyIGU9MDtlPHRoaXMubmJQZWFrcztlKyspe2xldCBpPXRoaXMucGVha0luZGV4ZXNbZV0sYT1NYXRoLnJvdW5kKGkqdCk7aWYoYT50aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO3ZhciBzPTAscj10aGlzLmZmdFNpemU7aWYoZT4wKXtsZXQgdT10aGlzLnBlYWtJbmRleGVzW2UtMV07cz1pLU1hdGguZmxvb3IoKGktdSkvMil9aWYoZTx0aGlzLm5iUGVha3MtMSl7bGV0IHU9dGhpcy5wZWFrSW5kZXhlc1tlKzFdO3I9aStNYXRoLmNlaWwoKHUtaSkvMil9bGV0IGw9cy1pLG89ci1pO2Zvcih2YXIgbj1sO248bztuKyspe2xldCB1PWkrbixmPWErbjtpZihmPj10aGlzLm1hZ25pdHVkZXMubGVuZ3RoKWJyZWFrO2xldCB2PTIqTWF0aC5QSSooZi11KS90aGlzLmZmdFNpemUsYz1NYXRoLmNvcyh2KnRoaXMudGltZUN1cnNvcikscD1NYXRoLnNpbih2KnRoaXMudGltZUN1cnNvciksZD11KjIsZz1kKzEsbT10aGlzLmZyZXFDb21wbGV4QnVmZmVyW2RdLEk9dGhpcy5mcmVxQ29tcGxleEJ1ZmZlcltnXSxfPW0qYy1JKnAsdz1tKnArSSpjLEI9ZioyLGI9QisxO3RoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW0JdKz1fLHRoaXMuZnJlcUNvbXBsZXhCdWZmZXJTaGlmdGVkW2JdKz13fX19fXJlZ2lzdGVyUHJvY2Vzc29yKCJwaGFzZS12b2NvZGVyLXByb2Nlc3NvciIsRnQpO2NsYXNzIEN0IGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBpPXV0LHRoaXMucGhpPS10aGlzLnBpLHRoaXMuWTA9MCx0aGlzLlkxPTAsdGhpcy5QVz10aGlzLnBpLHRoaXMuQj0yLjMsdGhpcy5kcGhpZj0wLHRoaXMuZW52Zj0wfXN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKXtyZXR1cm5be25hbWU6ImJlZ2luIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZW5kIixkZWZhdWx0VmFsdWU6MCxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLG1pbjowfSx7bmFtZToiZnJlcXVlbmN5IixkZWZhdWx0VmFsdWU6NDQwLG1pbjpOdW1iZXIuRVBTSUxPTn0se25hbWU6ImRldHVuZSIsZGVmYXVsdFZhbHVlOjAsbWluOk51bWJlci5ORUdBVElWRV9JTkZJTklUWSxtYXg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSx7bmFtZToicHVsc2V3aWR0aCIsZGVmYXVsdFZhbHVlOjEsbWluOjAsbWF4Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWX1dfXByb2Nlc3ModCxlLHMpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXJldHVybiExO2lmKGN1cnJlbnRUaW1lPD1zLmJlZ2luWzBdKXJldHVybiEwO2lmKGN1cnJlbnRUaW1lPj1zLmVuZFswXSlyZXR1cm4hMTtjb25zdCByPWVbMF07bGV0IG49MSxpO2ZvcihsZXQgYT0wO2E8KHJbMF0ubGVuZ3RoPz8wKTthKyspe2NvbnN0IGw9KDEtWCh0dChhLHMucHVsc2V3aWR0aCksLS45OSwuOTkpKSp0aGlzLnBpLG89dHQoYSxzLmRldHVuZSksdT1jdCh0dChhLHMuZnJlcXVlbmN5KSxvLzEwMCk7aT11Kih0aGlzLnBpLyhzYW1wbGVSYXRlKi41KSksdGhpcy5kcGhpZis9LjEqKGktdGhpcy5kcGhpZiksbio9Ljk5OTgsdGhpcy5lbnZmKz0uMSoobi10aGlzLmVudmYpLHRoaXMuQj0yLjMqKDEtMWUtNCp1KSx0aGlzLkI8MCYmKHRoaXMuQj0wKSx0aGlzLnBoaSs9dGhpcy5kcGhpZix0aGlzLnBoaT49dGhpcy5waSYmKHRoaXMucGhpLT0yKnRoaXMucGkpO2xldCBmPU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkwKTt0aGlzLlkwPS41KihmK3RoaXMuWTApO2xldCB2PU1hdGguY29zKHRoaXMucGhpK3RoaXMuQip0aGlzLlkxK2wpO3RoaXMuWTE9LjUqKHYrdGhpcy5ZMSk7Zm9yKGxldCBjPTA7YzxyLmxlbmd0aDtjKyspcltjXVthXT0uMTUqKGYtdikqdGhpcy5lbnZmfXJldHVybiEwfX1yZWdpc3RlclByb2Nlc3NvcigicHVsc2Utb3NjaWxsYXRvciIsQ3QpfSkoKTsK";
function U(t) {
  const e = V().createGain();
  return e.gain.value = t, e;
}
const ce = (t, e, n, c) => c - n === 0 ? 0 : (e - t) / (c - n);
function I(t, e, n, c) {
  const a = new AudioWorkletNode(t, e, c);
  return Object.entries(n).forEach(([o, s]) => {
    a.parameters.get(o).value = s;
  }), a;
}
const j = (t, e, n, c, a, o, s, d, l, r = "exponential") => {
  e = k(e), n = k(n), c = k(c), a = k(a);
  const i = r === "exponential" ? "exponentialRampToValueAtTime" : "linearRampToValueAtTime";
  r === "exponential" && (o = o === 0 ? 1e-3 : o, s = s === 0 ? 1e-3 : s);
  const b = s - o, m = s, u = o + c * b, h = l - d, X = (Z) => {
    let y;
    if (e > Z) {
      let p = ce(o, m, 0, e);
      y = Z * p + (o > m ? o : 0);
    } else
      y = (Z - e) * ce(m, u, 0, n) + m;
    return r === "exponential" && (y = y || 1e-3), y;
  };
  t.setValueAtTime(o, d), e > h ? t[i](X(h), l) : e + n > h ? (t[i](X(e), d + e), t[i](X(h), l)) : (t[i](X(e), d + e), t[i](X(e + n), d + e + n), t.setValueAtTime(u, l)), t[i](o, l + a);
};
function Be(t, e, n, c, a, o) {
  const s = {
    threshold: e ?? -3,
    ratio: n ?? 10,
    knee: c ?? 10,
    attack: a ?? 5e-3,
    release: o ?? 0.05
  };
  return new DynamicsCompressorNode(t, s);
}
const E = (t, e = "linear", n) => {
  const [s, d, l, r] = t;
  if (s == null && d == null && l == null && r == null)
    return n ?? [1e-3, 1e-3, 1, 0.01];
  const i = l ?? (s != null && d == null || s == null && d == null ? 1 : 1e-3);
  return [Math.max(s ?? 0, 1e-3), Math.max(d ?? 0, 1e-3), Math.min(i, 1), Math.max(r ?? 0, 0.01)];
};
function ft(t, e, n, c, a, o, s, d, l, r, i, b, m, u) {
  const h = "exponential", [X, Z, y, p] = E([a, o, s, d], h, [5e-3, 0.14, 0, 0.1]);
  let W, x;
  if (m === "ladder" ? (W = I(t, "ladder-processor", { frequency: n, q: c, drive: u }), x = W.parameters.get("frequency")) : (W = t.createBiquadFilter(), W.type = e, W.Q.value = c, W.frequency.value = n, x = W.frequency), (a ?? o ?? s ?? d ?? l) !== void 0) {
    l = k(l, 1, !0), b = k(b, 0, !0);
    const z = Math.abs(l), w = z * b;
    let L = et(2 ** -w * n, 0, 2e4), S = et(2 ** (z - w) * n, 0, 2e4);
    return l < 0 && ([L, S] = [S, L]), j(x, X, Z, y, p, L, S, r, i, h), W;
  }
  return W;
}
let oe = (t) => t < 0.5 ? 1 : 1 - (t - 0.5) / 0.5;
function Qe(t, e, n = 0) {
  const c = V();
  if (!n)
    return t;
  let a = c.createGain(), o = c.createGain();
  t.connect(a), e.connect(o), a.gain.value = oe(n), o.gain.value = oe(1 - n);
  let s = c.createGain();
  return a.connect(s), o.connect(s), s;
}
let Ue = ["linear", "exponential"];
function ut(t, e, n, c) {
  if (!(e.pattack ?? e.pdecay ?? e.psustain ?? e.prelease ?? e.penv))
    return;
  const o = k(e.penv, 1, !0), s = Ue[e.pcurve ?? 0];
  let [d, l, r, i] = E(
    [e.pattack, e.pdecay, e.psustain, e.prelease],
    s,
    [0.2, 1e-3, 1, 1e-3]
  ), b = e.panchor ?? r;
  const m = o * 100, u = 0 - m * b, h = m - m * b;
  j(t, d, l, r, i, u, h, n, c, s);
}
function mt(t, e, n) {
  const { vibmod: c = 0.5, vib: a } = e;
  let o;
  if (a > 0) {
    o = V().createOscillator(), o.frequency.value = a;
    const s = V().createGain();
    return s.gain.value = c * 100, o.connect(s), s.connect(t), o.start(n), o;
  }
}
function se(t, e, n, c) {
  const a = t.createConstantSource();
  return a.start(n), a.stop(c), a.onended = () => {
    e();
  }, a;
}
const je = (t, e = 1, n = "sine") => {
  const c = V(), a = c.createOscillator();
  a.type = n, a.frequency.value = t, a.start();
  const o = new GainNode(c, { gain: e });
  return a.connect(o), { node: o, stop: (s) => a.stop(s) };
}, Ee = (t, e, n, c = "sine") => {
  const o = t.value * e, s = o * n;
  return je(o, s, c);
};
function Lt(t, e, n) {
  const {
    fmh: c = 1,
    fmi: a,
    fmenv: o = "exp",
    fmattack: s,
    fmdecay: d,
    fmsustain: l,
    fmrelease: r,
    fmvelocity: i,
    fmwave: b = "sine",
    duration: m
  } = e;
  let u, h = () => {
  };
  if (a) {
    const Z = V().createGain(), y = Ee(t, c, a, b);
    if (u = y.node, h = y.stop, ![s, d, l, r, i].find((p) => p !== void 0))
      u.connect(t);
    else {
      const [p, W, x, f] = E([s, d, l, r]), z = n + m;
      j(
        Z.gain,
        p,
        W,
        x,
        f,
        0,
        1,
        n,
        z,
        o === "exp" ? "exponential" : "linear"
      ), u.connect(Z), Z.connect(t);
    }
  }
  return { stop: h };
}
const Tt = {}, Wt = {}, Kn = (t) => Tt[t];
function De(t, e) {
  var n = 1024;
  if (t < n) return t + " B";
  var c = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], a = -1;
  do
    t /= n, ++a;
  while (t >= n);
  return t.toFixed(1) + " " + c[a];
}
function Oe(t, e) {
  const { s: n, n: c = 0, speed: a = 1 } = t;
  let o = Ie(t, 36), s = o - 36, d, l = 0;
  if (Array.isArray(e))
    l = ne(c, e.length), d = e[l];
  else {
    const b = (u) => Xt(u) - o, m = Object.keys(e).filter((u) => !u.startsWith("_")).reduce(
      (u, h, X) => !u || Math.abs(b(h)) < Math.abs(b(u)) ? h : u,
      null
    );
    s = -b(m), l = ne(c, e[m].length), d = e[m][l];
  }
  const r = `${n}:${l}`;
  let i = Math.abs(a) * Math.pow(2, s / 12);
  return { transpose: s, sampleUrl: d, index: l, midi: o, label: r, playbackRate: i };
}
const Ae = async (t, e, n) => {
  let { sampleUrl: c, label: a, playbackRate: o } = Oe(t, e);
  n && (c = await n(c));
  const s = V(), d = await ue(c, s, a);
  return t.unit === "c" && (o = o * d.duration), { buffer: d, playbackRate: o };
}, qe = async (t, e, n) => {
  let { buffer: c, playbackRate: a } = await Ae(t, e, n);
  t.speed < 0 && (c = _e(c));
  const s = V().createBufferSource();
  s.buffer = c, s.playbackRate.value = a;
  const { s: d, loopBegin: l = 0, loopEnd: r = 1, begin: i = 0, end: b = 1 } = t, m = i * s.buffer.duration;
  (d.startsWith("wt_") ? 1 : t.loop) && (s.loop = !0, s.loopStart = l * s.buffer.duration - m, s.loopEnd = r * s.buffer.duration - m);
  const h = s.buffer.duration / s.playbackRate.value, X = (b - i) * h;
  return { bufferSource: s, offset: m, bufferDuration: h, sliceDuration: X };
}, ue = (t, e, n, c = 0) => {
  const a = n ? `sound "${n}:${c}"` : "sample";
  if (t = t.replace("#", "%23"), !Wt[t]) {
    N(`[sampler] load ${a}..`, "load-sample", { url: t });
    const o = Date.now();
    Wt[t] = fetch(t).then((s) => s.arrayBuffer()).then(async (s) => {
      const d = Date.now() - o, l = De(s.byteLength);
      N(`[sampler] load ${a}... done! loaded ${l} in ${d}ms`, "loaded-sample", { url: t });
      const r = await e.decodeAudioData(s);
      return Tt[t] = r, r;
    });
  }
  return Wt[t];
};
function _e(t) {
  const e = V(), n = e.createBuffer(t.numberOfChannels, t.length, e.sampleRate);
  for (let c = 0; c < t.numberOfChannels; c++)
    n.copyToChannel(t.getChannelData(c).slice().reverse(), c, c);
  return n;
}
const Sn = (t) => Tt[t];
function me(t) {
  if (t.startsWith("bubo:")) {
    const [e, n] = t.split(":");
    t = `github:Bubobubobubobubo/dough-${n}`;
  }
  return t;
}
function be(t, e = "") {
  if (!t.startsWith("github:"))
    throw new Error('expected "github:" at the start of pseudoUrl');
  let [n, c] = t.split("github:");
  return c = c.endsWith("/") ? c.slice(0, -1) : c, c.split("/").length === 2 && (c += "/main"), `https://raw.githubusercontent.com/${c}/${e}`;
}
const $e = (t, e, n = t._base || "") => Object.entries(t).forEach(([c, a]) => {
  if (typeof a == "string" && (a = [a]), typeof a != "object")
    throw new Error("wrong sample map format for " + c);
  n = a._base || n, n = me(n), n.startsWith("github:") && (n = be(n, ""));
  const o = (s) => n + s;
  Array.isArray(a) ? a = a.map(o) : a = Object.fromEntries(
    Object.entries(a).map(([s, d]) => [s, (typeof d == "string" ? [d] : d).map(o)])
  ), e(c, a);
});
let he = {};
function Hn(t, e) {
  he[t] = e;
}
function tn(t) {
  const e = Object.entries(he).find(([n]) => t.startsWith(n));
  if (e)
    return e[1];
}
const en = async (t, e = t._base || "", n = {}) => {
  if (typeof t == "string") {
    const o = tn(t);
    if (o)
      return o(t);
    if (t = me(t), t.startsWith("github:") && (t = be(t, "strudel.json")), t.startsWith("local:") && (t = "http://localhost:5432"), t.startsWith("shabda:")) {
      let [d, l] = t.split("shabda:");
      t = `https://shabda.ndre.gr/${l}.json?strudel=1`;
    }
    if (t.startsWith("shabda/speech")) {
      let [d, l] = t.split("shabda/speech");
      l = l.startsWith("/") ? l.substring(1) : l;
      let [r, i] = l.split(":"), b = "f", m = "en-GB";
      r && ([m, b] = r.split("/")), t = `https://shabda.ndre.gr/speech/${i}.json?gender=${b}&language=${m}&strudel=1'`;
    }
    if (typeof fetch != "function")
      return;
    const s = t.split("/").slice(0, -1).join("/");
    return typeof fetch > "u" ? void 0 : fetch(t).then((d) => d.json()).then((d) => en(d, e || d._base || s, n)).catch((d) => {
      throw console.error(d), new Error(`error loading "${t}"`);
    });
  }
  const { prebake: c, tag: a } = n;
  $e(
    t,
    (o, s) => q(o, (d, l, r) => nn(d, l, r, s), {
      type: "sample",
      samples: s,
      baseUrl: e,
      prebake: c,
      tag: a
    }),
    e
  );
}, ae = [];
async function nn(t, e, n, c, a) {
  let {
    s: o,
    nudge: s = 0,
    // TODO: is this in seconds?
    cut: d,
    loop: l,
    clip: r = void 0,
    // if set, samples will be cut off when the hap ends
    n: i = 0,
    speed: b = 1,
    // sample playback speed
    duration: m
  } = e;
  if (b === 0)
    return;
  const u = V();
  let [h, X, Z, y] = E([e.attack, e.decay, e.sustain, e.release]);
  const { bufferSource: p, sliceDuration: W, offset: x } = await qe(e, c, a);
  if (u.currentTime > t) {
    N(`[sampler] still loading sound "${o}:${i}"`, "highlight");
    return;
  }
  if (!p) {
    N(`[sampler] could not load "${o}:${i}"`, "error");
    return;
  }
  let f = mt(p.detune, e, t);
  const z = t + s;
  p.start(z, x);
  const w = u.createGain(), L = p.connect(w);
  r == null && l == null && e.release == null && (m = W);
  let S = t + m;
  j(L.gain, h, X, Z, y, 0, 1, t, S, "linear"), ut(p.detune, e, t, S);
  const K = u.createGain();
  L.connect(K), p.onended = function() {
    p.disconnect(), f?.stop(), L.disconnect(), K.disconnect(), n();
  };
  let B = S + y + 0.01;
  p.stop(B);
  const H = { node: K, bufferSource: p, stop: (J) => {
    p.stop(J);
  } };
  if (d !== void 0) {
    const J = ae[d];
    J && (J.node.gain.setValueAtTime(1, z), J.node.gain.linearRampToValueAtTime(0, z + 0.01)), ae[d] = H;
  }
  return H;
}
const Xe = 128, Kt = "System Standard";
let Ze = Xe;
function cn(t) {
  Ze = parseInt(t) ?? Xe;
}
const st = Te();
function q(t, e, n = {}) {
  t = t.toLowerCase().replace(/\s+/g, "_"), st.setKey(t, { onTrigger: e, data: n });
}
let pe = (t) => t;
function A(t) {
  return pe(t);
}
function wn(t) {
  pe = t;
}
function St(t) {
  for (const n in t)
    t[n.toLowerCase()] = t[n];
  const e = st.get();
  for (const n in e) {
    const [c, a] = n.split("_");
    if (!a) continue;
    const o = t[c];
    if (o) {
      if (typeof o == "string")
        e[`${o}_${a}`.toLowerCase()] = e[n];
      else if (Array.isArray(o))
        for (const s of o)
          e[`${s}_${a}`.toLowerCase()] = e[n];
    }
  }
  st.set({ ...e });
}
async function on(t) {
  const n = await (await fetch(t)).json();
  St(n);
}
async function Tn(...t) {
  switch (t.length) {
    case 1:
      return typeof t[0] == "string" ? on(t[0]) : St(t[0]);
    case 2:
      return St({ [t[0]]: t[1] });
    default:
      throw new Error("aliasMap expects 1 or 2 arguments, received " + t.length);
  }
}
function xt(t) {
  return st.get()[t.toLowerCase()];
}
const sn = async () => {
  await navigator.mediaDevices.getUserMedia({ audio: !0 });
  let t = await navigator.mediaDevices.enumerateDevices();
  t = t.filter((n) => n.kind === "audiooutput" && n.deviceId !== "default");
  const e = /* @__PURE__ */ new Map();
  return e.set(Kt, ""), t.forEach((n) => {
    e.set(n.label, n.deviceId);
  }), e;
}, Ge = {
  s: "triangle",
  gain: 0.8,
  postgain: 1,
  density: ".03",
  ftype: "12db",
  fanchor: 0,
  resonance: 1,
  hresonance: 1,
  bandq: 1,
  channels: [1, 2],
  phaserdepth: 0.75,
  shapevol: 1,
  distortvol: 1,
  delay: 0,
  delayfeedback: 0.5,
  delaytime: 0.25,
  orbit: 1,
  i: 1,
  velocity: 1,
  fft: 8
};
let Nt = new Map(Object.entries(Ge));
function ye(t, e) {
  Nt.set(t, e);
}
function g(t) {
  return Nt.get(t);
}
function Nn(t) {
  Object.keys(t).forEach((e) => {
    ye(e, t[e]);
  });
}
function an() {
  Nt = new Map(Object.entries(Ge));
}
function Yn(t) {
  an(), t === "1.0" && ye("fanchor", 0.5);
}
const Fn = () => st.set({});
let bt;
const dn = () => (bt = new AudioContext(), bt), V = () => bt || dn();
function Pn() {
  return V().currentTime;
}
let Mt;
function ln() {
  return Mt || (Mt = V().audioWorklet.addModule(ke)), Mt;
}
async function rn(t = {}) {
  const { disableWorklets: e = !1, maxPolyphony: n, audioDeviceName: c = Kt } = t;
  if (cn(n), typeof window > "u")
    return;
  const a = V();
  if (c != null && c != Kt)
    try {
      const s = (await sn()).get(c), d = (s ?? "").length > 0;
      a.sinkId !== s && d && await a.setSinkId(s), N(
        `[superdough] Audio Device set to ${c}, it might take a few seconds before audio plays on all output channels`
      );
    } catch {
      N("[superdough] failed to set audio interface", "warning");
    }
  if (await a.resume(), e) {
    N("[superdough]: AudioWorklets disabled with disableWorklets");
    return;
  }
  try {
    await ln(), N("[superdough] AudioWorklets loaded");
  } catch (o) {
    console.warn("could not load AudioWorklet effects", o);
  }
  N("[superdough] ready");
}
let Rt;
async function Cn(t) {
  return Rt || (Rt = new Promise((e) => {
    document.addEventListener("click", async function n() {
      document.removeEventListener("click", n), await rn(t), e();
    });
  })), Rt;
}
let Q = {}, ht, _;
function un() {
  const t = V(), e = t.destination.maxChannelCount;
  t.destination.channelCount = e, ht = new ChannelMergerNode(t, { numberOfInputs: t.destination.channelCount }), _ = new GainNode(t), ht.connect(_), _.connect(t.destination);
}
const Yt = (t, e = [0, 1]) => {
  const n = V();
  ht == null && un();
  const c = new StereoPannerNode(n);
  t.connect(c);
  const a = new ChannelSplitterNode(n, {
    numberOfOutputs: c.channelCount
  });
  c.connect(a), e.forEach((o, s) => {
    a.connect(ht, s % c.channelCount, et(o, 0, n.destination.channelCount - 1));
  });
}, vn = () => {
  _ != null && (_.gain.linearRampToValueAtTime(0, V().currentTime + 0.01), _ = null);
};
function mn(t, e, n, c) {
  if (n = et(n, 0, 0.98), !Q[t]) {
    const o = V().createFeedbackDelay(1, e, n);
    o.start?.(c), Yt(o, [0, 1]), Q[t] = o;
  }
  return Q[t].delayTime.value !== e && Q[t].delayTime.setValueAtTime(e, c), Q[t].feedback.value !== n && Q[t].feedback.setValueAtTime(n, c), Q[t];
}
function bn(t, e, n = 1, c = 0.5, a = 1e3, o = 2e3) {
  const s = V(), d = s.createGain();
  d.gain.value = o * 2, I(s, "lfo-processor", {
    frequency: n,
    depth: 1,
    skew: 0,
    phaseoffset: 0,
    time: t,
    end: e,
    shape: 1,
    dcoffset: -0.5
  }).connect(d);
  const r = 2;
  let i = 0;
  const b = [];
  for (let m = 0; m < r; m++) {
    const u = s.createBiquadFilter();
    u.type = "notch", u.gain.value = 1, u.frequency.value = a + i, u.Q.value = 2 - Math.min(Math.max(c * 2, 0), 1.9), d.connect(u.detune), i += 282, m > 0 && b[m - 1].connect(u), b.push(u);
  }
  return b[b.length - 1];
}
function hn(t) {
  t = t ?? 0;
  const e = ["12db", "ladder", "24db"];
  return typeof t == "number" ? e[Math.floor(ie(t, e.length))] : t;
}
let C = {}, it = (t, e) => t !== void 0 && t !== e;
function Xn(t, e, n, c, a, o) {
  if (!C[t]) {
    const d = V().createReverb(e, n, c, a, o);
    Yt(d, [0, 1]), C[t] = d;
  }
  return (it(e, C[t].duration) || it(n, C[t].fade) || it(c, C[t].lp) || it(a, C[t].dim) || C[t].ir !== o) && C[t].generate(e, n, c, a, o), C[t];
}
let v = {}, $ = {};
function Zn(t, e = 1024, n = 0.5) {
  if (!v[t]) {
    const c = V().createAnalyser();
    c.fftSize = e, c.smoothingTimeConstant = n, v[t] = c, $[t] = new Float32Array(v[t].frequencyBinCount);
  }
  return v[t].fftSize !== e && (v[t].fftSize = e, $[t] = new Float32Array(v[t].frequencyBinCount)), v[t];
}
function Jn(t = "time", e = 1) {
  const n = {
    time: () => v[e]?.getFloatTimeDomainData($[e]),
    frequency: () => v[e]?.getFloatFrequencyData($[e])
  }[t];
  if (!n)
    throw new Error(`getAnalyzerData: ${t} not supported. use one of ${Object.keys(n).join(", ")}`);
  return n(), $[e];
}
function zt(t, e, n) {
  const c = U(n);
  return t.connect(c), c.connect(e), c;
}
function In() {
  Q = {}, C = {}, v = {}, $ = {};
}
let ot = /* @__PURE__ */ new Map();
const pn = async (t, e, n) => {
  const c = V();
  e = typeof e == "string" && e.startsWith("=") ? Number(e.slice(1)) : c.currentTime + e;
  let { stretch: a } = t;
  if (a != null && (e = e - 0.04), typeof t != "object")
    throw new Error(
      `expected hap.value to be an object, but got "${t}". Hint: append .note() or .s() to the end`,
      "error"
    );
  if (t.duration = n, e < c.currentTime) {
    console.warn(
      `[superdough]: cannot schedule sounds in the past (target: ${e.toFixed(2)}, now: ${c.currentTime.toFixed(2)})`
    );
    return;
  }
  let {
    s: o = g("s"),
    bank: s,
    source: d,
    gain: l = g("gain"),
    postgain: r = g("postgain"),
    density: i = g("density"),
    // filters
    fanchor: b = g("fanchor"),
    drive: m = 0.69,
    // low pass
    cutoff: u,
    lpenv: h,
    lpattack: X,
    lpdecay: Z,
    lpsustain: y,
    lprelease: p,
    resonance: W = g("resonance"),
    // high pass
    hpenv: x,
    hcutoff: f,
    hpattack: z,
    hpdecay: w,
    hpsustain: L,
    hprelease: S,
    hresonance: K = g("hresonance"),
    // band pass
    bpenv: B,
    bandf: M,
    bpattack: H,
    bpdecay: J,
    bpsustain: Zt,
    bprelease: Y,
    bandq: nt = g("bandq"),
    channels: T = g("channels"),
    //phaser
    phaserrate: at,
    phaserdepth: Ft = g("phaserdepth"),
    phasersweep: We,
    phasercenter: xe,
    //
    coarse: Pt,
    crush: Ct,
    shape: vt,
    shapevol: pt = g("shapevol"),
    distort: Jt,
    distortvol: Gt = g("distortvol"),
    pan: It,
    vowel: kt,
    delay: dt = g("delay"),
    delayfeedback: Bt = g("delayfeedback"),
    delaytime: Qt = g("delaytime"),
    orbit: Ut = g("orbit"),
    room: jt,
    roomfade: Me,
    roomlp: Re,
    roomdim: ze,
    roomsize: ge,
    ir: yt,
    i: Et = g("i"),
    velocity: Vt = g("velocity"),
    analyze: Dt,
    // analyser wet
    fft: Le = g("fft"),
    // fftSize 0 - 10
    compressor: Ot,
    compressorRatio: Ke,
    compressorKnee: Se,
    compressorAttack: He,
    compressorRelease: we
  } = t;
  l = A(k(l, 1)), r = A(r), pt = A(pt), Gt = A(Gt), dt = A(dt), Vt = A(Vt), l *= Vt;
  const At = Math.round(Math.random() * 1e6);
  for (let G = 0; G <= ot.size - Ze; G++) {
    const D = ot.entries().next(), F = D.value[1], P = D.value[0], te = e + 0.25;
    F?.node?.gain?.linearRampToValueAtTime(0, te), F?.stop?.(te), ot.delete(P);
  }
  T = (Array.isArray(T) ? T : [T]).map((G) => G - 1);
  let O = [];
  s && o && (o = `${s}_${o}`, t.s = o);
  let lt;
  if (d)
    lt = d(e, t, n);
  else if (xt(o)) {
    const { onTrigger: G } = xt(o), F = await G(e, t, () => {
      O.forEach((P) => P?.disconnect()), ot.delete(At);
    });
    F && (lt = F.node, ot.set(At, F));
  } else
    throw new Error(`sound ${o} not found! Is it loaded?`);
  if (!lt)
    return;
  if (c.currentTime > e) {
    N("[webaudio] skip hap: still loading", c.currentTime - e);
    return;
  }
  const R = [];
  R.push(lt), a !== void 0 && R.push(I(c, "phase-vocoder-processor", { pitchFactor: a })), R.push(U(l));
  const rt = hn(t.ftype);
  if (u !== void 0) {
    let G = () => ft(
      c,
      "lowpass",
      u,
      W,
      X,
      Z,
      y,
      p,
      h,
      e,
      e + n,
      b,
      rt,
      m
    );
    R.push(G()), rt === "24db" && R.push(G());
  }
  if (f !== void 0) {
    let G = () => ft(
      c,
      "highpass",
      f,
      K,
      z,
      w,
      L,
      S,
      x,
      e,
      e + n,
      b
    );
    R.push(G()), rt === "24db" && R.push(G());
  }
  if (M !== void 0) {
    let G = () => ft(
      c,
      "bandpass",
      M,
      nt,
      H,
      J,
      Zt,
      Y,
      B,
      e,
      e + n,
      b
    );
    R.push(G()), rt === "24db" && R.push(G());
  }
  if (kt !== void 0) {
    const G = c.createVowelFilter(kt);
    R.push(G);
  }
  if (Pt !== void 0 && R.push(I(c, "coarse-processor", { coarse: Pt })), Ct !== void 0 && R.push(I(c, "crush-processor", { crush: Ct })), vt !== void 0 && R.push(I(c, "shape-processor", { shape: vt, postgain: pt })), Jt !== void 0 && R.push(I(c, "distort-processor", { distort: Jt, postgain: Gt })), Ot !== void 0 && R.push(
    Be(c, Ot, Ke, Se, He, we)
  ), It !== void 0) {
    const G = c.createStereoPanner();
    G.pan.value = 2 * It - 1, R.push(G);
  }
  if (at !== void 0 && Ft > 0) {
    const G = bn(e, e + n, at, Ft, xe, We);
    R.push(G);
  }
  const ct = new GainNode(c, { gain: r });
  R.push(ct), Yt(ct, T);
  let qt;
  if (dt > 0 && Qt > 0 && Bt > 0) {
    const G = mn(Ut, Qt, Bt, e);
    qt = zt(ct, G, dt), O.push(qt);
  }
  let _t;
  if (jt > 0) {
    let G;
    if (yt !== void 0) {
      let F, P = xt(yt);
      Array.isArray(P) ? F = P.data.samples[Et % P.data.samples.length] : typeof P == "object" && (F = Object.values(P.data.samples).flat()[Et % Object.values(P.data.samples).length]), G = await ue(F, c, yt, 0);
    }
    const D = Xn(Ut, ge, Me, Re, ze, G);
    _t = zt(ct, D, jt), O.push(_t);
  }
  let $t;
  if (Dt) {
    const G = Zn(Dt, 2 ** (Le + 5));
    $t = zt(ct, G, 1), O.push($t);
  }
  R.slice(1).reduce((G, D) => G.connect(D), R[0]), O = O.concat(R);
}, kn = (t, e, n, c) => {
  pn(e, t - n, e.duration / c);
};
let gt = {};
function Gn(t, e) {
  const n = V();
  if (gt[t])
    return gt[t];
  const c = 2 * n.sampleRate, a = n.createBuffer(1, c, n.sampleRate), o = a.getChannelData(0);
  let s = 0, d, l, r, i, b, m, u;
  d = l = r = i = b = m = u = 0;
  for (let h = 0; h < c; h++)
    if (t === "white")
      o[h] = Math.random() * 2 - 1;
    else if (t === "brown") {
      let X = Math.random() * 2 - 1;
      o[h] = (s + 0.02 * X) / 1.02, s = o[h];
    } else if (t === "pink") {
      let X = Math.random() * 2 - 1;
      d = 0.99886 * d + X * 0.0555179, l = 0.99332 * l + X * 0.0750759, r = 0.969 * r + X * 0.153852, i = 0.8665 * i + X * 0.3104856, b = 0.55 * b + X * 0.5329522, m = -0.7616 * m - X * 0.016898, o[h] = d + l + r + i + b + m + u + X * 0.5362, o[h] *= 0.11, u = X * 0.115926;
    } else if (t === "crackle") {
      const X = e * 0.01;
      Math.random() < X ? o[h] = Math.random() * 2 - 1 : o[h] = 0;
    }
  return t !== "crackle" && (gt[t] = a), a;
}
function Ve(t = "white", e, n = 0.02) {
  const a = V().createBufferSource();
  return a.buffer = Gn(t, n), a.loop = !0, a.start(e), {
    node: a,
    stop: (o) => a.stop(o)
  };
}
function yn(t, e, n) {
  const c = Ve("pink", n);
  return {
    node: Qe(t, c.node, e),
    stop: (o) => c?.stop(o)
  };
}
const Ht = (t) => {
  let { note: e, freq: n } = t;
  return e = e || 36, typeof e == "string" && (e = Xt(e)), !n && typeof e == "number" && (n = re(e)), Number(n);
};
function de(t) {
  t.disconnect(), t.parameters.get("end")?.setValueAtTime(0, 0);
}
const Vn = ["triangle", "square", "sawtooth", "sine"], fn = ["pink", "white", "brown", "crackle"];
function Bn() {
  [...Vn].forEach((t) => {
    q(
      t,
      (e, n, c) => {
        const [a, o, s, d] = E(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l = xn(t, e, n), { node: r, stop: i, triggerRelease: b } = l;
        const m = U(0.3), { duration: u } = n;
        r.onended = () => {
          r.disconnect(), m.disconnect(), c();
        };
        const h = U(1);
        let X = r.connect(m).connect(h);
        const Z = e + u;
        j(X.gain, a, o, s, d, 0, 1, e, Z, "linear");
        const y = Z + d + 0.01;
        return b?.(y), i(y), {
          node: X,
          stop: (p) => {
            i(p);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  }), q(
    "supersaw",
    (t, e, n) => {
      const c = V();
      let { duration: a, n: o, unison: s = 5, spread: d = 0.6, detune: l } = e;
      l = l ?? o ?? 0.18;
      const r = Ht(e), [i, b, m, u] = E(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), h = t + a, X = h + u + 0.01, Z = et(s, 1, 100);
      let y = Z > 1 ? et(d, 0, 1) : 0, p = I(
        c,
        "supersaw-oscillator",
        {
          frequency: r,
          begin: t,
          end: X,
          freqspread: l,
          voices: Z,
          panspread: y
        },
        {
          outputChannelCount: [2]
        }
      );
      const W = 1 / Math.sqrt(Z);
      ut(p.parameters.get("detune"), e, t, h);
      const x = mt(p.parameters.get("detune"), e, t), f = Lt(p.parameters.get("frequency"), e, t);
      let z = U(1);
      z = p.connect(z), j(z.gain, i, b, m, u, 0, 0.3 * W, t, h, "linear");
      let w = se(
        c,
        () => {
          de(p), z.disconnect(), n(), f?.stop(), x?.stop();
        },
        t,
        X
      );
      return {
        node: z,
        stop: (L) => {
          w.stop(L);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), q(
    "pulse",
    (t, e, n) => {
      const c = V();
      let { duration: a, n: o = 0.5 } = e;
      const s = Ht(e), [d, l, r, i] = E(
        [e.attack, e.decay, e.sustain, e.release],
        "linear",
        [1e-3, 0.05, 0.6, 0.01]
      ), b = t + a, m = b + i + 0.01;
      let u = I(
        c,
        "pulse-oscillator",
        {
          frequency: s,
          begin: t,
          end: m,
          pulsewidth: o
        },
        {
          outputChannelCount: [2]
        }
      );
      ut(u.parameters.get("detune"), e, t, b);
      const h = mt(u.parameters.get("detune"), e, t), X = Lt(u.parameters.get("frequency"), e, t);
      let Z = U(1);
      Z = u.connect(Z), j(Z.gain, d, l, r, i, 0, 1, t, b, "linear");
      let y = se(
        c,
        () => {
          de(u), Z.disconnect(), n(), X?.stop(), h?.stop();
        },
        t,
        m
      );
      return {
        node: Z,
        stop: (p) => {
          y.stop(p);
        }
      };
    },
    { prebake: !0, type: "synth" }
  ), [...fn].forEach((t) => {
    q(
      t,
      (e, n, c) => {
        const [a, o, s, d] = E(
          [n.attack, n.decay, n.sustain, n.release],
          "linear",
          [1e-3, 0.05, 0.6, 0.01]
        );
        let l, { density: r } = n;
        l = Ve(t, e, r);
        let { node: i, stop: b, triggerRelease: m } = l;
        const u = U(0.3), { duration: h } = n;
        i.onended = () => {
          i.disconnect(), u.disconnect(), c();
        };
        const X = U(1);
        let Z = i.connect(u).connect(X);
        const y = e + h;
        j(Z.gain, a, o, s, d, 0, 1, e, y, "linear");
        const p = y + d + 0.01;
        return m?.(p), b(p), {
          node: Z,
          stop: (W) => {
            b(W);
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
function Wn(t, e) {
  const n = new Float32Array(t + 1), c = new Float32Array(t + 1), a = V(), o = a.createOscillator(), s = {
    sawtooth: (r) => [0, -1 / r],
    square: (r) => [0, r % 2 === 0 ? 0 : 1 / r],
    triangle: (r) => [r % 2 === 0 ? 0 : 1 / (r * r), 0]
  };
  if (!s[e])
    throw new Error(`unknown wave type ${e}`);
  n[0] = 0, c[0] = 0;
  let d = 1;
  for (; d <= t; ) {
    const [r, i] = s[e](d);
    n[d] = r, c[d] = i, d++;
  }
  const l = a.createPeriodicWave(n, c);
  return o.setPeriodicWave(l), o;
}
function xn(t, e, n) {
  let { n: c, duration: a, noise: o = 0 } = n, s;
  !c || t === "sine" ? (s = V().createOscillator(), s.type = t || "triangle") : s = Wn(c, t), s.frequency.value = Ht(n), s.start(e);
  let d = mt(s.detune, n, e);
  ut(s.detune, n, e, e + a);
  const l = Lt(s.frequency, n, e);
  let r;
  return o && (r = yn(s, o, e)), {
    node: r?.node || s,
    stop: (i) => {
      l.stop(i), d?.stop(i), r?.stop(i), s.stop(i);
    },
    triggerRelease: (i) => {
    }
  };
}
function Mn(t = 1, e = 0.05, n = 220, c = 0, a = 0, o = 0.1, s = 0, d = 1, l = 0, r = 0, i = 0, b = 0, m = 0, u = 0, h = 0, X = 0, Z = 0, y = 1, p = 0, W = 0) {
  let x = Math.PI * 2, f = V().sampleRate, z = (at) => at > 0 ? 1 : -1, w = l *= 500 * x / f / f, L = n *= (1 + e * 2 * Math.random() - e) * x / f, S = [], K = 0, B = 0, M = 0, H = 1, J = 0, Zt = 0, Y = 0, nt, T;
  for (c = c * f + 9, p *= f, a *= f, o *= f, Z *= f, r *= 500 * x / f ** 3, h *= x / f, i *= x / f, b *= f, m = m * f | 0, T = c + p + a + o + Z | 0; M < T; S[M++] = Y)
    ++Zt % (X * 100 | 0) || (Y = s ? s > 1 ? s > 2 ? s > 3 ? Math.sin((K % x) ** 3) : Math.max(Math.min(Math.tan(K), 1), -1) : 1 - (2 * K / x % 2 + 2) % 2 : 1 - 4 * Math.abs(Math.round(K / x) - K / x) : Math.sin(K), Y = (m ? 1 - W + W * Math.sin(x * M / m) : 1) * z(Y) * Math.abs(Y) ** d * // curve 0=square, 2=pointy
    t * 1 * // envelope
    (M < c ? M / c : M < c + p ? 1 - (M - c) / p * (1 - y) : M < c + p + a ? y : M < T - Z ? (T - M - Z) / o * // release falloff
    y : 0), Y = Z ? Y / 2 + (Z > M ? 0 : (M < T - Z ? 1 : (T - M) / Z) * // release delay
    S[M - Z | 0] / 2) : Y), nt = (n += l += r) * // frequency
    Math.cos(h * B++), K += nt - nt * u * (1 - (Math.sin(M) + 1) * 1e9 % 2), H && ++H > b && (n += i, L += i, H = 0), m && !(++J % m) && (n = L, l = w, H ||= 1);
  return S;
}
const Rn = (t, e) => {
  let {
    s: n,
    note: c = 36,
    freq: a,
    //
    zrand: o = 0,
    attack: s = 0,
    decay: d = 0,
    sustain: l = 0.8,
    release: r = 0.1,
    curve: i = 1,
    slide: b = 0,
    deltaSlide: m = 0,
    pitchJump: u = 0,
    pitchJumpTime: h = 0,
    lfo: X = 0,
    znoise: Z = 0,
    zmod: y = 0,
    zcrush: p = 0,
    zdelay: W = 0,
    tremolo: x = 0,
    duration: f = 0.2,
    zzfx: z
  } = t;
  const w = Math.max(f - s - d, 0);
  typeof c == "string" && (c = Xt(c)), !a && typeof c == "number" && (a = re(c)), n = n.replace("z_", "");
  const L = ["sine", "triangle", "sawtooth", "tan", "noise"].indexOf(n) || 0;
  i = n === "square" ? 0 : i;
  const K = (
    /* ZZFX. */
    Mn(...z || [
      0.25,
      // volume
      o,
      a,
      s,
      w,
      r,
      L,
      i,
      b,
      m,
      u,
      h,
      X,
      Z,
      y,
      p,
      W,
      l,
      // sustain volume!
      d,
      x
    ])
  ), B = V(), M = B.createBuffer(1, K.length, B.sampleRate);
  M.getChannelData(0).set(K);
  const H = V().createBufferSource();
  return H.buffer = M, H.start(e), {
    node: H
  };
};
function Qn() {
  ["zzfx", "z_sine", "z_sawtooth", "z_triangle", "z_square", "z_tan", "z_noise"].forEach((t) => {
    q(
      t,
      (e, n, c) => {
        const { node: a } = Rn({ s: t, ...n }, e);
        return a.onended = () => {
          a.disconnect(), c();
        }, {
          node: a,
          stop: () => {
          }
        };
      },
      { type: "synth", prebake: !0 }
    );
  });
}
let tt;
async function zn(t, e) {
  const n = `dsp-worklet-${Date.now()}`, c = `${e}
let __q = []; // trigger queue
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.t = 0;
    this.stopped = false;
    this.port.onmessage = (e) => {
      if(e.data==='stop') {
        this.stopped = true;
      } else if(e.data?.dough) {
        __q.push(e.data)
      } else {
        msg?.(e.data)
      }
    };
  }
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    if(__q.length) {
      for(let i=0;i<__q.length;++i) {
        const deadline = __q[i].time-currentTime;
        if(deadline<=0) {
          trigger(__q[i].dough)
          __q.splice(i,1)
        }
      }
    }
    for (let i = 0; i < output[0].length; i++) {
      const out = dsp(this.t / sampleRate);
      output.forEach((channel) => {
        channel[i] = out;
      });
      this.t++;
    }
  return !this.stopped;
  }
}
registerProcessor('${n}', MyProcessor);
`, o = `data:text/javascript;base64,${btoa(c)}`;
  await t.audioWorklet.addModule(o);
  const s = new AudioWorkletNode(t, n);
  return { node: s, stop: () => s.port.postMessage("stop") };
}
const fe = () => {
  tt && (tt?.stop(), tt?.node?.disconnect());
};
typeof window < "u" && window.addEventListener("message", (t) => {
  t.data === "strudel-stop" ? fe() : t.data?.dough && tt?.node.port.postMessage(t.data);
});
const Un = async (t) => {
  const e = V();
  fe(), tt = await zn(e, t), tt.node.connect(e.destination);
};
function jn(t, e, n, c, a) {
  window.postMessage({ time: a, dough: e.value, currentTime: n, duration: e.duration, cps: c });
}
export {
  Xe as DEFAULT_MAX_POLYPHONY,
  Tn as aliasBank,
  v as analysers,
  $ as analysersData,
  Lt as applyFM,
  A as applyGainCurve,
  Yt as connectToDestination,
  ft as createFilter,
  Un as dough,
  jn as doughTrigger,
  Qe as drywet,
  zn as dspWorklet,
  U as gainNode,
  E as getADSRValues,
  Zn as getAnalyserById,
  Jn as getAnalyzerData,
  V as getAudioContext,
  Pn as getAudioContextCurrentTime,
  sn as getAudioDevices,
  Kn as getCachedBuffer,
  Be as getCompressor,
  g as getDefaultValue,
  Sn as getLoadedBuffer,
  xn as getOscillator,
  j as getParamADSR,
  ut as getPitchEnvelope,
  Ae as getSampleBuffer,
  qe as getSampleBufferSource,
  Oe as getSampleInfo,
  xt as getSound,
  mt as getVibratoOscillator,
  I as getWorklet,
  Rn as getZZFX,
  rn as initAudio,
  Cn as initAudioOnFirstClick,
  un as initializeAudioOutput,
  ue as loadBuffer,
  N as logger,
  nn as onTriggerSample,
  vn as panic,
  $e as processSampleMap,
  Hn as registerSamplesPrefix,
  q as registerSound,
  Bn as registerSynthSounds,
  Qn as registerZZFXSounds,
  an as resetDefaultValues,
  In as resetGlobalEffects,
  Fn as resetLoadedSounds,
  _e as reverseBuffer,
  en as samples,
  dn as setDefaultAudioContext,
  ye as setDefaultValue,
  Nn as setDefaultValues,
  wn as setGainCurve,
  Ln as setLogger,
  cn as setMaxPolyphony,
  Yn as setVersionDefaults,
  st as soundMap,
  pn as superdough,
  kn as superdoughTrigger,
  Wn as waveformN,
  se as webAudioTimeout
};
